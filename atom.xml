<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>97年的铁憨憨 -</title>
  
  <subtitle>愿你我既可以朝九晚五 又能够浪迹天涯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qzloo.cn/"/>
  <updated>2020-01-03T05:55:19.552Z</updated>
  <id>https://qzloo.cn/</id>
  
  <author>
    <name>仇阿龙!</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zabbix(12)：zabbix-web发送邮件告警</title>
    <link href="https://qzloo.cn/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/"/>
    <id>https://qzloo.cn/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/</id>
    <published>2010-01-23T09:35:50.000Z</published>
    <updated>2020-01-03T05:55:19.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>在之前的文章中，我们已经总结了自定义报警媒介的知识点</p><p>本篇文章采用腾讯<code>QQ</code>邮箱，想必大家都对<code>QQ</code>很了解了，所以我就直接用<code>QQ</code>邮箱来发送数据，我之前测试过<code>163</code>邮箱也是很好用的，当然你也可以用你公司自己的邮箱配置，操作方法都大同小异</p><p>登录<code>QQ</code>邮箱，查看账户设置，如下图所示</p></blockquote><a id="more"></a><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-2.jpg" alt="12-2"></p><blockquote><p>查看设置收发邮件的方式，如下连接地址</p><p><code>https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</code></p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-3.jpg" alt="12-3"></p><blockquote><p>查看腾讯<code>QQ</code>的<code>smtp</code>邮箱配置，由于阿里云防止接口垃圾邮件默认关闭了<code>25</code>端口，以下发邮件会用<code>465</code>，<code>465</code>端口一会儿再<code>zabbix</code>配置上会用到</p><p>打开<code>Foxmail</code>，新建一个腾讯<code>QQ</code>账号邮箱</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-4.jpg" alt="12-4"></p><blockquote><p>我们需要<code>SSL</code>加密端口发送，所以必须手动设置</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-5.jpg" alt="12-5"></p><blockquote><p>进行<code>POP3</code>设置，设置完成之后创建邮箱账号</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-6.jpg" alt="12-6"></p><blockquote><p>开启腾讯<code>QQ</code>的<code>SMTP</code>服务</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-7.jpg" alt="12-7"></p><blockquote><p>根据腾讯的提示，用你绑定手机发送短信到腾讯科技</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-8.jpg" alt="12-8"></p><blockquote><p>获取到<code>QQ</code>邮箱的授权码</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-9.jpg" alt="12-9"></p><blockquote><p>开启<code>SMTP</code>成功后点击保存更改</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-10.jpg" alt="12-10"></p><blockquote><p><code>zabbix</code>从<code>3.0</code>就开始支持<code>web</code>版发送邮件告警了，在<code>zabbix2.0</code>的时代，我们得配合脚本发送邮件，但是我们要配置<code>web</code>发送邮件的前提就是<code>curl</code>的版本必须在<code>7.2</code>以上，我们现在所用的操作环境是<code>7.29.0</code>版本的</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-1.jpg" alt="12-1"></p><blockquote><p>选择媒介类型中的<code>Email</code></p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-11.jpg" alt="12-11"></p><blockquote><p>配置发件人信息，输入信息完成后点击更新，如下图</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-12.jpg" alt="12-12"></p><blockquote><p>完成发件人<code>Email</code>配置</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-13.jpg" alt="12-13"></p><blockquote><p>点击用户中的<code>admin</code>，配置收件人</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-14.jpg" alt="12-14"></p><blockquote><p>修改用户中的报警媒介，并点击更新</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-15.jpg" alt="12-15"></p><blockquote><p>更新成功</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-16.jpg" alt="12-16"></p><blockquote><p>定制报警内容，关于<code>zabbix</code>的报警变量可以参考官方文档</p><p><code>https://www.zabbix.com/documentation/3.0/manual/appendix/macros/supported_by_location</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">告警主机:&#123;HOSTNAME1&#125;&lt;br/&gt;</span><br><span class="line">告警地址:&#123;IPADDRESS&#125;&lt;br/&gt;</span><br><span class="line">告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;&lt;br/&gt;</span><br><span class="line">告警等级:&#123;TRIGGER.SEVERITY&#125;&lt;br/&gt;</span><br><span class="line">告警信息:&#123;TRIGGER.NAME&#125;&lt;br/&gt;</span><br><span class="line">告警项目:&#123;TRIGGER.KEY1&#125;&lt;br/&gt;</span><br><span class="line">问题详情:&#123;ITEM.NAME&#125;: &#123;ITEM.VALUE&#125;&lt;br/&gt;</span><br><span class="line">当前状态:&#123;TRIGGER.STATUS&#125;: &#123;ITEM.VALUE1&#125;&lt;br/&gt;</span><br><span class="line">事件ID:&#123;EVENT.ID&#125;</span><br><span class="line"></span><br><span class="line">Item values:&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">1. &#123;ITEM.NAME1&#125; (&#123;HOST.NAME1&#125;:&#123;ITEM.KEY1&#125;): &#123;ITEM.VALUE1&#125;&lt;br/&gt;</span><br><span class="line">2. &#123;ITEM.NAME2&#125; (&#123;HOST.NAME2&#125;:&#123;ITEM.KEY2&#125;): &#123;ITEM.VALUE2&#125;&lt;br/&gt;</span><br><span class="line">3. &#123;ITEM.NAME3&#125; (&#123;HOST.NAME3&#125;:&#123;ITEM.KEY3&#125;): &#123;ITEM.VALUE3&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>将以上内容复制到消息内容中，恢复信息同上</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-17.jpg" alt="12-17"></p><blockquote><p>打开用户群组中管理员用户的调试模式</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-18.jpg" alt="12-18"></p><blockquote><p>并点击用户群组名进入到它的权限页面，添加所有选择，并更新</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-19.jpg" alt="12-19"></p><blockquote><p>群组更新完成</p></blockquote><p><img src="/2010/01/23/zabbix-web%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/12-20.jpg" alt="12-20"></p><blockquote><p>这样<code>web</code>页面发送<code>Email</code>报警邮件就成功了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在之前的文章中，我们已经总结了自定义报警媒介的知识点&lt;/p&gt;
&lt;p&gt;本篇文章采用腾讯&lt;code&gt;QQ&lt;/code&gt;邮箱，想必大家都对&lt;code&gt;QQ&lt;/code&gt;很了解了，所以我就直接用&lt;code&gt;QQ&lt;/code&gt;邮箱来发送数据，我之前测试过&lt;code&gt;163&lt;/code&gt;邮箱也是很好用的，当然你也可以用你公司自己的邮箱配置，操作方法都大同小异&lt;/p&gt;
&lt;p&gt;登录&lt;code&gt;QQ&lt;/code&gt;邮箱，查看账户设置，如下图所示&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(11)：zabbix监控配置小结,触发警报</title>
    <link href="https://qzloo.cn/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/"/>
    <id>https://qzloo.cn/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/</id>
    <published>2010-01-21T01:29:05.000Z</published>
    <updated>2020-01-03T05:56:25.717Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>在之前的文章中，我们已经总结了主机、监控项、触发器、事件、动作等相关知识点，但是到目前为止，还没有真正的受到过任何一个<code>zabbix</code>中的警告，那么这次，我们就在之前的基础上，刻意的让某个监控项达到指定的阈值，看看能否正常的收到报警信息</p><p>在开始实验之前，先描述一下我们的测试环境</p><p>被监控主机的<code>IP</code>地址为<code>47.96.189.157</code>，被监控主机的名称为’<code>testzabbix1.qzl.net</code>‘，简易名称为’<code>testzabbix1</code>‘</p></blockquote><a id="more"></a><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-1.jpg" alt="11-1"></p><blockquote><p>在被监控主机上，我们定义了两个监控项，分别用于监控<code>cpu</code>的上下文切换次数和磁盘根分区的使用率</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-2.jpg" alt="11-2"></p><blockquote><p>我们已经为’<code>RootPartitionUsed</code>‘监控项创建了一个触发器，触发器如下</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-3.jpg" alt="11-3"></p><blockquote><p>并且已经定义了对应的动作，当上述触发器被触发时，如下动作会被执行</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-4.jpg" alt="11-4"></p><blockquote><p>好了，现在我们故意造成磁盘使用率超过指定阈值的情况，看看会不会受到警报，在操作之前，先看看我们的磁盘使用率的监控情况</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-5.jpg" alt="11-5"></p><blockquote><p>磁盘使用率为<code>16.91%</code>，阈值为<code>18%</code></p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-6.jpg" alt="11-6"></p><blockquote><p>好了，现在我们进入到被监控主机的根分区，在根分区中创建一个大文件，提高磁盘使用率</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-7.jpg" alt="11-7"></p><blockquote><p>在创建文件的过程中，观察对应的监控图形，发现图形中出现上升曲线，并且已经超过对应的阈值</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-8.jpg" alt="11-8"></p><blockquote><p>磁盘使用率超出阈值以后，触发器被触发，触发器的状态从’<code>OK</code>‘转为’<code>Problem</code>‘，点击’检测中’—-‘事件’，即可看到触发器对应的状态变化</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-9.jpg" alt="11-9"></p><blockquote><p>触发器状态已经从’正常’变为’问题’，最新的事件出现在事件列表的最上方</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-10.jpg" alt="11-9"></p><blockquote><p>此时，我们收到了报警邮件，还记得我们在’动作’中使用过的’宏’吗，<code>PROBLEM</code>为触发器的状态，<code>RootPartitionUsedTrigger</code>为触发器的名称，它们组成了邮件的标题</p><p>如果你不能正常的收到报警邮件，请检查你的’报警媒介’是否能够正常工作，如果使用了脚本类型的’报警媒介’，请确定脚本有正确的执行权限，如果使用了脚本调用了对应的邮件</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-11.jpg" alt="11-11"></p><blockquote><p>打开邮件，内容如下，已经监控到磁盘使用超过了我们设置的阈值，阈值为<code>18%</code></p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-12.jpg" alt="11-12"></p><blockquote><p>好了，现在我们删除对应的测试文件，让根分区的值还原到正常范围内</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-13.jpg" alt="11-13"></p><blockquote><p>根据对应的监控图形，磁盘使用率已经下降到阈值以下</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-14.jpg" alt="11-14"></p><blockquote><p>同时，查看对应事件，触发器的状态也从’问题’重新变回了’正常’，即从’<code>Problem</code>‘又变回了’<code>OK</code>‘</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-15.jpg" alt="11-15"></p><blockquote><p>此时再收到邮件，是触发器的状态恢复正常时发送的信息</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-16.jpg" alt="11-16"></p><blockquote><p>邮件内容如下</p></blockquote><p><img src="/2010/01/21/zabbix%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93-%E8%A7%A6%E5%8F%91%E8%AD%A6%E6%8A%A5/11-17.jpg" alt="11-17"></p><blockquote><p>好了，我们已经收到了<code>zabbix</code>的正常报警信息，我想，现在我们已经能够初步的使用<code>zabbix</code>了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在之前的文章中，我们已经总结了主机、监控项、触发器、事件、动作等相关知识点，但是到目前为止，还没有真正的受到过任何一个&lt;code&gt;zabbix&lt;/code&gt;中的警告，那么这次，我们就在之前的基础上，刻意的让某个监控项达到指定的阈值，看看能否正常的收到报警信息&lt;/p&gt;
&lt;p&gt;在开始实验之前，先描述一下我们的测试环境&lt;/p&gt;
&lt;p&gt;被监控主机的&lt;code&gt;IP&lt;/code&gt;地址为&lt;code&gt;47.96.189.157&lt;/code&gt;，被监控主机的名称为’&lt;code&gt;testzabbix1.qzl.net&lt;/code&gt;‘，简易名称为’&lt;code&gt;testzabbix1&lt;/code&gt;‘&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(10)：zabbix动作详解</title>
    <link href="https://qzloo.cn/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
    <id>https://qzloo.cn/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/</id>
    <published>2010-01-19T12:21:00.000Z</published>
    <updated>2020-01-03T05:56:05.984Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>这篇文章将会介绍<code>zabbix</code>中的’动作’，也就是所谓的’<code>Actions</code>‘</p><p>在前文中，我们一直拿’养鸡场’的场景作为学习<code>zabbix</code>的示例，这次还是老套路，仍然拿’养鸡场’作为话题的切入点</p><p>为了防止养鸡场的温度低于<code>30</code>度，我们在养鸡场中放置了一台监控设备，这台监控设备能够每隔<code>1</code>分钟检测一次养鸡场温度，如果最近一次检测到养鸡场的温度低于<code>30</code>度，则会亮起红灯，当养鸡场管理员看到红灯亮起，就会先打开暖气后一段时间以内，养鸡场温度仍然无法恢复到<code>30</code>度以上，那么工作人员则需要采取进一步措施了，比如说报告老板</p><p>在前文中我们已经解释过，’养鸡场温度’可以理解为<code>zabbix</code>的监控项，<code>30</code>度可以理解为养鸡场温度的阈值，’养鸡场温度 &lt; <code>30</code>‘可以理解为<code>zabbix</code>中的触发器，并且，我们已经在前文中定义了对应的监控项、触发器等，但是，我们并没有刻意的触发对应的触发器，因为我们还没有定义对应的’动作(<code>Actions</code>)’，也就是说，即使触发器被触发、产生了相应的事件，我们也无法收到’报警信息’，而’动作’是什么呢？刚才描述的’养鸡场’场景中的’打开暖气’、’报告老板’等一系列措施，都可以理解为<code>zabbix</code>中的动作，说的再通俗一点，’动作’就是在监控项出现异常时，<code>zabbix</code>应该采取哪些措施，是向管理员发送邮件呢，还是执行对应的脚本呢？这些就是所谓的’动作’</p><p>在<code>zabbix</code>中，动作是可以’步进’的，什么意思呢？仍然以养鸡场为例，当温度低于<code>30</code>度，养鸡场工作人员会先打开暖气，等待<code>2</code>分钟，如果<code>2</code>分钟以后，养鸡场温度仍然低于<code>30</code>度，工作人员则需要将情况报告给老板，那么，养鸡场工作人员采取的动作一共有两步，第一步：打开暖气。第二步：报告老板。这就是所谓的’步进’，一个动作可以由多个步骤组成，如果前面的步骤无法解决问题，则按照顺序执行后面的步骤，当然，一个动作也可以只有一步</p><p>那么现在，我们一起来看看怎样在<code>zabbix</code>中创建一个动作，此处仍然使用我们之前的测试环境，前文中我们已经创建了用于监控磁盘使用率的监控项’<code>RootPartitionUsed</code>‘，以及对应的触发器’<code>RootPartitionUsedTrigger</code>‘，现在，我们需要创建一个动作，与监控项和触发器结合起来一起使用，打开<code>zabbix</code>控制台，点击’配置’—-‘动作’，点击下图中的’创建动作’按钮，即可创建动作，我们也可以选择对应动作的事件源，由于我们并没有详细解释过’事件’，所以此处保持默认即可，点击创建动作</p></blockquote><a id="more"></a><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-1.jpg" alt="10-1"></p><blockquote><p>可以看到，动作由三个部分组成：’动作’、’条件’、’操作’，我们一个一个聊</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-2.jpg" alt="10-2"></p><blockquote><p>在名称中填写动作的名字，由于当前动作是为了监控项’<code>RootPartitionUsed</code>‘而准备的，所以，我们命名当前动作为’<code>RootPartitionUsedActions</code>‘</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-3.jpg" alt="10-3"></p><blockquote><p>上图中的’默认接收人’想要表达的意思并不正确，我们一起看一下’英文原版界面’，如下图</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-4.jpg" alt="10-4"></p><blockquote><p>可以看到，英文界面中，此处想要表达的意思为’默认主题’，由于翻译的问题，此处显示为’默认接收人’，容易引起误解</p><p>‘默认主题’中的内容看着有没有很熟悉，没错，<code>{TRIGGER.STATUS}</code>和<code>{TRIGGER.NAME}</code>都是<code>zabbix</code>中的’宏’，我们在设置脚本类型的’报警媒介’时已经使用过它们，此处我们再次解释一遍，我们可以把<code>zabbix</code>的’宏’理解成<code>zabbix</code>中的变量，不同的宏代表的含义也不一样，不过通过宏的名字，一般都能猜出宏的含义，比如<code>{TRIGGER.STATUS}</code>就表示对应触发器的状态，<code>{TRIGGER.NAME}</code>就表示对应触发器的名称，所以此处，’默认主题’的内容由对应的触发器状态和触发器名称组成。’宏’需要用大括号括起，并且’宏’的名字必须由大写字母组成，如果想要了解更多的’宏’都代表什么含义，可以参考官方<code>zabbix3.0</code>在线手册，地址如下<code>https://www.zabbix.com/documentation/3.0/manual/appendix/macros/supported_by_location</code></p><p>默认信息也是由一些’宏’拼凑而成的，每个’宏’的含义可以参看上述连接</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-5.jpg" alt="10-5"></p><blockquote><p>点击动作的’条件’选项卡，可以看到如下界面，我们可以通过这个配置界面，设定当前动作在什么情况下被执行</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-6.jpg" alt="10-6"></p><blockquote><p>比如，我们设置当前动作的目的就是在磁盘使用率超出阈值时，给管理员发送邮件，那么，我们就需要将当前工作与’磁盘使用率监控项对应的触发器’联系在一起，并且需要指明’磁盘使用率监控项对应的触发器’符合哪种条件时，当前动作会被执行，如下图，系统默认为我们设置了一些条件，这些条件可能不符合我们的实际需求，我们可以移除它们，如下图，点击’移除’</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-7.jpg" alt="10-7"></p><blockquote><p>我们可以根据实际情况，定义自己需要的触发条件</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-8.jpg" alt="10-8"></p><blockquote><p>那么现在，我们就来定义当前动作需要与哪个触发器进行关联，首先，选择触发器</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-9.jpg" alt="10-9"></p><blockquote><p>点击下图中的选择按钮</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-10.jpg" alt="10-10"></p><blockquote><p>由于创建当前动作的目的就是为了在磁盘使用率超出阈值时报警，所以，此处选择前文中创建的触发器’<code>RootPartitionUsedTrigger</code>‘，将它们关联在一起</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-11.jpg" alt="10-11"></p><blockquote><p>点击上图中的触发器后，界面如下图，点击下图中的’添加’，即可讲’<code>RootPartitionUsedTrigger</code>‘这个触发器与当前动作关联在一起</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-12.jpg" alt="10-12"></p><blockquote><p>虽然我们将’<code>RootPartitionUsedTrigger</code>‘这个触发器与当前动作关联在了一起，但是这还不够，我们还需要指明，当前触发器处于哪种状态时，执行当前动作，所以，我们需要继续添加条件</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-13.jpg" alt="10-13"></p><blockquote><p>点击下图中的’触发器值’</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-14.jpg" alt="10-14"></p><blockquote><p>选择’触发器值’后，选择对应的值，此处选择’问题’，选择问题后，点击’添加’，以添加新条件</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-15.jpg" alt="10-15"></p><blockquote><p>可以看到，经过配置后，条件如下，如下配置表示，当触发器’<code>RootPartitionUsedTrigger</code>‘的值为’问题’时，当前动作将会被执行，换句话说，当触发器’<code>RootPartitionUsedTrigger</code>‘的状态变为’<code>Problem</code>‘时，当前动作则会被执行，在下图中的计算方式中，显示为’<code>A and B</code>‘，表示<code>A</code>条件与<code>B</code>条件同时满足时，整体条件才被满足，动作才会被执行，我们也可以根据自己的实际情况，调整多个条件之间的逻辑关系</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-16.jpg" alt="10-16"></p><blockquote><p>配置如上后，点击’操作’选项卡，还记得我们之前说的’步进’吗，动作可以只有一步，也可以由多个步骤组成一个动作，此处就是配置动作的这些步骤的</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-17.jpg" alt="10-17"></p><blockquote><p>我们可以定义动作的’步进’时长，比如我们定义每一步的时长为<code>60</code>秒，那么如果动作包含了<code>3</code>个步骤，执行完整个动作则需要<code>180</code>秒，点击下图中的’新的’，为动作创建一个新的步骤</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-18.jpg" alt="10-18"></p><blockquote><p>步骤’<code>1 -1</code>‘表示当前步骤为第一步，第一步的持续时长为一步的默认时长</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-19.jpg" alt="10-19"></p><blockquote><p>如果有多个步骤，每个步骤此处的设置可以类似如下实例：</p><p>第一步：’<code>1 -1</code>‘，表示第一步持续时长为一步的时长</p><p>第二步：’<code>2 -2</code>‘，表示第二步持续时长为一步的时长</p><p>第三步：’<code>3 -4</code>‘，表示第三步持续时长为两步的时长，换句话说，第三大步需要由<code>3、4</code>两个小步组成</p><p>第四步：’<code>5 -7</code>‘，表示第四步持续时长为三步的时长，换句话说，第四大步需要由<code>5、6、7</code>三个小步组成</p><p>也可以不使用默认的步骤时长，我们也可以在’步骤持续时间’中定义当前这一步的持续时长</p><p>当前步骤是为了发送消息还是为了执行对应的命令呢？如果当前动作由多个步骤组成，我们可以在前面的步骤中执行命令，如果执行对应命令后还是无法使监控项回归正常，则在后面的步骤中发送消息，就好像养鸡场的工作人员一样，如果打开暖气无法解决问题，则需要报告老板，此处，我们选择’发送消息’进行演示</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-20.jpg" alt="10-20"></p><blockquote><p>我们需要设置将消息发送给谁，可以发送给选定的用户，也可以发送给用户组中的用户，此处点击下图中的’添加’</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-21.jpg" alt="10-21"></p><blockquote><p>加入我们要将信息发送给<code>Admin</code>用户，点击对应用户</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-22.jpg" alt="10-22"></p><blockquote><p>还记得前一篇文章中我们创建的’报警媒介’吗，此处选择通过哪些报警信道发送报警信息，此处，我们选择上次创建的’<code>MailScript</code>媒介’</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-23.jpg" alt="10-23"></p><blockquote><p>配置如下后，点击下图中的’添加’</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-24.jpg" alt="10-24"></p><blockquote><p>点击上图中的’添加’以后，则可以为当前动作添加一个步骤</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-25.jpg" alt="10-25"></p><blockquote><p>我们再来回顾一下当前这个动作的所有配置</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-26.jpg" alt="10-26"></p><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-27.jpg" alt="10-27"></p><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-28.jpg" alt="10-28"></p><blockquote><p>如果三个标签中的内容都已经正确设置，那么点击任意一个标签中的’添加’按钮即可创建当前动作。点击’添加’按钮后，动作已经被成功添加</p></blockquote><p><img src="/2010/01/19/zabbix%E5%8A%A8%E4%BD%9C%E8%AF%A6%E8%A7%A3/10-29.jpg" alt="10-29"></p><blockquote><p>好了，动作应该怎样创建，我们已经解释完了，在下一篇文章中，我们会将之前的知识点串联起来，看看监控项异常时，能不能像我们想象的那样收到报警信息</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章将会介绍&lt;code&gt;zabbix&lt;/code&gt;中的’动作’，也就是所谓的’&lt;code&gt;Actions&lt;/code&gt;‘&lt;/p&gt;
&lt;p&gt;在前文中，我们一直拿’养鸡场’的场景作为学习&lt;code&gt;zabbix&lt;/code&gt;的示例，这次还是老套路，仍然拿’养鸡场’作为话题的切入点&lt;/p&gt;
&lt;p&gt;为了防止养鸡场的温度低于&lt;code&gt;30&lt;/code&gt;度，我们在养鸡场中放置了一台监控设备，这台监控设备能够每隔&lt;code&gt;1&lt;/code&gt;分钟检测一次养鸡场温度，如果最近一次检测到养鸡场的温度低于&lt;code&gt;30&lt;/code&gt;度，则会亮起红灯，当养鸡场管理员看到红灯亮起，就会先打开暖气后一段时间以内，养鸡场温度仍然无法恢复到&lt;code&gt;30&lt;/code&gt;度以上，那么工作人员则需要采取进一步措施了，比如说报告老板&lt;/p&gt;
&lt;p&gt;在前文中我们已经解释过，’养鸡场温度’可以理解为&lt;code&gt;zabbix&lt;/code&gt;的监控项，&lt;code&gt;30&lt;/code&gt;度可以理解为养鸡场温度的阈值，’养鸡场温度 &amp;lt; &lt;code&gt;30&lt;/code&gt;‘可以理解为&lt;code&gt;zabbix&lt;/code&gt;中的触发器，并且，我们已经在前文中定义了对应的监控项、触发器等，但是，我们并没有刻意的触发对应的触发器，因为我们还没有定义对应的’动作(&lt;code&gt;Actions&lt;/code&gt;)’，也就是说，即使触发器被触发、产生了相应的事件，我们也无法收到’报警信息’，而’动作’是什么呢？刚才描述的’养鸡场’场景中的’打开暖气’、’报告老板’等一系列措施，都可以理解为&lt;code&gt;zabbix&lt;/code&gt;中的动作，说的再通俗一点，’动作’就是在监控项出现异常时，&lt;code&gt;zabbix&lt;/code&gt;应该采取哪些措施，是向管理员发送邮件呢，还是执行对应的脚本呢？这些就是所谓的’动作’&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;zabbix&lt;/code&gt;中，动作是可以’步进’的，什么意思呢？仍然以养鸡场为例，当温度低于&lt;code&gt;30&lt;/code&gt;度，养鸡场工作人员会先打开暖气，等待&lt;code&gt;2&lt;/code&gt;分钟，如果&lt;code&gt;2&lt;/code&gt;分钟以后，养鸡场温度仍然低于&lt;code&gt;30&lt;/code&gt;度，工作人员则需要将情况报告给老板，那么，养鸡场工作人员采取的动作一共有两步，第一步：打开暖气。第二步：报告老板。这就是所谓的’步进’，一个动作可以由多个步骤组成，如果前面的步骤无法解决问题，则按照顺序执行后面的步骤，当然，一个动作也可以只有一步&lt;/p&gt;
&lt;p&gt;那么现在，我们一起来看看怎样在&lt;code&gt;zabbix&lt;/code&gt;中创建一个动作，此处仍然使用我们之前的测试环境，前文中我们已经创建了用于监控磁盘使用率的监控项’&lt;code&gt;RootPartitionUsed&lt;/code&gt;‘，以及对应的触发器’&lt;code&gt;RootPartitionUsedTrigger&lt;/code&gt;‘，现在，我们需要创建一个动作，与监控项和触发器结合起来一起使用，打开&lt;code&gt;zabbix&lt;/code&gt;控制台，点击’配置’—-‘动作’，点击下图中的’创建动作’按钮，即可创建动作，我们也可以选择对应动作的事件源，由于我们并没有详细解释过’事件’，所以此处保持默认即可，点击创建动作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(9)：zabbix定义报警媒介</title>
    <link href="https://qzloo.cn/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/"/>
    <id>https://qzloo.cn/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/</id>
    <published>2010-01-17T06:02:24.000Z</published>
    <updated>2020-01-03T05:55:50.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>这篇文章将会介绍<code>zabbix</code>中的’报警媒介’，也就是所谓的’<code>Media types</code>‘</p><p>当<code>zabbix</code>中的某些被监控指标出现异常时，<code>zabbbix</code>会通过哪种方式通知运维工程师呢？是通过邮件呢，还是通过短信呢，或者是通过其他方式呢？今天我们就来聊聊<code>zabbix</code>的报警方式，无论是通过邮件报警还是通过短信报警，无非都是通过某种’媒介’将报警信息传递给收信人，所以在<code>zabbix</code>中，报警方式被称为’报警媒介’，那么，<code>zabbix</code>都支持哪些报警媒介呢，我们一起来看看</p><p><code>zabbix</code>支持的报警媒介如下：</p><p><code>Email</code>：邮件，这是最常用也是最传统的一种报警媒介，邮件报警，<code>zabbix</code>通过配置好的<code>SMTP</code>邮件服务器向用户发送对应的报警信息</p><p><code>Script</code>：脚本，当<code>zabbix</code>中的某些监控项出现异常时，也可以调用自定义的脚本进行报警，脚本的使用就比较灵活，具体怎样报警全看你的脚本怎么写</p><p><code>SMS</code>：短信，如果想要使用短信报警，则需要依赖短信网关(貌似需要北美的运营商)</p><p><code>Jabber</code>：即时通讯服务</p><p><code>Ez Texting</code>：商业的，收费的短信服务(北美运营商提供服务)</p><p>看到上面的描述，我们能用的貌似只剩下了<code>Email</code>和<code>Script</code>了。那么在<code>zabbix</code>中，怎样定义对应的报警媒介呢，很简单，打开我们的<code>zabbix</code>控制台，点击’管理’—-‘报警媒介类型’</p></blockquote><a id="more"></a><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-1.jpg" alt="9-1"></p><blockquote><p>可以看到，默认已经存在一些报警媒介，我们可以对已经存在的报警媒介进行修改，也可以创建符合自己需要的报警媒介，点击’创建媒体类型’按钮</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-2.jpg" alt="9-2"></p><blockquote><p>点击上述按钮后，会出现如下界面，当我们创建报警媒介时，默认类型为’电子邮件’</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-3.jpg" alt="9-3"></p><blockquote><p>展开’类型’下拉框，可以看到对应的几种报警媒介类型，这几种类型我们已经解释过，我们经常用到的无非就是电子邮件和脚本，此处我们选择’脚本’</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-4.jpg" alt="9-4"></p><blockquote><p>选择报警媒介类型为脚本后，配置界面如下，我们说过，通过脚本报警是非常灵活的，因为我们可以通过脚本发送邮件，发送短信，发送微信等，脚本内部具体通过哪种方式报警，取决于我们怎样编写脚本</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-5.jpg" alt="9-5"></p><blockquote><p>在配置脚本类型的’报警媒介’之前，我们需要先编写好对应的脚本，并且将脚本放置到对应的目录中，以便<code>zabbix</code>能够找到对应的脚本。那么此处，我们来动手编写一个能够发送邮件信息的脚本，这个脚本很简单，此处我们直接使用mail命令发送邮件，脚本内容如下</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-6.jpg" alt="9-6"></p><blockquote><p>从脚本内容可以看出，我们在脚本中接收了<code>3</code>个参数，第一个参数代表邮件发送给哪个邮件，第二个参数代表邮件主题，第三个参数代表邮件内容，既然定义了参数，那么<code>zabbix</code>在调用此脚本的时候，必然需要传入对应的参数，<code>zabbix</code>会怎样传入参数呢，我们一会儿再聊</p><p>当然，聪明如你一定想到了，上面的脚本只定义了发给谁，发什么，但是没有定义谁来发送邮件，那么现在，我们来配置默认的发件人，编辑<code>/etc/mail.rc</code>配置文件，加入如下内容</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-7.jpg" alt="9-7"></p><blockquote><p><code>set from=发件人邮箱</code></p><p><code>set smtp=smtp服务器</code></p><p><code>set smtp-auth-user=发件人邮箱账户</code></p><p><code>set smtp-auth-password=发件人邮箱账户授权码</code></p><p><code>set smtp-auth=login</code></p><p><code>set ssl-verify=ignore</code></p><p><code>set nss-config-dir=/root/.certs</code></p><p>配置完成后，保存退出即可，但是需要注意，某些邮件服务器可能无法使用上述配置进行登录，需要进行测试，此处的<code>smtp.163.com</code>已经经过测试，可以通过这种方法调用邮箱发送邮件</p><p>目前，我们已经配置了发送邮件的相关配置，并且编写了发送邮件的脚本，但是我们还需要另一步配置，因为<code>zabbix</code>在默认情况下，会去指定的目录中查找对应的报警脚本，所以，我们应该叫报警脚本放置到指定的目录中，<code>zabbix</code>默认的报警脚本目录应该存放在哪里呢，我们通过配置文件可以得到答案，打开<code>/etc/zabbix/zabbix_server.conf</code>配置文件</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-8.jpg" alt="9-8"></p><blockquote><p>通过<code>AlertScriptsPath</code>属性，可以配置报警脚本的指定位置，<code>zabbix</code>会去对应目录中查找报警脚本</p><p>此处，我们将<code>mail.sh</code>脚本放置在对应目录中，并且设置权限如下</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-9.jpg" alt="9-9"></p><blockquote><p>上述步骤配置完成后，回到刚才的’报警媒介’配置界面，因为我们的脚本是通过<code>mail</code>命令进行邮件告警的，所以，我们为这个报警媒介取名为’<code>MailScript</code>‘，如下图</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-10.jpg" alt="9-10"></p><blockquote><p>类型选择’脚本’，脚本名称为’<code>mail.sh</code>‘，<code>zabbix</code>会自动到<code>AlertScriptsPath</code>属性对应的目录中查找相同名称的脚本，还记得我们刚才写的脚本吗，我们向脚本中传入了<code>3</code>个参数，我们可以通过’脚本参数’设定需要传入的参数，当<code>zabbix</code>调用对应脚本时，会自动把’脚本参数’中对应的值按照顺序传入对应的脚本中</p><p>点击上图中的’添加’连接，可以添加对应的参数，如下图，我们添加了三个参数</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-11.jpg" alt="9-11"></p><blockquote><p>从上图可以看出，我们在这个报警媒介中设定了<code>3</code>个参数，这<code>3</code>个参数是什么意思呢，他们分别代表报警接收人，报警的主题，报警的信息</p><p>其实，这种由大括号括起，并且由大写字母组成的字符串在<code>zabbix</code>中被称作’宏’，我们可以理解为<code>zabbix</code>内置的变量，当不同的警告发生时，上述的<code>3</code>个’宏’的值会自动发生变化</p><p>那么，除了上述的<code>3</code>个’宏’，<code>zabbix</code>还有哪些’宏’呢？其他’宏’都代表了什么含义呢？我们可以查看<code>zabbix</code>的官方在线帮助手册，<code>zabbix3.0</code>的’宏’列表地址如下</p><p><code>https://www.zabbix.com/documentation/3.0/manual/appendix/macros/supported_by_location</code></p><p>在<code>zabbix3.0</code>之前，上图中的<code>3</code>个参数是默认传入对应脚本的，不用我们再手动进行定义，但是从<code>zabbix3.0</code>开始，如果想要向对应的脚本传入上述<code>3</code>个参数，则需要按照上图进行定义</p><p>好了，定义完成后，点击’添加’按钮，即可创建一个名称为’<code>MailScript</code>‘的报警媒介了</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-12.jpg" alt="9-12"></p><blockquote><p>到此处，我们已经成功的定义了一个’报警媒介’，从此，我们可以通过这个媒介，向用户发送报警信息了</p><p>但是，如果想要某个<code>zabbix</code>用户能够接收到从’<code>MailScript</code>报警媒介’发送过来的报警，还需要进一步配置，比如，当’<code>Admin</code>‘用户想要通过’<code>MailScript</code>‘报警媒介接收警报时，则必须能够’适配’这种媒介，如果’<code>Admin</code>‘用户没有使用’<code>MailScript</code>媒介’的能力，那么’<code>Admin</code>‘用户将无法接收到由’<code>MailScript</code>媒介’发出的报警信息。我们应该怎样让用户能够对应的报警媒介呢，配置步骤如下</p><p>打开<code>zabbix</code>控制台，点击’管理’—-‘用户’，选中要配置的用户，此处以管理员为例</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-13.jpg" alt="9-13"></p><blockquote><p>点击下图中，红框中的’报警媒介’</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-14.jpg" alt="9-14"></p><blockquote><p>点击下图中的’添加’连接</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-15.jpg" alt="9-15"></p><blockquote><p>在类型中，选择我们刚才创建的’报警媒介’，选择’<code>MailScript</code>‘，因为’<code>MailScript</code>‘最终还是使用邮件发送信息，所以此处，收件人填写’<code>Admin</code>‘用户所使用的报警信息接收邮箱，同时，还能够选择在哪些时段使用这种’报警媒介’接收信息，接收哪种级别的报警信息，是不是很人性化？配置如下图后，点击添加按钮</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-16.jpg" alt="9-16"></p><blockquote><p>确定无误后，点击’更新’按钮</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-17.jpg" alt="9-17"></p><blockquote><p>此刻，如果有对应的报警信息需要通过’<code>MailScript</code>媒介’发送给’<code>Admin</code>‘用户，’<code>Admin</code>‘用户就可以接收到对应的报警信息了。所以，在使用的过程中，如果定义了新的’报警媒介’，不要忘记为对应的用户添加’报警媒介’</p></blockquote><p><img src="/2010/01/17/zabbix%E5%AE%9A%E4%B9%89%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B/9-18.jpg" alt="9-18"></p><blockquote><p>好了，我们已经能够根据实际需要，定义一个’报警媒介’了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章将会介绍&lt;code&gt;zabbix&lt;/code&gt;中的’报警媒介’，也就是所谓的’&lt;code&gt;Media types&lt;/code&gt;‘&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;zabbix&lt;/code&gt;中的某些被监控指标出现异常时，&lt;code&gt;zabbbix&lt;/code&gt;会通过哪种方式通知运维工程师呢？是通过邮件呢，还是通过短信呢，或者是通过其他方式呢？今天我们就来聊聊&lt;code&gt;zabbix&lt;/code&gt;的报警方式，无论是通过邮件报警还是通过短信报警，无非都是通过某种’媒介’将报警信息传递给收信人，所以在&lt;code&gt;zabbix&lt;/code&gt;中，报警方式被称为’报警媒介’，那么，&lt;code&gt;zabbix&lt;/code&gt;都支持哪些报警媒介呢，我们一起来看看&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix&lt;/code&gt;支持的报警媒介如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Email&lt;/code&gt;：邮件，这是最常用也是最传统的一种报警媒介，邮件报警，&lt;code&gt;zabbix&lt;/code&gt;通过配置好的&lt;code&gt;SMTP&lt;/code&gt;邮件服务器向用户发送对应的报警信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Script&lt;/code&gt;：脚本，当&lt;code&gt;zabbix&lt;/code&gt;中的某些监控项出现异常时，也可以调用自定义的脚本进行报警，脚本的使用就比较灵活，具体怎样报警全看你的脚本怎么写&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SMS&lt;/code&gt;：短信，如果想要使用短信报警，则需要依赖短信网关(貌似需要北美的运营商)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Jabber&lt;/code&gt;：即时通讯服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ez Texting&lt;/code&gt;：商业的，收费的短信服务(北美运营商提供服务)&lt;/p&gt;
&lt;p&gt;看到上面的描述，我们能用的貌似只剩下了&lt;code&gt;Email&lt;/code&gt;和&lt;code&gt;Script&lt;/code&gt;了。那么在&lt;code&gt;zabbix&lt;/code&gt;中，怎样定义对应的报警媒介呢，很简单，打开我们的&lt;code&gt;zabbix&lt;/code&gt;控制台，点击’管理’—-‘报警媒介类型’&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(8)：zabbix触发器详解之二触发器语法</title>
    <link href="https://qzloo.cn/2010/01/15/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://qzloo.cn/2010/01/15/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2010-01-15T02:20:50.000Z</published>
    <updated>2020-01-03T05:55:42.027Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>这篇文章将会介绍<code>zabbix</code>触发器的语法结构</p><p>在上一篇文章中，我们已经用了’非<code>bu</code>常<code>zhuan</code>通<code>ye</code>俗’的方法给大家解释了什么是触发器，那么这次，我们从专业的角度，总结一下什么是触发器，但是这次的总结可能需要建立在之前文章的基础上，所以大家可以先回顾一下之前的文章</p><p>先来看看我们上一次创建的触发器</p></blockquote><a id="more"></a><p><img src="/2010/01/15/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95/8-1.jpg" alt="8-1"></p><blockquote><p>我们也说过，触发器的本质其实就是一个表达式。上次创建的触发器对应的表达式如下图，下图中的表达式的含义为，如果<code>testzabbix1.qzl.net</code>这台主机上的根分区使用率倒数第二次被监控到的值大于<code>18</code>，则触发器将会被触发</p></blockquote><p><img src="/2010/01/15/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95/8-2.jpg" alt="8-2"></p><blockquote><p>那么，我们把上图中的表达式放大一下，并且将其分解成<code>5</code>个部分，从而方便我们去理解</p></blockquote><p><img src="/2010/01/15/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95/8-3.jpg" alt="8-3"></p><blockquote><p>其实，上面的<code>5</code>个部分我们可以通过如下语法表示，如下语法描述了一个触发器的条件表达式的基本结构</p><p><code>{&lt;server&gt;：&lt;key&gt;.&lt;function&gt;(&lt;parameter&gt;)}&lt;operator&gt;&lt;constant&gt;</code></p><p>此处，我们只总结其专业术语，如果想要通俗的理解，请查阅前一篇文章</p></blockquote><ol><li>上图中的第一部分对应了上述语法中的<code>&lt;server&gt;</code>，表示主机名称，上图中对应的主机为<code>testzabbix1.qzl.net</code></li><li>上图中的第二部分对应了上述语法中的<code>&lt;key&gt;</code>，表示对应主机上某个监控项对应的<code>key</code>，上图中对应的<code>key</code>取得的值为对应主机的根分区的使用率</li><li>上图中的第三部分对应了上述语法中的<code>&lt;function&gt;(&lt;parameter&gt;)</code>，所以说，<code>last(#2)</code>应该被称作一个带有参数的函数，<code>last()</code>被我们称之为函数，<code>#2</code>被我们称之为函数的参数，<code>last(#2)</code>就表示监控项对应的<code>key</code>最近<code>2</code>次中倒数第<code>2</code>次取得的值，那么聪明如你一定想到了，除了<code>last()</code>函数，还有别的函数吗，必须有啊，不同的函数实现的功能则不同，触发器所支持的函数有很多，常用的有<code>avg</code>、<code>count</code>、<code>change</code>、<code>sum</code>、<code>max</code>、<code>min</code>、<code>date</code>等等，看这些函数的名字你也能猜出其大概的作用，无非就是获取监控项的值的最大值，最小值，值的总和，或者平均值等，如果你想要了解它们，可以登录<code>zabbix</code>的官网查看在线手册，地址如下<code>https://www.zabbix.com/documentation/3.0/manual/appendix/triggers/functions</code>而函数的参数格式变化则比较少，如果参数值前面带有’<code>#</code>‘作为前缀，则表示次数，比如<code>avg(#10)</code>，则表示最近<code>10</code>次监控项的值的平均值，如果参数值前面没有’<code>#</code>‘作为前缀，则表示时间，比如<code>sum(300)</code>，表示<code>300</code>秒内监控项的值的综合，<code>max(#20)</code>则表示最近<code>20</code>次监控项的值的最大值，<code>min(600)</code>则表示最近<code>10</code>分钟内监控项的值的最小值，但是需要注意，<code>last(0)</code>的含义与<code>last(#1)</code>的含义相同，都表示最近<code>1</code>次。有的函数还支持使用第<code>2</code>个参数，比如<code>avg(1h，1d)</code>，表示<code>一天</code>前的<code>一小时</code>内的监控项的值的平均值，假设现在的时间是<code>5点</code>，<code>avg(1h)</code>可以理解为<code>4点</code>到<code>5点</code>之间的监控项的值的平均值，而<code>avg(1h，1d)</code>中的<code>1d</code>表示时间偏移量，那么<code>avg(1h，1d)</code>可以理解为昨天<code>4点</code>到<code>5点</code>的监控项的值的平均值</li><li>上图中的第四部分对应了上述语法中的<code>&lt;operator&gt;</code>，其实就是常用的比较操作符或者运算操作符，由于<code>zabbix</code>版本的不同，操作符可能有所变化，<code>zabbix3.0</code>支持的操作符可以参考在线手册，地址如下，如下地址中除了包含表达式支持的操作符，还有一些触发器表达式的实例，都是我们学习的好素材：<code>https://www.zabbix.com/documentation/3.0/manual/config/triggers/expression</code></li><li>上图中的第五部分对应了上述语法中的<code>&lt;constant&gt;</code>，用于设定监控项对应的阈值</li></ol><blockquote><p>如果你看过上一篇文章，那么你一定知道，触发器的表达式时可以通过图形化界面中的配置，自动生成的，既然能够自动生成，我们还需要理解上述表达式的结构吗？虽然话是这样说，但是知其然，知其所以然，不是更好吗，嘿嘿嘿<del>~</del></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章将会介绍&lt;code&gt;zabbix&lt;/code&gt;触发器的语法结构&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我们已经用了’非&lt;code&gt;bu&lt;/code&gt;常&lt;code&gt;zhuan&lt;/code&gt;通&lt;code&gt;ye&lt;/code&gt;俗’的方法给大家解释了什么是触发器，那么这次，我们从专业的角度，总结一下什么是触发器，但是这次的总结可能需要建立在之前文章的基础上，所以大家可以先回顾一下之前的文章&lt;/p&gt;
&lt;p&gt;先来看看我们上一次创建的触发器&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(7)：zabbix触发器详解之一创建触发器</title>
    <link href="https://qzloo.cn/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://qzloo.cn/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2010-01-13T00:38:56.000Z</published>
    <updated>2020-01-03T05:55:53.213Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>这篇文章将会介绍怎样在<code>zabbix</code>中创建触发器，并解释触发器的各个配置</p><p>在上一篇文章中，我们已经大概描述了触发器、事件、动作的概念，并且通过’养鸡场’的场景比喻了它们，这次我们来看看怎样创建一个触发器，并且细细品味一番</p><p>我们继续使用之前的测试环境，如果你对我们的测试环境还不了解，可以参考之前的文章，首先，打开我们的<code>zabbix</code>控制台</p></blockquote><a id="more"></a><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-1.jpg" alt="7-1"></p><blockquote><p>因为<code>testzabbix1</code>主机上并不存在任何触发器，所以此处的触发器列表为空，如果对应主机上已经存在对应的触发器，我们可以通过过滤条件筛选出我们想要得到的触发器，此处，我们直接点击’创建触发器’按钮</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-2.jpg" alt="7-2"></p><blockquote><p>可以看到触发器的创建配置界面如下，我们为触发器起个名字，名字叫’<code>RootPartitionUsedTrigger</code>‘，从名字你也能看出来，这个触发器是为了监控根分区的使用率而创建的，还记得我们之前创建的监控项’<code>RootPartitionUsed</code>‘吗？我们现在要做的就是为这个监控项创建一个触发器，当这个监控项的值达到我们指定的阈值时，就会产生某个’事件’，以便我们采取后续的措施，我们在前文中拿’养鸡场’的场景举了例子，当养鸡场的温度低于<code>30</code>度时，红灯就会亮起，而此处，我们会把’养鸡场的温度’换成’磁盘使用率’，把’<code>30</code>度’换成了’<code>18%</code>‘，把红灯亮起想象成某个’事件’即可。而且我们在前文也已经说过，触发器的本质其实是一个表达式，用来定义监控项的阈值，那么我们怎样配置这个表达式呢，点击下图中的’添加’按钮，即可配置触发器的表达式</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-3.jpg" alt="7-3"></p><blockquote><p>点击上图中标注的’添加’按钮以后，可以看到如下界面，这个界面，就是我们用来配置’触发器’的表达式的界面</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-4.jpg" alt="7-4"></p><ol><li>监控项：前文中说过，我们往往通过触发器定义被监控项的阈值，那么这个触发器是定义哪个监控项的阈值呢，我们可以通过此处进行选择</li><li>功能：功能说起来比较麻烦，但是并不难理解，我们举个例子，还拿之前的’养鸡场’做例子，我发现这个例子特别好使，如果你没有看到我们所描述的’养鸡场’的场景，最好先看看之前的文章，会方便我们理解很多东西。我们设定，养鸡场的温度不能低于<code>30</code>度，如果低于<code>30</code>度，则报警，于是我们在养鸡场里面放置了一台设备，这台设备的作用就是每隔<code>1</code>分钟检测一下养鸡场的室温，如果低于<code>30</code>度，就亮起红灯并且警铃大作，比如，我们可以定义，如果最近一次的检测值低于<code>30</code>度，那么就报警，也可以定义，如果<code>5</code>分钟前的检测值低于<code>30</code>度，则报警，甚至，我们还可以这样定义，如果连续<code>10</code>分组内获取的温度值的平均值小于<code>30</code>度，则报警。那么，在<code>zabbix</code>中，怎样实现这样的灵活设定呢，没错，就是通过’功能’栏定义的，功能栏中将常用的各种定义已经为我们准备好了，比如，最近<code>T</code>次检测或者<code>T</code>分钟以内，养鸡场的温度出现了小于<code>N</code>度的情况，在功能栏中可以选择’最新的<code>T</code>值 &lt; <code>N</code>‘</li><li>我们在’功能’中，已经选择了某种定义，比如’最新的<code>T</code>值 &lt; <code>N</code>‘，那么<code>T</code>是以时间为单位呢，还是以次数为单位呢，如果我们想要定义’最近的第<code>T</code>次，养鸡场温度小于<code>30</code>度’，那么此处需要选择’计数’，如果我们想要表达’最近<code>T</code>分钟以内，养鸡场温度小于过<code>30</code>度’，那么此处需要选择’时间’，如果我们选择’计数’，直接在此处填写次数即可，比如，我们想要定义’最近检测值的第<code>5</code>次，养鸡场温度小于<code>30</code>‘，则在此处选择’计数’以后，填写<code>5</code>即可。如果此处我们选择时间，只需在’排班’中填写对应的时间即可</li><li>如果我们想要定义’<code>T</code>分钟以内，养鸡场温度出现过小于<code>30</code>度的情况’，则需要在’<code>3</code>‘中选择’时间’，同时在此处指明时间长度，默认单位是秒</li><li>此处用于设置<code>N</code>的值，比如’最近一次监测的养鸡场温度小于<code>30</code>度’，那么我们可以将<code>N</code>设置为<code>30</code></li></ol><blockquote><p>经过上述一番解释，我想大家应该已经能够初步的明白这些概念了，那么我们结合实际情况，一步一步的进行配置，配置如下</p><p>首先，选择我们要为哪个监控项配置触发器，即为哪个监控项设置阈值，点击’选择’按钮</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-5.jpg" alt="7-5"></p><blockquote><p>点击选择按钮以后，看到如下页面，通过’群组’与’主机’找到对应的主机，此处选择我们的测试主机<code>testzabbix1</code>，找到对应的监控项，因为我们是要为根分区磁盘使用率监控项设置触发器，所以，此处选择’<code>RootPartitionUsed</code>‘监控项</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-6.jpg" alt="7-6"></p><blockquote><p>假如我们想要将触发器定义为’最近第2次监控到根分区使用率大于18%，则触发’，那么我们则选择’last() - Last(most recent) T value’(最新的T值)即可</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-7.jpg" alt="7-7"></p><blockquote><p>最终配置如下，如下配置表示，当<code>testzabbix1</code>这台服务器的根分区使用率倒数第<code>2</code>次被监控到大于<code>18%</code>，则触发器的条件被满足，触发器将会被触发，配置如下后，点击’插入’按钮</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-8.jpg" alt="7-8"></p><blockquote><p>点击上图中的插入按钮后，回到触发器的最初的配置页面，可以看到，<code>zabbix</code>根据我们的设置，自动生成了一个’表达式’，这就是我们前面所说的，触发器的本质是一个表达式</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-9.jpg" alt="7-9"></p><blockquote><p>此刻，客观您再看看这个表达式，是不是就很容易理解了，我再来啰嗦一遍，希望你不要烦，上面的表达式表示，<code>testezabbix1.qzl.net</code>这台主机上的根分区使用率如果最近两次被监控到的值大于<code>18</code>，则触发器将会被触发。我们也可以同时配置多个表达式，点击’表达式构造器’即可定义多个表达式之间的逻辑关系，此处为了演示方便，不会对它们进行详细解释</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-10.jpg" alt="7-10"></p><blockquote><p>‘多重问题事件生成’表示触发器如果处于’<code>problem</code>‘状态，则重复的生成对应的’问题事件’，这样解释有点模糊，不容易理解，等到我们实际用的时候再细细解释，一般不勾选此项</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-11.jpg" alt="7-11"></p><blockquote><p>我们可以对触发器进行描述，还能为触发器添加一个<code>url</code>，当我们收到报警信息时，可以通过<code>url</code>快速的定位到触发器所对应的监控项，我们可以把对应监控项的’最新数据’对应的图形连接填入<code>url</code>处，但是，这样说起来不容易理解，没关系，在后面的示例中会进行演示，我们还可以为触发器定义’严重性’，其实就是这个触发器所对应的问题优先级，颜色越深，严重性越大</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-12.jpg" alt="7-12"></p><blockquote><p>此触发器示例的最终配置如下，因为现在并没有定义其他触发器，所以我们无法定义触发器的依赖关系，而且依赖关系的概念我们也没有提及过，所以，此处配置如下后，点击添加即可</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-13.jpg" alt="7-13"></p><blockquote><p>可以看到，触发器已经创建完成了</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-14.jpg" alt="7-14"></p><blockquote><p>此刻，我们再次查看触发器对应监控项的’图形’，应该已经发生了变化</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-15.jpg" alt="7-15"></p><blockquote><p>可以看到，在对应的图形中，已经显示除了对应的触发器，出发与的阈值为<code>18</code>，当大于<code>18</code>时，此触发器会被触发</p></blockquote><p><img src="/2010/01/13/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8/7-16.jpg" alt="7-16"></p><blockquote><p>好了，我们已经定义了一个触发器，但是我们还从未’触发’过它，不用着急，这是早晚的事儿</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章将会介绍怎样在&lt;code&gt;zabbix&lt;/code&gt;中创建触发器，并解释触发器的各个配置&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我们已经大概描述了触发器、事件、动作的概念，并且通过’养鸡场’的场景比喻了它们，这次我们来看看怎样创建一个触发器，并且细细品味一番&lt;/p&gt;
&lt;p&gt;我们继续使用之前的测试环境，如果你对我们的测试环境还不了解，可以参考之前的文章，首先，打开我们的&lt;code&gt;zabbix&lt;/code&gt;控制台&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(6)：zabbix触发器、事件、动作相关概念</title>
    <link href="https://qzloo.cn/2010/01/11/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8A%A8%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://qzloo.cn/2010/01/11/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8A%A8%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2010-01-11T12:11:56.000Z</published>
    <updated>2020-01-03T05:55:32.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>这篇文章将会初步的介绍<code>zabbix</code>中的触发器、事件、动作等相关概念</p><p>我有一个朋友，我很佩服他，他的行动能力特别强，想到了，计划好了，就去做，比如说养鸡，他在农村找了一片地，盖了一个养鸡场，然后就开始养鸡，并且把土鸡下的蛋加以包装，以绿色无污染的优势在市场上售卖，后来，他还去考了一个飞机驾照，我知道养鸡和飞机并没有什么关系，我只是单纯的感觉他的人生非常精彩而已，有的客官看到这里就怒了，我是来了解<code>zabbix</code>的，不是来看什么’养鸡’和’飞机’的，能不能别瞎<code>BB</code>，耽误大爷时间，这位大爷您息怒，听我慢慢道来</p><p>其实，我们可以从养鸡场的某个场景去理解<code>zabbix</code>的触发器、事件、动作等相关概念，在养鸡场，温度是非常重要的，温度要适中，要让鸡感觉很舒服，不同年龄段的鸡对温度的要求也不一样<del>咳咳</del>扯远了，我们不考虑这么多，假设，养鸡场的温度不能低于<code>30</code>度，如果低于<code>30</code>度，鸡们就会很不满意，就会吃不好睡不好，导致身体亚健康，鸡的身体不好，我们把它们做成鸡肉的时候口感就不好，口感不好客户就不会购买我们的鸡肉，我们作为鸡场老板来说，是不能允许这样的事情发生的，所以，我们必须时刻监控着养鸡场的温度，如果养鸡场的温度低于<code>30</code>度，必须马上亮起红灯警报，工作人员发现红灯亮起，就必须马上采取措施，比如，把暖气打开，或者马上报告老板</p></blockquote><a id="more"></a><p><img src="/2010/01/11/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8A%A8%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/6-1.jpg" alt="6-1"></p><blockquote><p>那么现在，我们把刚才说的养鸡场的场景与我们的<code>zabbix</code>联系起来，我们要监控养鸡场的温度，就好像我们要监控服务器的磁盘使用率一样，无论是养鸡场的温度，还是磁盘的使用率，都是我们要监控的指标，我们在前文已经描述过，一个被监控的指标被称作一个’监控项’(<code>item</code>)，那么，养鸡场的温度，在<code>zabbix</code>中就是一个<code>item</code>，而我们规定，养鸡场的温度低于<code>30</code>度时就要亮起红灯，也就是说，<code>30</code>度就是温度这个指标的阈值，那么，养鸡场的温度低于<code>30</code>度，在<code>zabbix</code>中怎样表达呢？在<code>zabbix</code>中，我们可以这样描述：养鸡场温度 &lt; <code>30</code></p><p>没错，就是这么简单，而’养鸡场温度 &lt; <code>30</code>‘不过是一个数学上的’比较表达式’而已，这个表达式，在<code>zabbix</code>中被称为’触发器’(<code>Triggers</code>)，换种角度解释，我们还可以从字面上理解’触发器’，触发器是会被触发的机器，但是只有满足触发条件时，触发器才会被触发，当触发器被触发以后，会产生某个’事件’(<code>Events</code>)，比如，当养鸡场温度低于<code>30</code>度时，红灯会亮起，那么’红灯亮起’就可以理解为’养鸡场温度 &lt; <code>30</code>‘这个’触发器’所产生的’事件’，当温度低于<code>30</code>时，触发器的条件被满足，就会产生’红灯事件’，当’红灯事件’产生以后，工作人员就会采取相应的措施，比如通知老板或者打开暖气，那么，’打开暖气’或者’报告老板’的一系列措施，在<code>zabbix</code>中被称为’动作’(<code>Actions</code>)。好了，我想我已经解释清楚了，为了解决这些概念，还要描述怎么养鸡，真实不容易~</p><p>那么，我们现在抛开’养鸡场’的概念，纯粹的总结一边<code>zabbix</code>中的触发器、事件、动作等相关概念</p><p><strong>触发器(<code>Triggers</code>)</strong>：我们可以把<code>zabbix</code>的触发器理解成一个条件表达式，我们往往通过触发器定义被监控项的阈值，当触发器对应的表达式被满足时，则代表被监控项达到了我们设定的阈值，也就意味着发生了我们不想要遇到的问题，换句话说，当监控项的值处于合理范围时，触发器不会被触发，当监控项的值超出合理范围(即达到阈值)，触发器则会被触发，当触发器被触发时，往往代表着出现了问题，触发器未被触发时，其的状态为’<code>OK</code>‘，当触发器被触发时，触发器的状态为’<code>Problem</code>‘，当被监控项的值达到阈值时，触发器的状态’<code>OK</code>‘变为’<code>Problem</code>‘，当监控项的值再次回归到合理范围时，触发器的状态会从’<code>Problem</code>‘转换回’<code>OK</code>‘</p><p><strong>事件(<code>Events</code>)</strong>：当触发器的状态发生改变时，则会产生对应的’事件’，当然，由触发器的状态改变而产生的事件被称为’触发器事件’，<code>zabbix</code>中，事件分为几种类型，除了’触发器事件’，还有一些别的事件，此处为了方便描述，暂且不提及它们，我们可以把’事件’大概理解成一个重要的事情</p><p><strong>动作(<code>Actions</code>)</strong>：当某个事件产生时，需要对应的处理措施，这种处理措施被称为动作</p><p>好了，这篇文章中，我们只是大概的描述了触发器、事件、动作的相关概念，但是并没有实际使用它们，我们会在以后的文章中，给出对应的应用示例，并且在实际使用时再更加详细的了解它们</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章将会初步的介绍&lt;code&gt;zabbix&lt;/code&gt;中的触发器、事件、动作等相关概念&lt;/p&gt;
&lt;p&gt;我有一个朋友，我很佩服他，他的行动能力特别强，想到了，计划好了，就去做，比如说养鸡，他在农村找了一片地，盖了一个养鸡场，然后就开始养鸡，并且把土鸡下的蛋加以包装，以绿色无污染的优势在市场上售卖，后来，他还去考了一个飞机驾照，我知道养鸡和飞机并没有什么关系，我只是单纯的感觉他的人生非常精彩而已，有的客官看到这里就怒了，我是来了解&lt;code&gt;zabbix&lt;/code&gt;的，不是来看什么’养鸡’和’飞机’的，能不能别瞎&lt;code&gt;BB&lt;/code&gt;，耽误大爷时间，这位大爷您息怒，听我慢慢道来&lt;/p&gt;
&lt;p&gt;其实，我们可以从养鸡场的某个场景去理解&lt;code&gt;zabbix&lt;/code&gt;的触发器、事件、动作等相关概念，在养鸡场，温度是非常重要的，温度要适中，要让鸡感觉很舒服，不同年龄段的鸡对温度的要求也不一样&lt;del&gt;咳咳&lt;/del&gt;扯远了，我们不考虑这么多，假设，养鸡场的温度不能低于&lt;code&gt;30&lt;/code&gt;度，如果低于&lt;code&gt;30&lt;/code&gt;度，鸡们就会很不满意，就会吃不好睡不好，导致身体亚健康，鸡的身体不好，我们把它们做成鸡肉的时候口感就不好，口感不好客户就不会购买我们的鸡肉，我们作为鸡场老板来说，是不能允许这样的事情发生的，所以，我们必须时刻监控着养鸡场的温度，如果养鸡场的温度低于&lt;code&gt;30&lt;/code&gt;度，必须马上亮起红灯警报，工作人员发现红灯亮起，就必须马上采取措施，比如，把暖气打开，或者马上报告老板&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(5)：zabbix添加带有参数的监控项</title>
    <link href="https://qzloo.cn/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/"/>
    <id>https://qzloo.cn/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/</id>
    <published>2010-01-09T10:22:56.000Z</published>
    <updated>2020-01-03T05:56:32.499Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>在前文中，我们已经解释了’监控项’(<code>item</code>)、’键’(<code>key</code>)、’应用集’(<code>application</code>)等概念，并且为<code>testzabbix1</code>主机添加了一个监控项，其作用是监控主机的<code>cpu</code>上下文切换速率</p><p>这次，我们再为<code>testzabbix1</code>主机添加一个监控项，用于监控磁盘分区的使用率，因为创建监控项的过程我们在前文已经详细的演示过，重复的地方我们就不再赘述，这次创建的监控项与上次创建的监控项只有些许不同而已，我会重点介绍它们的不同之处</p></blockquote><a id="more"></a><blockquote><p>点击<code>zabbix</code>控制台的’配置’—-‘主机’，点击<code>testzabbix1</code>主机的监控项</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-1.jpg" alt="5-1"></p><blockquote><p>点击’创建监控项’按钮</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-2.jpg" alt="5-2"></p><blockquote><p>假设我们想要监控<code>testzabbix1</code>主机上的’根分区’的磁盘使用率，所以，我们命名监控项名称为<code>RootPartitionUsed</code></p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-3.jpg" alt="5-3"></p><blockquote><p>我们说过，如果想要获取监控指标的数据，可以通过指定的<code>key</code>获取，如果<code>zabbix</code>自带的<code>key</code>不能满足我们，我们可以自定义<code>key</code>，而此处，我们的需求是监控根分区磁盘使用率，而<code>zabbix</code>自带的<code>key</code>中，正好有一个<code>key</code>能够获得某个磁盘分区的使用率，所以，我们点击上图中的’选择’按钮</p></blockquote><blockquote><p>点击选择按钮以后，从列表中找到如下图中的键，键名为’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘，从解释中可以了解到，通过这个键获取到信息与磁盘容量相关</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-4.jpg" alt="5-4"></p><blockquote><p>细心的你一定发现了，我们这次选择的’键’与上一次选择的’键’有哪些地方好像不太一样，没错，格式好像不太一样</p><p>我们来对比一下，上次，我们为了监控<code>cpu</code>的上下文切换次数，选择了如下键</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-5.jpg" alt="5-5"></p><blockquote><p>而这次，为了监控磁盘分区的使用率，我们选择了如下键</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-6.jpg" alt="5-6"></p><blockquote><p>这次我们选择的键，除了键名以外，还多出了传入参数的位置</p><p>对于’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘这个键来说，’<code>vfs.fs.size</code>‘就是键名，’<code>[fs,&lt;mode&gt;]</code>‘就是这个键需要的参数</p><p>而’<code>[fs,&lt;mode&gt;]</code>‘这两个参数中，<code>fs</code>是不可省参数，<code>mode</code>是可省参数</p><p>聪明如你一定已经发现了，如果参数被尖括号括起，则代表这个参数是可省参数，例如上述的&lt;<code>mode</code>&gt;，如果参数没有被尖括号括起，则代表是不可省参数，例如上述的<code>fs</code></p></blockquote><blockquote><p>那么这个键到底怎么使用呢，<code>fs</code>和<code>mode</code>这两个参数分别代表了什么呢，我们可以通过官网帮助手册，查看这些’键’的含义与使用方法</p><p><code>zabbix3.0</code>版本的所有’键’的含义及用法的官方在线手册地址如下</p><p><code>https://www.zabbix.com/documentation/3.0/manual/config/items/itemtypes/zabbix_agent</code></p><p>打开上述网址后，查询对应’键’的名称，从在线帮助手册中可以看到，这个键的描述，返回值，参数的含义与值，以及示例等信息</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-7.jpg" alt="5-7"></p><blockquote><p>从上图可以看出，用过这个键，获取的返回信息可以有两种类型，一种是整形，一种是浮点型，这取决于我们需要获取哪种信息，如果是获取磁盘的使用百分比，则会返回给我们浮点型，如果是获取使用量，则会返回整形，代表使用了多少<code>bytes</code>，上图中解释了两个参数的用法，<code>fs</code>代表对应的文件系统，我们可以理解为对应的文件系统所在的分区，<code>mode</code>的值可以为<code>total</code>，<code>free</code>，<code>used</code>，<code>pfree</code>，<code>pused</code>，分别表示获取对应文件系统的总大小(省略<code>mode</code>参数时，此为默认值)，空余空间大小，已经使用的空间的大小，空闲率和使用率，还记得这个键返回的两种数据类型吗，如果我们将<code>mode</code>设置为<code>total</code>，<code>free</code>，<code>used</code>，那么，这个键返回的数据类型将为整形(就是一个整数)，如果我们将<code>mode</code>设置为<code>pfree</code>或者<code>pused</code>，那么这个键返回的信息的数据类型就是浮点型(带有小数点的数字)。而且，帮助文档中还给出了这个’键’的使用示例，<code>vfs.fs.size[/tmp,frss]</code>，示例表示获取/<code>tmp</code>所对应的文件系统的剩余空间大小</p></blockquote><blockquote><p>好了，我们大概对<code>vfs.fs.size[fs,&lt;mode&gt;]</code>这个键有了一些了解，通过这个键，可以获取到文件系统对应分区的磁盘空间使用情况信息，我们可以通过<code>fs</code>参数指定对应的文件系统，通过<code>mode</code>参数，指定我们想要获取的信息的格式，还记得我们上次使用的<code>zabbix_get</code>命令吗，没错，我们现在<code>server</code>端，通过命令行测试一下，试试能否通过<code>zabbix_get</code>，调用对应的键，获取对应的磁盘信息，在<code>server</code>端执行如下命令</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-8.jpg" alt="5-8"></p><blockquote><p>上图中，我们使用了<code>zabbix_get</code>命令，调用了<code>vfs.fs.size</code>这个键，并且指定了对应的文件系统，我们指定<code>fs</code>参数的值为’<code>/</code>‘，而我们并没有设置<code>mode</code>参数的值，我们说过，<code>mode</code>参数是可省参数，当<code>mode</code>参数省略时，默认值为<code>total</code>，表示获取对应文件系统的总大小，由于是以字节为单位，所以返回的数值比较大，换算成<code>G</code>，应该为<code>39.2G</code>，那么我们到<code>agent</code>端验证一下，看看其’根分区’的大小是否与此值相同，如下命令在<code>agent</code>端执行</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-9.jpg" alt="5-9"></p><blockquote><p>可以看到，被监控主机的根分区大小为<code>40G</code>，与<code>39.2G</code>相差一点，这是因为换算的关系引起的，我们可以认为，我们获得到的信息是没有错的</p><p>那么，我们再次在<code>server</code>端执行如下几条命令，这次，我们设置了<code>mode</code>参数的值</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-10.jpg" alt="5-10"></p><blockquote><p>上图中的三条命令分别获取了根分区的使用量，空余量，以及磁盘使用率</p><p>好了，经过测试，通过’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘这个键，的确能够获得磁盘的使用情况统计信息，那么，我们回到我们的监控项配置页面</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-11.jpg" alt="5-11"></p><blockquote><p>当我们选择了对应的键以后，我们还需要做出适当的修改，将其参数值改成我们所需要的值，如下</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-12.jpg" alt="5-12"></p><blockquote><p>由于我们获取的数据为根分区的使用率，返回的信息为浮点型，所以，信息类型选择浮点型，由于返回的信息为磁盘使用率，所以单位设置为’<code>%</code>‘</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-13.jpg" alt="5-13"></p><blockquote><p>好了，其他的设置我们在前一篇文章中已经解释过了，此处不再赘述，但是为了演示方便，我并没有将数据更新间隔设置为<code>3600</code>，而是设置<code>10</code>秒收集一次磁盘数据，再次强调，这样设置只是为了快速获取演示效果，生产环境中对于类似这样的数据不要监控的如此频繁，配置如下后，点击添加按钮</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-14.jpg" alt="5-14"></p><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-15.jpg" alt="5-15"></p><blockquote><p>监控项添加完毕后，等待一分钟左右，查看对应的监控数据，如下，点击监控项对应的’图形’连接</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-16.jpg" alt="5-16"></p><blockquote><p>可以看到，监控到的磁盘使用率为<code>16.88%</code>，而且界面上显示的单位也是’<code>%</code>‘，还记得我们在监控项中配置的单位吗，就是这个作用，如果数据较多，我们可以拖动监控视图的’镜头’，调整’镜头’的远近以及位置，即可看到不同时间段的监控数据，但是因为我们磁盘使用率一直没有多大变化，所以，看不出镜头移动时的效果，如果是长时间的波动的数据，拖动镜头时的效果则比较明显</p></blockquote><p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-17.jpg" alt="5-17"></p><blockquote><p>这次，我们又添加了一个监控项，只是与上一次相比，我们这次添加的监控项可以传入参数</p><p>而且，我们已经了解到，如果想要搞明白<code>zabbix</code>的各种自带<code>key</code>的作用，可以参考<code>zabbix</code>官方在线手册</p><p><code>https://www.zabbix.com/documentation/3.0/manual/config/items/itemtypes/zabbix_agent</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在前文中，我们已经解释了’监控项’(&lt;code&gt;item&lt;/code&gt;)、’键’(&lt;code&gt;key&lt;/code&gt;)、’应用集’(&lt;code&gt;application&lt;/code&gt;)等概念，并且为&lt;code&gt;testzabbix1&lt;/code&gt;主机添加了一个监控项，其作用是监控主机的&lt;code&gt;cpu&lt;/code&gt;上下文切换速率&lt;/p&gt;
&lt;p&gt;这次，我们再为&lt;code&gt;testzabbix1&lt;/code&gt;主机添加一个监控项，用于监控磁盘分区的使用率，因为创建监控项的过程我们在前文已经详细的演示过，重复的地方我们就不再赘述，这次创建的监控项与上次创建的监控项只有些许不同而已，我会重点介绍它们的不同之处&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(4)：zabbix添加监控项</title>
    <link href="https://qzloo.cn/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/"/>
    <id>https://qzloo.cn/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/</id>
    <published>2010-01-07T03:50:44.000Z</published>
    <updated>2020-01-03T05:56:39.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>前文中，已经描述了怎样在<code>zabbix</code>中添加主机，但是，我们并没有对主机进行任何指标的实际监控，那么现在，我们来说说，具体怎样监控我们想要监控的指标</p></blockquote><a id="more"></a><blockquote><p>在具体操作之前，我们先聊聊理论，假设我们想要监控磁盘的使用率，在没有<code>zabbix</code>这种监控工具时，我们该怎样监控呢，再或者，我们不仅没有<code>zabbix</code>这种监控工具，我们也不会写脚本，更不会写任何程序，我们该如何监控磁盘的使用率呢。没错，人工监控，当我们无法依赖任何工具或者脚本等外部助力时，我们只能不停的看着屏幕，查看当前磁盘的使用率，如果磁盘使用率达到了我们设定的阈值，我们就会作出相应的处理动作。即使我们是通过人工完成监控的，我们也要想办法能够获取到被监控目标的数据，比如我们想要监控磁盘使用率，那么我们就要不停的获取磁盘的使用率信息，以便我们能够随时的了解磁盘的空间使用情况，那么我们怎样获取磁盘的使用率呢，就拿<code>Centos</code>为例，我们可能会通过如下命令，获取每个分区的磁盘使用率</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-1.jpg" alt="4-1"></p><blockquote><p>没错，我们通过命令，获取到了磁盘使用率的信息，当然，这个命令比较简短，方便我们从键盘键入，如果一条简单的命令，无法获取到磁盘使用率的信息呢，那么我们可能会通过一条稍微复杂的命令去实现监控，比如，如果我们只想要监控’根分区’磁盘使用率，我们可能会使用如下命令实现</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-2.jpg" alt="4-2"></p><blockquote><p>我们发现，获取监控信息的命令越来越长了，那么我们能不能尽量简化这些较长的命令呢，必须能啊，设置个别名不就行了，那么，我们把刚才的命令设置一个别名，直接执行命令别名试试</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-3.jpg" alt="4-3"></p><blockquote><p>可以看到，原本比较长的命令只缩减为了<code>rdu</code>三个字符。是不是比原来方便了许多呢，我们只需要三个字符，就能获取根分区的使用情况</p><p>这个时候，你可能会问，<code>linux</code>的命令别名与<code>zabbix</code>的监控项由关系吗，我们是来看怎么添加<code>zabbix</code>监控项的，不是来听你瞎BB的</p><p>好吧，其实它们并没有什么关系，但是它们有一些类似的地方，比如，我们刚才做的工作，无非就是获取监控信息，需要获取监控信息，就要执行对应的命令，我们也可以通过别名，调用对应的命令，从而获取到我们想要或得到的监控信息，在<code>zabbix</code>中，我们要监控的某一个指标，被称为’监控项’，就像我们的磁盘使用率，在<code>zabbix</code>中就可以被认为是一个’监控项’(<code>item</code>)，如果要获取到’监控项’的相关信息，我们则要执行一个命令，但是我们不能直接调用命令，而是通过一个’别名’去调用命令，这个’命令别名’在<code>zabbix</code>中被称为’键’(<code>key</code>)，所以，在<code>zabbix</code>中，如果我们想要获取到一个’监控项’的值，则需要有对应的’键’，通过’键’能够调用相应的命令，获取到对应的监控信息，我们暂且这样理解，方便我们入门</p></blockquote><blockquote><p>好了，此处我们又提到了两个新的术语，我们来总结一遍</p><p>监控项(<code>item</code>)：某个监控指标，在<code>zabbix</code>中被称之为一个<code>item</code>，某个主机中可能有多个需要被监控的指标，也就是说，某个<code>host</code>中可能有多个<code>item</code></p><p>键(<code>key</code>、<code>item key</code>)：如果想要获取监控项对应的数据，则必须通过某个<code>key</code>去获取，我们可以把<code>key</code>想象成调用对应命令的’命令别名’，<code>zabbix</code>中自带一些<code>key</code>，这些<code>key</code>往往比较通用，比如，通过这些<code>key</code>，我们可以监控<code>cpu</code>，内存，硬盘等常用指标，获取不同的指标信息，需要不同的<code>key</code>，但是如果这些自带的<code>key</code>无法满足我们的监控需求时，我们也可以自定义<code>key</code>，通过自定义<code>key</code>执行对应的操作，这些都是后话，我们慢慢来</p></blockquote><blockquote><p>好了，说了这么多，哥们你应该有点印象了，话接上回，我们已经在<code>zabbix</code>中添加了一台主机，现在，我们继续在这台主机上操作</p><p>首先，打开我们<code>zabbix</code>控制台，点击’配置’–’主机’，可以看到我们上次创建的主机，虽然我们为对应的被监控主机安装了<code>agent</code>，但是主机对应的<code>ZBX</code>仍然显示为灰色，代表我们还没有任何监控项被检测到，那么现在，我们来为<code>testzabbix1</code>主机添加一个监控项</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-4.jpg" alt="4-4"></p><blockquote><p>点击<code>testzabbix1</code>主机上的’监控项’，如下图所示位置</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-5.jpg" alt="4-5"></p><blockquote><p>进入监控项配置界面后，可以根据一些条件，筛选出已经存在的一些监控项，但是我们并没有任何监控项，所以此处，我们直接点击’创建监控项’按钮，以便新建监控项</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-6.jpg" alt="4-6"></p><blockquote><p>假如，现在我们想要监控<code>testzabbix1</code>这台主机的<code>CPU</code>的上下文切换此处，那么我们可以在此界面进行如下配置</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-7.jpg" alt="4-7"></p><blockquote><p>首先，在名称文本框中设置监控项的名称，我们此处监控的指标为<code>cpu</code>上下文切换此处，所以，命名此监控项为’<code>cpu context switches</code>‘</p><p>因为我们在<code>testzabbix1</code>这台主机上安装了<code>zabbix agent</code>，所以，此处类型保持默认，选择<code>zabbix</code>客户端</p><p>在键值一栏中，我们可以选择对应的<code>key</code>，也就是说，我们通过哪个<code>key</code>，获取到<code>cpu</code>的上下文切换次数的信息，所以，点击’选择’按钮，点击选择按钮以后，可以看到非常多的预先定义好的<code>key</code>，这些<code>key</code>都是<code>zabbix</code>自带的<code>key</code>，这些<code>key</code>一般都是系统级别的通过的监控项所能够用到的<code>key</code>，如果这些’键’不能满足我们的需求，我们则需要自定义<code>key</code>，这是后话，到时再聊，此处，我们选择<code>system.cpu.switches</code></p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-8.jpg" alt="4-8"></p><blockquote><p>选择完成后，可以看到，<code>key</code>的值已经自动填充到了’键值’的文本框中</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-9.jpg" alt="4-9"></p><blockquote><p>在继续操作之前，我们来插入一段概念</p><p>我们在介绍<code>zabbix</code>的概念时已经说过：管理员可以在<code>server</code>端使用一个名为<code>zabbix_get</code>的工具，测试是否能够从<code>agent</code>端拉取数据</p></blockquote><blockquote><p>其实，我们可以先通过命令行，看看对应的’键’返回的信息到底是什么样子的</p><p>我们在<code>server</code>端，使用如下命令，获取一下<code>system.cpu.switches</code>这个键对应的值</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-10.jpg" alt="4-10"></p><blockquote><p>上图中，我们在<code>server</code>端通过<code>zabbix_get</code>命令，使用<code>system.cpu.switches</code>这个’键’，获得了<code>47.96.189.157</code>这台主机上的<code>cpu</code>上下文切换次数</p><p>通过<code>-s</code>选项指定被监控主机的<code>IP</code>，通过<code>-k</code>选项指定对应的<code>KEY</code>，即可获得对应主机的对应监控指标的信息</p><p>那么，我们多运行两个这个命令</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-11.jpg" alt="4-11"></p><blockquote><p>可以看到，<code>cpu</code>的上下文切换次数是在不停的增长的，而且返回的值是一个整数</p></blockquote><blockquote><p>好了，回到我们的图形化配置界面，继续看我们的监控项配置</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-12.jpg" alt="4-12"></p><blockquote><p>我们就是通过<code>agent</code>接口监控数据的，<code>agent</code>监听在<code>10050</code>端口上，此处保持默认即可</p><p>而我们刚才也看到了，通过<code>zabbix_get</code>获取到的<code>system.cpu.switches</code>的数据，都是一些十进制的整数，所以，信息类型选择数字，数据类型选择十进制</p><p>数据更新间隔表示每隔多长时间获取一次监控项对应的数据，为了演示方便，能够尽快获取到数据，我们设定为每隔<code>30</code>秒获取一次监控信息，此处表示每隔<code>30</code>秒获取一次<code>47.96.189.157</code>主机的<code>cpu</code>上下文切换次数。但是需要注意，在生产环境中，如果不是特别重要的、敏感的、迅速变化的数据，不要获取的这么频繁，因为如果我们的监控项变得特别多时，获取信息的时间间隔过于频繁会带来巨大的监控压力，同时对数据库的写入也是一种考验</p><p>当然，我们也可以灵活的定义时间间隔，比如，周一到周五我们的业务量比较少，可以<code>10</code>分钟获取一次数据，而周六周日的业务量会剧增，为了实时监控，可以设置<code>5</code>分钟获取一次数据，这里只是举个例子，如果有类似的需求，可以通过’自定义时间间隔’配置段，添加不同时间段的不同监测频率</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-13.jpg" alt="4-13"></p><blockquote><p>因为我们每隔<code>30</code>秒就获取一次数据，那么这些数据都会编程历史数据，存入数据库中，通过上图中的历史数据文本框，可以设置历史数据的保存时长</p><p>上图中，我们设置历史数据保存<code>8</code>天，此监控项超过<code>100</code>天的数据将会被<code>zabbix</code>删除</p><p>从上图中，还可以看到有一个趋势数据保存天数，趋势数据时什么意思呢？趋势数据就是每个小时收集到的历史数据中的最大值、最小值，平均值以及每个小时收集到的历史数据的数量，所以，趋势数据每小时收集一次，数据量不会特别大，一般情况下，历史数据的保留时间都比趋势数据的保留时间短很多，因为历史数据比较多，如果我们监控的主机非常多，而且监控的频率特别频繁，那么数据库的压力则会变得非常大</p></blockquote><blockquote><p>继续向下看，可以看到存储值与查看值两个下拉框</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-14.jpg" alt="4-14"></p><blockquote><p>我们点开存储值下拉框，可以看到三个选项，不变、差量(每秒速率)、差量(简单变化)</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-15.jpg" alt="4-15"></p><blockquote><p>那么，这些值都是什么意思呢，我们慢慢说</p><p>不变：表示获取到的值是什么样子的，就在数据库中存储为什么样子</p><p>差量(简单变化)：表示本次收集到的信息值减去上一次收集到的信息值得出的差值</p><p>差量(每秒速率)：表示本次收集到的值 减去上次收集到的值以后，再除以两次收集信息的间隔时间</p><p>而此处，我们监控的指标为<code>cpu</code>上下文切换次数，这是一个不断增长的整数值，所以，我们选择’差量(每秒速率)’最为合适</p><p>这样我们就能够监控到不同时间段内<code>cpu</code>上下文切换的频率了</p></blockquote><blockquote><p>那么查看值是什么意思呢？查看值可以改变监控数据的展示方式，以便监控人员更容易理解，此处我们保持默认即可，在实际用到时我们再做解释</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-16.jpg" alt="4-16"></p><blockquote><p>新的应用集与应用集是什么意思呢？</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-17.jpg" alt="4-17"></p><blockquote><p>我们可以把’应用集’理解为同一类型的监控项的集合，’应用集’英文原词为<code>application</code>，<code>application</code>为一组<code>item</code>(监控项)的集合，比如，我们有<code>3</code>个监控项，它们分别监控’磁盘使用率’，’磁盘写入速率’，’磁盘读取速率’，虽然它们监控的指标不同，但是他们都是监控’磁盘’的监控项，所以，我们可以把它们归类为’磁盘’应用集，同理，如果有<code>2</code>个监控项，一个是监控<code>nginx</code>连接数量的，一个是监控<code>nginx</code>请求数量的，虽然它们监控的指标不同，但是它们都是监控<code>nginx</code>相关指标的，所以，我们可以把它们归为<code>nginx</code>应用集</p><p>但是，由于我们没有创建过任何应用集，所以上图中，应用集选择框中没有任何可选应用集，如果没有可选的合适的应用集，我们可以直接在’新的应用集’文本框中填入要创建的应用集名称，那么对应应用集会自动被创建，当前监控项也会自动归类为这个应用集</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-18.jpg" alt="4-18"></p><blockquote><p>继续聊，’填入主机资产记录栏位’我们后面再聊</p><p>描述信息栏填写关于这个监控项的相关描述</p><p>‘已启用’默认被勾选，表示此监控项被创建后，立即生效，即创建此监控项后立即开始监控</p></blockquote><blockquote><p>好了，监控项的配置我们已经解释的七七八八了，示例配置如下，点击添加按钮，注：为了更快的获取演示效果，此处将数据更新间隔设置为<code>5</code>秒，但是生产环境中请仔细考虑具体设置为多少秒比较适合生产环境的需求</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-19.jpg" alt="4-19"></p><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-20.jpg" alt="4-20"></p><blockquote><p>点击添加按钮以后，可以看到，<code>testzabbix1</code>主机的第一个监控项已经被添加，而且处于已启用状态</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-21.jpg" alt="4-21"></p><blockquote><p>点击监控项旁边的’应用集’</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-22.jpg" alt="4-22"></p><blockquote><p>可以看到，应用集中已经存在了<code>cpu</code>应用集，而且这个应用集中已经存在一个监控项，就是我们刚才创建的’<code>cpu context switches</code>‘监控项</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-23.jpg" alt="4-23"></p><blockquote><p>我们已经创建了一个监控项，那么怎样查看这个监控项的监控情况呢，点击’检测中’—-‘最新数据’，但是目前并没有展示出任何数据，因为我们还没有指定要查看哪些监控数据</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-24.jpg" alt="4-24"></p><blockquote><p>我们可以输入过滤条件，过滤出我们想要查看的数据，比如，我们选择根据主机过滤，过滤出对应主机的对应的监控项数据</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-25.jpg" alt="4-25"></p><blockquote><p>从对应的主机组中找到对应的主机</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-26.jpg" alt="4-26"></p><blockquote><p>选择主机以后点击过滤</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-27.jpg" alt="4-27"></p><blockquote><p>点击过滤按钮以后，应该可以看到我们刚才创建的监控项，已经存在了部分数据，如果你刚刚创建完监控项，不要着急的立马查看’监控项’数据，因为它可能需要一段时间收集数据</p><p>但是，如果超出正常收集数据的时间后，很长时间以内仍然无法收集到数据，那么有可能是因为<code>agent</code>端与<code>server</code>端时间不同步引起的，请确定你的<code>agent</code>端与<code>server</code>端的时间是同步的</p><p>可以看到，’<code>cpu context switches</code>‘这个监控项已经存在数据，我们点击对应的’图形’连接</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-28.jpg" alt="4-28"></p><blockquote><p>点击上图中的’图形’连接们可以看到如下界面，<code>zabbix</code>已经监控到了对应的<code>cpu</code>上下文切换频率，并且绘制出了对应的’图形’</p></blockquote><p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-29.jpg" alt="4-29"></p><blockquote><p>从上图中，可以看到，<code>zabbix</code>除了为我们绘制出了图形以外，还显示出了最大值、最小值、平均值等信息，上图中，正常显示为中文</p><p>如果你的界面不能正常显示中文，那么证明你没有上传中文字体，或者没有正确的配置显示字体选项，我们在安装<code>zabbix</code>的文章中已经描述了解决问题的过程，此处不再赘述</p><p>我们已经为主机添加了第一个监控项，并且已经成功监控到了对应的数据，好了，我们已经入门了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;前文中，已经描述了怎样在&lt;code&gt;zabbix&lt;/code&gt;中添加主机，但是，我们并没有对主机进行任何指标的实际监控，那么现在，我们来说说，具体怎样监控我们想要监控的指标&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(3)：zabbix添加主机</title>
    <link href="https://qzloo.cn/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/"/>
    <id>https://qzloo.cn/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/</id>
    <published>2010-01-05T11:29:44.000Z</published>
    <updated>2020-01-03T05:56:48.681Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p>在前文中，我们已经介绍过了<code>zabbix</code>是什么，以及怎样安装<code>zabbix</code>环境，那么现在，我们应该开始实际动手使用<code>zabbix</code>了，为了能让大家更加容易理解实际使用过程中将会用到的术语以及概念，我们先把实际工作场景描述清楚，然后再根据描述的工作场景进行演示</p></blockquote><a id="more"></a><blockquote><p>假设，我们想要使用<code>zabbix</code>监控一台<code>linux</code>服务器，那么，我们肯定要将这个服务器纳入<code>zabbix</code>的管理范围，而’添加主机’这个操作，就是将被监控的主机纳入<code>zabbix</code>管理范围的一个必须操作，如果我们有<code>10</code>台主机都需要被<code>zabbix</code>监控呢，没错，这<code>10</code>台主机都必须被添加到<code>zabbix</code>的监控列表中，在<code>zabbix</code>中，我们将被监控的对象称之为’主机’，’主机’不一定是服务器，也可以是路由器，交换机等网络设备，而且，根据主机的属性、角色、特征的不同，我们还能够将主机分组，比如，我们有<code>10</code>台服务器，<code>10</code>台服务器中，有<code>3</code>台<code>windows</code>服务器，有<code>7</code>台<code>linux</code>服务器，那么，我们可以按照操作系统的不同，将他们分为两组，<code>windows</code>服务器组与<code>linux</code>服务器组，或者我们不按照操作系统对主机进行分组，而是根据服务器的角色对主机分组，比如，一共<code>10</code>台服务器，<code>3</code>台是提供<code>ldap</code>服务的，<code>2</code>台是提供<code>web</code>服务的，<code>5</code>台是提供数据库服务的，我们也可以把它们按照角色分成<code>3</code>组，<code>ldap</code>主机组、<code>web</code>主机组、<code>db</code>主机组，当然，我们只是举个例子，实际应用中，具体怎样分组，是根据实际需求视情况而定的，那么，为什么要将主机分组呢，这是为了方便管理，因为同一类主机需要被监控的指标很有可能都是相同的，所以将它们分为一组方便管理，这是后话，我们到时候再聊</p></blockquote><blockquote><p>上面一段话中，我们提到了两个<code>zabbix</code>的常用术语，’主机’与’主机组’，我们再来总结一遍</p><ol><li><code>host</code>(主机)：需要被<code>zabbix</code>监控的对象，被称为主机，主机必须属于某个主机组</li><li><code>hostgroup</code>(主机组)：’主机组’也被称为’主机群组’，是由具有相同属性、特征、角色的多个主机组成的逻辑单元</li></ol></blockquote><blockquote><p>好了，理解上述两个术语，并且能够在<code>zabbix</code>中是同它们，就是我们这篇文章所要达到的目标</p><p>那么，我们来看看怎样在<code>zabbix</code>中添加一台主机，在动手添加主机之前，先说明一下我们的环境</p><p>我们已经将<code>zabbix-server</code>、<code>zabbix-database</code>、<code>zabbix-web</code>安装在了<code>116.62.188.230</code>上</p><p>同时，我们将<code>zabbix-agent</code>安装在了<code>47.96.189.157</code>上</p><p>所以此处，<code>47.96.189.157</code>就是被监控的对象，我们需要将<code>47.96.189.157</code>添加为<code>zabbix</code>主机</p></blockquote><blockquote><p>好了，跟我一起搞起来，首先，打开我们的<code>zabbix web</code>控制台，我们看看都有哪些’主机组’</p><p>点击’配置’—-‘主机群组’，可以看到，系统默认已经为我们准备了一些主机组，如果这些主机组不满足我们的需要，我们也可以创建新的主机组，点击下图中的’创建主机群组’按钮，即可创建主机组，但是，现在我们还不用深入研究主机组，此处只是让大家了解一下，对主机组有一个初步的认识即可</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-1.jpg" alt="3-1"></p><blockquote><p>同样，点击’配置’—-‘主机’，即可查看已经被加入<code>zabbix</code>主机列表的主机，可以看到，<code>zabbix</code>默认将<code>zabbix server</code>添加为了一台主机，以便可以自己监控自己，但是此处，我们需要添加一台我们自己的主机，就是<code>47.96.189.157</code>，点击’创建主机’，点击创建主机之前，可以选择左侧的’群组’下拉菜单，以确定将要创建的主机所在的主机组，当然，我们也可以先不选主机组，直接点击’创建主机’按钮</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-2.jpg" alt="3-2"></p><blockquote><p>点击’创建主机’按钮以后，即可看到类似如下界面，为了更好的描述每个步骤，具体解释参考下图后面的注释列表</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-3.jpg" alt="3-3"></p><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-4.jpg" alt="3-4"></p><ol><li>我们可以在主机名称的文本框中填写被监控主机的主机名称</li><li>‘可见名称’一般使用简短的、易读的、见名知义的名称表示主机即可</li><li>我们可以选择将要创建的主机属于哪个主机组，当然，如果没有合适的主机组，我们也可以直接在创建主机时，直接新建主机组，我们说过，每个主机必须存在于某个主机组中，所以，主机组是必须的</li><li>如果在’3’的位置没有对应的、可用的、合适的主机组，我们可以直接在’新的群组’中创建符合当前主机需要的主机组</li><li>选择通过哪种接口监控当前主机，可选的方式有<code>IPMI</code>接口、<code>JMX</code>接口、<code>SNMP</code>接口、<code>agent</code>接口，我们说过，’主机’在<code>zabbix</code>中，可以是服务器，路由器，交换机等等硬件设备，有的硬件设备只支持某种接口，所以，当我们添加主机时，会让我们选择通过哪种合适的接口监控它，具体各接口的使用场景我们已经在第一篇介绍<code>zabbix</code>概念的文章中描述过，此处不再赘述，当然，如果一台自助机能被多种接口所监控，也可以同时配置多个接口监控这台主机，但是当前，我们需要监控的主机是一台<code>linux</code>服务器，而且已经安装了对应的<code>agent</code>端，所以，此处，我们只使用<code>agent</code>接口对当前主机进行监控，而使用<code>agent</code>接口时，可以通过<code>IP</code>连接到对应<code>agent</code>，也可以使用主机名连接到对应<code>agent</code>，而此处，我们选择使用<code>IP</code>地址连接到对应的<code>agent</code>，<code>IP</code>地址就是我们将要添加的主机的<code>IP</code>，<code>47.96.189.157</code>，对应端口为默认的<code>10050</code>，如果你想要使用主机名连接到对应的<code>agent</code>，那么需要保证主机名能够被正常解析到<code>47.96.189.157</code>上，此处不再赘述，如果有多个<code>IP</code>可以连接到对应<code>agent</code>，可以点击’添加’，添加一条新的<code>IP</code></li><li>对将要添加的主机进行描述，添加相应的描述信息即可</li><li>表示是否使用<code>zabbix proxy</code>监控当前主机，虽然上图中，此处翻译为’由<code>agent</code>代理程序检测’，但是实际是用于指定<code>zabbix proxy</code>的，与<code>zabbix agent</code>并没有关系，但是因为我们没有配置<code>zabbix proxy</code>，所以此处保持默认即可</li></ol><blockquote><p>好了，按照上述界面中的配置进行设置以后，点击’添加’按钮，即可简单的添加一台主机，可以看到，<code>47.96.189.157</code>已经被添加到了主机列表中</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-5.jpg" alt="3-5"></p><blockquote><p>而且，如果此时我们再次查看主机组，已经发现，<code>Zabbix test</code>主机组已经被添加了，而且其中的成员已经包含了<code>testzabbix1</code>主机</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-6.jpg" alt="3-6"></p><blockquote><p>回到主机列表，可以看到我们刚才添加的<code>testzabbix1</code>主机，但是<code>testzabbix1</code>主机的’可用性’对应的<code>4</code>种接口都是灰色的</p></blockquote><p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-7.jpg" alt="3-7"></p><blockquote><p>上图中，<code>ZBX</code>就代表<code>agent</code>接口，虽然我们在添加主机时，配置了通过<code>agent</code>监控对应主机，但是，由于我们并没有配置监控主机的任何指标，所以，<code>ZBX</code>仍然是灰色的，也就是说，我们现在只是将<code>47.96.189.157</code>加入了<code>zabbix</code>的监控范围，但是并没有对它进行任何实际的监控，因为我们还没有配置任何’监控项’，至于怎样配置监控项，且听下回分解</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在前文中，我们已经介绍过了&lt;code&gt;zabbix&lt;/code&gt;是什么，以及怎样安装&lt;code&gt;zabbix&lt;/code&gt;环境，那么现在，我们应该开始实际动手使用&lt;code&gt;zabbix&lt;/code&gt;了，为了能让大家更加容易理解实际使用过程中将会用到的术语以及概念，我们先把实际工作场景描述清楚，然后再根据描述的工作场景进行演示&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(2)：Zabbix安装</title>
    <link href="https://qzloo.cn/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/"/>
    <id>https://qzloo.cn/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/</id>
    <published>2010-01-03T03:41:01.000Z</published>
    <updated>2020-01-03T05:55:26.116Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><blockquote><p>我们在上一篇介绍<code>zabbix</code>的基本概念的文章中已经描述过，<code>zabbix</code>的几个常用的重要组件，在安装<code>zabbix</code>时，其实就是在安装这些组件</p><p>由于我们的监控规模并不庞大，所以此处不会安装<code>zabbix proxy</code>，我们将会安装如下组件：</p><p><code>zabbix server</code></p><p><code>zabbix database</code></p><p><code>zabbix web</code></p><p><code>zabbix agent</code></p></blockquote><a id="more"></a><blockquote><p>此处我们将要安装的<code>zabbix server</code>版本为<code>zabbix3.0.7</code></p><p>如果你想要无痛的跟随本博客中的步骤进行练习，请安装3.0版本的<code>zabbix</code></p><p>因为<code>zabbix3.X</code>依赖的<code>php</code>版本不能低于<code>php5.4</code>，而<code>centos6.8</code>中，<code>php</code>默认版本为5.3</p><p>如果你想要使用<code>centos6.X</code>的操作系统，同时想要更加方便的升级<code>php</code>，可以使用<code>Remi</code>源升级<code>php</code></p><p>但是为了更加方便的使用yum源安装相关软件包，此处使用7.3安装<code>zabbix3.0.7</code></p></blockquote><blockquote><p>首先，为了方便安装，配置<code>zabbix</code>的官方<code>yum</code>源</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-1.jpg" alt="2-1"></p><blockquote><p>我们配置了<code>zabbix3.0</code>的<code>yum</code>源</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-2.jpg" alt="2-2"></p><blockquote><p>同时，我们配置了base源与epel源，因为安装过程中会用到这些yum源</p><p>准备工作完毕，剩下的就是安装各个组件了</p></blockquote><h5 id="安装zabbix-server"><a href="#安装zabbix-server" class="headerlink" title="安装zabbix server"></a>安装<code>zabbix server</code></h5><blockquote><p>我们先从<code>zabbix server</code>开始安装，由于我们使用<code>mysql</code>作为数据库，所以，在安装<code>zabbix3.X</code>的版本的<code>server</code>端时，需要安装<code>zabbix-server-mysql</code>包，在<code>3.X</code>的<code>zabbix</code>版本中，并没有单独的<code>zabbix server</code>端程序包，安装<code>zabbix-server-mysql</code>包即为安装了<code>server</code>端包，同时，我们可以在服务端安装<code>zabbix_get</code>包，以便向<code>agent</code>端发起测试采集数据请求，所以，我们在<code>server</code>端安装如下包</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-3.jpg" alt="2-3"></p><blockquote><p>安装完成上述两个包以后，<code>server</code>即为安装完成，是不是很简单，<code>server</code>端的相关配置我们一会儿再进行</p></blockquote><h5 id="初始化zabbix-database"><a href="#初始化zabbix-database" class="headerlink" title="初始化zabbix database"></a>初始化<code>zabbix database</code></h5><blockquote><p>此处我们将<code>mysql</code>与<code>zabbix</code>安装在同一台服务器上，安装<code>mysql</code>的过程此处不再赘述，当我们安装完<code>mysql</code>，需要初始化<code>zabbix</code>的数据库，而在我们安装<code>zabbix server</code>时，其中就包含初始化<code>zabbix</code>数据库的<code>sql</code>脚本</p><p>我们查看刚才安装完成的<code>zabbix-server-mysql</code>，可以看到一个<code>create.sql.gz</code>的包</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-4.jpg" alt="2-4"></p><blockquote><p>解压此包即可获得初始化<code>sql</code>脚本</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-5.jpg" alt="2-5"></p><blockquote><p>但是需要注意的是，此<code>sql</code>脚本中<code>sql</code>只会在对应的数据库中初始化<code>zabbix</code>所需要的数据库表，但是不会创建<code>zabbix</code>数据库，所以，创建<code>zabbix</code>数据库这一步骤，还是需要我们手动进行的，所以，此处我们先手动创建<code>zabbix</code>的数据库，过程如下</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-6.jpg" alt="2-6"></p><blockquote><p><code>zabbix</code>数据库初始化完成后，执行对应的<code>sql</code>初始化脚本</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-7.jpg" alt="2-7"></p><blockquote><p>查看<code>zabbix</code>数据库，发现对应的表已经生成</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-8.jpg" alt="2-8"></p><h5 id="配置zabbix-server端并启动"><a href="#配置zabbix-server端并启动" class="headerlink" title="配置zabbix server端并启动"></a>配置<code>zabbix server</code>端并启动</h5><blockquote><p><code>server</code>端已经安装完毕，并且数据库也已经初始化，现在我们开始配置<code>server</code>端，编辑<code>zabbix server</code>端的配置文件</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-9.jpg" alt="2-9"></p><blockquote><p>此处列出我们可能会经常修改的参数，如下</p><p><code>ListenPort=10051</code></p><p># 服务端监听的端口，保持默认即可</p><p><code>SourceIP=</code></p><p># 通过<code>SourceIP</code>参数可以指定服务端的源<code>IP</code>，当<code>server</code>端有多个<code>IP</code>地址时，我们可以指定服务端使用固定的<code>IP</code>与<code>agent</code>端进行通讯，为了安全起见，<code>agent</code>端会基于<code>IP</code>进行一定的访问控制，也就是说<code>agent</code>端只允许指定的<code>IP</code>以<code>server</code>端的身份采集被监控主机的数据，如果<code>IP</code>不对应，则不允许采集被监控主机的数据，所以，当<code>server</code>端有多个<code>IP</code>时，我们可以通过<code>SourceIP</code>参数，指定<code>server</code>端通过哪个<code>IP</code>采集被监控主机的数据</p><p><code>LogType=file</code></p><p># 通过<code>LogType</code>参数，可以指定通过那种方式记录日志，此参数可以设置为三种植，<code>system</code>、<code>file</code>、<code>console</code>，<code>system</code>表示将日志发往<code>syslog</code>，<code>file</code>表示使用指定的文件作为日志文件，<code>console</code>表示将日志发往控制台，默认为<code>file</code></p><p><code>LogFile=/var/log/zabbix/zabbix_server.log</code></p><p># 当<code>LogType</code>设置为<code>file</code>时，通过<code>LogFile</code>参数设置日志文件位置</p><p><code>LogFileSize=0</code></p><p># 指明日志文件达到多大时自动滚动，单位为<code>MB</code>，如果设置<code>LogFileSize</code>为<code>50</code>，表示日志大小达到<code>50MB</code>滚动一次，设置为<code>0</code>表示日志文件不会滚动，所有日志保存在一个文件中</p><p><code>DebugLevel=3</code></p><p># 通过<code>DebugLevel</code>参数可以定义日志的详细程度，即为日志级别</p><p><code>DBHost=localhost</code></p><p># 通过<code>DBHost</code>参数设置<code>zabbix</code>数据库所在的服务器<code>IP</code>，由于此处<code>zabbix</code>与<code>mysql</code>安装在同一服务器上，所以此处设置为<code>localhost</code></p><p><code>DBName=zabbix</code></p><p># 通过<code>DBName</code>指定<code>zabbix</code>数据库对应的名称</p><p><code>DBUser=zabbix</code></p><p># 通过<code>DBUser</code>指定<code>zabbix</code>数据库用户名</p><p><code>DBPassword=123456</code></p><p># 通过<code>DBPassword</code>指定<code>zabbix</code>数据库用户的密码</p><p><code>DBPort=3306</code></p><p># 通过<code>DBPort</code>指定<code>zabbix</code>所在数据库服务监听的端口号</p><p><code>DBSocket=/var/lib/mysql/mysql.sock</code></p><p># 如果数据库服务与<code>server</code>端在同一台服务器上，可以通过<code>DBSocket</code>指定数据库本地套接字文件位置，但是需要注意，即使设置了<code>mysql</code>套接字文件的位置，还是需要配合<code>DBHost</code>参数，否则在登录<code>zabbix</code>控制台时，可能会出现警告，在<code>zabbix server</code>的<code>log</code>中，也可能会出现无法连接到数据库的提示</p></blockquote><blockquote><p>根据上述的配置参数的解释，根据具体需求进行实际配置即可</p></blockquote><blockquote><p>配置完成后，启动<code>zabbix</code>服务端即可，启动后，<code>10051</code>端口已经被监听</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-10.jpg" alt="2-10"></p><blockquote><p>好了，<code>zabbix server</code>已经启动，剩下的就是初始化<code>zabbix</code>设置了，但是初始化<code>zabbix</code>的设置需要<code>zabbix web</code>提供的<code>GUI</code>图形化界面，所以，我们需要先安装<code>zabbix web</code></p></blockquote><h5 id="安装zabbix-web"><a href="#安装zabbix-web" class="headerlink" title="安装zabbix web"></a>安装<code>zabbix web</code></h5><blockquote><p><code>zabbix web</code>可以安装在单独的主机上，只要连接到<code>zabbix database</code>所在的数据库即可，但是此处为了方便，我们将<code>zabbix web</code>与<code>mysql</code>以及<code>zabbix server</code>安装在同一台服务器上</p><p>因为<code>zabbix web</code>需要<code>lamp</code>环境，所以，此处我们将会依赖到的环境先安装好</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-11.jpg" alt="2-11"></p><blockquote><p>完成上述步骤后，安装<code>zabbix web</code>所需要的两个包，对应版本为<code>3.0.7</code></p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-12.jpg" alt="2-12"></p><blockquote><p>查看刚才安装完成的<code>zabbix-web</code>程序包，可以看到，<code>zabbix-web</code>的<code>web</code>应用存放在<code>/usr/share/zabbix</code>中</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-13.jpg" alt="2-13"></p><blockquote><p><code>zabbix</code>还是比较贴心的，针对<code>httpd</code>，<code>zabbix-web</code>包中已经包含了对应<code>zabbix</code>文档路径的配置文件</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-14.jpg" alt="2-14"></p><blockquote><p>可以看到，针对<code>zabbix web</code>的文档路径，此文件中已经为我们准备好了默认配置，如果不使用<code>httpd</code>的虚拟主机，主要将时区稍加改动即可直接使用</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-15.jpg" alt="2-15"></p><blockquote><p>而此处，我们使用<code>httpd</code>的虚拟主机访问<code>zabbix web</code>，所以，将配置文件中的内容改为如下配置，同时将时区修改为亚洲上海</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-16.jpg" alt="2-16"></p><blockquote><p>配置完成后，启动hettpd服务</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-17.jpg" alt="2-17"></p><blockquote><p>好了，<code>zabbix web</code>安装配置完成</p></blockquote><h5 id="初始化zabbix-配置"><a href="#初始化zabbix-配置" class="headerlink" title="初始化zabbix 配置"></a>初始化<code>zabbix</code> 配置</h5><blockquote><p>完成上述安装步骤后，访问<code>zabbix_IP/zabbix</code>，可以看到如下图的<code>zabbix</code>安装页面，点击下一步按钮</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-18.jpg" alt="2-18"></p><blockquote><p>可以看到，<code>zabbix</code>自动检查了安装环境是否满足要求，如果出现不满足要求的情况，需要进一步处理，此处没有问题，点击下一步</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-19.jpg" alt="2-19"></p><blockquote><p>此处<code>zabbix</code>需要配置数据库连接，此处配置数据库的类型，<code>IP</code>，端口，数据库名，用户密码等信息，端口填写<code>0</code>表示使用默认端口(<code>3306</code>端口)</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-20.jpg" alt="2-20"></p><blockquote><p>此处，我们可以填写<code>zabbix server</code>的详细信息，包括<code>IP</code>地址，端口号，以及<code>server</code>名称等，填写完成后点击下一步</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-21.jpg" alt="2-21"></p><blockquote><p>在配置之前，请确定概要信息无误，点击下一步</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-22.jpg" alt="2-22"></p><blockquote><p>从提示可以看出，初始化配置已经完成，而且<code>zabbix</code>提示我们，这些配置信息都被保存到了<code>&#39;/etc/zabbix/web/zabbix.conf.php&#39;</code>配置文件中，如果想要更改刚才的一些配置，可以通过修改此文件完成，初始化已经完成，点击结束即可</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-23.jpg" alt="2-23"></p><blockquote><p>点击完成按钮后，可以看到<code>zabbix</code>的登录页面，默认的管理员用户为<code>admin</code>，密码为<code>zabbix</code>，输入用户名密码后登录</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-24.jpg" alt="2-24"></p><blockquote><p>登录完成后，可以看到<code>zabbix</code>的仪表盘</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-25.jpg" alt="2-25"></p><blockquote><p>哈哈哈，我知道你看英文不爽，别急，现在就调成中文，点击下图中红框标注的图标</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-26.jpg" alt="2-26"></p><blockquote><p>语言选择中文，点击更新即可，但是你可能无法在语言中看到中文选项，如果无法找到中文选项，则代表你的配置文件中的中文选项显示属性为<code>False</code></p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-27.jpg" alt="2-27"></p><blockquote><p>如果你安装的<code>zabbix3.0.X</code>无法看到中文选项，那么你可以需要少许额外的操作，首先，你需要修改如下文件</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-28.jpg" alt="2-28"></p><blockquote><p>找到中文对应的值，将显示属性设置为true即可</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-29.jpg" alt="2-29"></p><blockquote><p>但是，你可能还会遇见中文乱码的情况，如果遇到中文乱码，可以从<code>windows</code>中挑选一个顺眼的中文字体，将对应字体文件放置到<code>linux</code>中<code>zabbix web</code>的字体目录中，因为我们使用的是<code>rpm</code>包安装的<code>zabbix web</code>，所以<code>zabbix web</code>的默认字体目录为<code>/usr/share/zabbix/fonts</code>，<code>windows</code>中的字体文件后缀名如果为<code>TTF</code>，当我们把对应字体文件拷贝到<code>zabbix</code>字体目录时，需要修改其后缀名为小写的<code>ttf</code>(如果本来就是小写的则不用任何修改)，字体文件上传完毕后，修改<code>/usr/share/zabbix/include/defines.inc.php</code>配置文件，将下图中显示字体部分修改为刚才上传的字体文件对应的名称即可</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-30.jpg" alt="2-30"></p><blockquote><p>比如，我选择了’微软雅黑’字体，将<code>msyh.ttf</code>文件上传至<code>zabbix</code>的<code>fonts</code>目录后，配置文件修改如下</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-31.jpg" alt="2-31"></p><blockquote><p>好了，上述操作完成后，<code>zabbix</code>控制台即显示为中文了</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-32.jpg" alt="2-32"></p><blockquote><p>但是，你可能会在访问<code>zabbix</code>控制台时，可能会发现如下提示</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-33.jpg" alt="2-33"></p><blockquote><p>如果出现上图中的提示，可能是由如下几个原因引起的</p></blockquote><ol><li><code>zabbix-server</code>未正常启动</li><li>已经开始<code>selinux</code>，但是没有正常设置对应权限</li><li><code>zabbix-server</code>未能正常连接数据库</li><li><code>zabbix.conf.php</code>文件中<code>$ZBX_SERVER</code>参数对应的主机名不能正常解析</li><li>其他原因，需要查看<code>zabbix server</code>日志</li></ol><blockquote><p>如果在访问<code>zabbix</code>控制台时并没有出现上述提示，忽略上述描述即可</p></blockquote><blockquote><p>为了更加安全，我们不应该使用管理员的默认密码，所以，我们最好先修改管理员密码</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-34.jpg" alt="2-34"></p><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-35.jpg" alt="2-35"></p><blockquote><p>好了，我们以后的监控工作就要围绕这个<code>web</code>界面展开了，为了以后更好的展开工作，我们先大概的了解一下<code>zabbix</code>的菜单</p></blockquote><blockquote><p>管理菜单中，一般用于管理<code>zabbix</code>自身及<code>zabbix</code>相关设置</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-36.jpg" alt="2-36"></p><blockquote><p>配置菜单中，一般用于配置监控相关设置</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-37.jpg" alt="2-37"></p><blockquote><p>监测中菜单，一般用于查看被监控的相关数据</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-38.jpg" alt="2-38"></p><blockquote><p>报表菜单中，可以为管理员生成一段时间内的监控统计信息</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-39.jpg" alt="2-39"></p><blockquote><p>资产记录菜单中，管理员可以查看被管控的主机有那些，以及相关的资产信息</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-40.jpg" alt="2-40"></p><blockquote><p>好了，<code>zabbix web</code>的安装及简介暂时告一段落</p></blockquote><h5 id="安装zabbix-agent"><a href="#安装zabbix-agent" class="headerlink" title="安装zabbix agent"></a>安装<code>zabbix agent</code></h5><blockquote><p>万事俱备，就差<code>agent</code>端了，<code>agent</code>端安装也非常方便，直接被监控主机上安装如下两个包即可</p><p>此处被管理主机为<code>centos7.3</code>，已经配置好了对应的<code>zabbix</code>源，<code>agent</code>版本可以跟<code>server</code>端版本不一致，没有关系，安装即可</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-41.jpg" alt="2-41"></p><blockquote><p>我们查看一下<code>zabbix-agent</code>都安装了哪些文件，当然，最重要的就是<code>zabbix_agentd.conf</code>这个配置文件了</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-42.jpg" alt="2-42"></p><blockquote><p>还记得我们在刚开始介绍<code>zabbix</code>时，说过的’主动模式’与’被动模式’吗？这两种模式的相关配置，都需要在<code>zabbix_agentd.conf</code>中定义，打开这个文件，我们来配置一下最常用的<code>agent</code>端配置。首先，可以看到配置文件中有很多注释，打开配置文件，首先看到的就是’通用参数配置段’，我们可以在此配置段配置<code>zabbix_agent</code>进程的进程编号文件路径，存储日志方式，日志文件位置，日志滚动阈值等常用设定，细心如你一定已经发现，<code>zabbix_agent</code>配置文件的’通过配置段’中的参数大多数与<code>zabbix_server</code>配置文件中的仓用参数意义相同，所以，此处不再过多赘述，如果没有特殊需要，保持默认即可</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-43.jpg" alt="2-43"></p><blockquote><p>此处先说说我们马上会用到的两个配置段，如下图红框中的注释所描述的，’被动模式配置段’与’主动模式配置段’</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-44.jpg" alt="2-44"></p><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-45.jpg" alt="2-45"></p><blockquote><p>我们已经在最开始的概念介绍中，描述过，’主动模式’与’被动模式’都是对于<code>agent</code>端来说的，而且它们可以同时存在，并不冲突</p><p>我们来看看’被动模式’的相关配置参数</p><p>被动模式相关参数如下</p><p><code>Server</code>：用于指定允许哪台服务器拉取当前服务器的数据，当<code>agent</code>端工作于被动模式，则代表<code>server</code>端会主动拉取<code>agent</code>端数据，那么<code>server</code>端的<code>IP</code>必须与此参数的<code>IP</code>对应，此参数用于实现基于<code>IP</code>的访问控制，如果有多个<code>IP</code>，可以使用逗号隔开</p><p><code>ListenPort</code>：用于指定当<code>agent</code>端工作于被动模式时所监听的端口号，默认端口为<code>10050</code>，也就是说，<code>server</code>端默认访问<code>10050</code>端口，从而拉取数据</p><p><code>ListenIP</code>：用于指定<code>agent</code>端工作于被动模式时所监听的<code>IP</code>地址，默认值为<code>0.0.0.0</code>，表示监听本机的所有<code>IP</code>地址</p><p><code>StartAgents</code>：用于指定欲生成的<code>agent</code>进程数量</p></blockquote><blockquote><p>好了，被动模式的参数说完了，现在聊聊主动模式</p><p>主动模式的常用参数如下</p><p><code>ServerActive</code>：此参数用于指定当<code>agent</code>端工作于主动模式时，将信息主动推送到哪台<code>server</code>上，当有多个<code>IP</code>时，可以用逗号隔开</p><p><code>Hostname</code>：此参数用于指定当前主机的主机名，<code>server</code>端通过此参数对应的主机名识别当前主机</p><p><code>RefreshActiveChecks</code>：此参数用于指定<code>agent</code>端每多少秒主动将采集到的数据发往<code>server</code>端</p></blockquote><blockquote><p>此处，我们同时设置’被动模式’与’主动模式’的如下参数，其他保持默认即可，修改完成后保存退出</p><p><code>Server=116.62.188.230</code></p><p><code>ServerActive=116.62.188.230</code></p><p><code>Hostname=testzabbix1.qzl.net</code></p></blockquote><blockquote><p>配置文件修改完成之后，启动agent端进行</p></blockquote><p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-46.jpg" alt="2-46"></p><blockquote><p>好了，agent端也已经安装完毕了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Zabbix&quot;&gt;&lt;a href=&quot;#Zabbix&quot; class=&quot;headerlink&quot; title=&quot;Zabbix&quot;&gt;&lt;/a&gt;Zabbix&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;我们在上一篇介绍&lt;code&gt;zabbix&lt;/code&gt;的基本概念的文章中已经描述过，&lt;code&gt;zabbix&lt;/code&gt;的几个常用的重要组件，在安装&lt;code&gt;zabbix&lt;/code&gt;时，其实就是在安装这些组件&lt;/p&gt;
&lt;p&gt;由于我们的监控规模并不庞大，所以此处不会安装&lt;code&gt;zabbix proxy&lt;/code&gt;，我们将会安装如下组件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix database&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix web&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix agent&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>zabbix(1)：Zabbix概念</title>
    <link href="https://qzloo.cn/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/"/>
    <id>https://qzloo.cn/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/</id>
    <published>2010-01-01T01:10:57.000Z</published>
    <updated>2020-01-03T05:56:13.225Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><h5 id="Zabbix监控系统入门简介"><a href="#Zabbix监控系统入门简介" class="headerlink" title="Zabbix监控系统入门简介"></a>Zabbix监控系统入门简介</h5><blockquote><p><code>Zabbix</code>是一个基于<code>WEB</code>界面的提供分布式系统监控的企业级的开源解决方案，<code>Zabbix</code>能监视各种网络参数，保证服务器系统的安全稳定的运行，并提供灵活的通知机制以让SA快速定位并解决存在的各种问题。<code>Zabbix</code>分布式监控系统的优点如下：</p></blockquote><a id="more"></a><ul><li>支持自动发现服务器和网络设备</li><li>支持底层自动发现</li><li>分布式的监控体系和集中式的<code>WEB</code>管理</li><li>支持主动监控和被动监控模式</li><li>服务器端支持多种操作系统：<code>Linux, Solaris, HP-UX, AIX, FreeBSD, OpenBSD, MAC</code>等</li><li><code>Agent</code>客户端支持多种操作系统：<code>Linux, Solaris, HP-UX, AIX, FreeBSD, Windows</code>等</li><li>基于<code>SNMP</code>、<code>IPMI</code>接口方式也可以监控<code>Agent</code></li><li>安全的用户认证及权限配置</li><li>基于<code>WEB</code>的管理方法，支持自由的自定义事件和邮件发送</li><li>高水平的业务视图监控资源，支持日志审计，资产管理等功能</li><li>支持高水平<code>API</code>二次开发、脚本监控、自<code>Key</code>定义、自动化运维整合调用</li></ul><h5 id="Zabbix监控组件及流程"><a href="#Zabbix监控组件及流程" class="headerlink" title="Zabbix监控组件及流程"></a>Zabbix监控组件及流程</h5><blockquote><p><code>Zabbix</code>监控组件如下图所示，主要由三大组件，分别是 <code>Zabbix server</code>端、<code>Zabbix Proxy</code>、<code>Agent</code>客户端，其中<code>Zabbix Server</code>端包括：<code>WEB GUI</code>、<code>Database</code>、<code>Zabbix_Server</code>。</p></blockquote><p><img src="/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/1-1.jpg" alt="1-1"></p><blockquote><p><code>Zabbix</code>监控系统具体监控系统流程如下图所示：</p></blockquote><p><img src="/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/1-2.jpg" alt="1-2"></p><blockquote><p><code>Zabbix</code>监控完整流程包括：<code>Agent</code>安装在被监控的主机上，Agent负责定期收集客户端本地各项数据，并发送到<code>Zabbix Server</code>端，<code>Zabbix Server</code>收到数据，将数据存储到数据库中，用户基于<code>Zabbix WEB</code>可以看到数据在前端展现图像。</p><p>当<code>Zabbix</code>监控某个具体的项目，该项目会设置一个触发器阀值，当被监控的指标超过该触发器设定的阀值，会进行一些必要的动作，动作包括：邮件、微信报警或者执行命令等操作。如下为<code>Zabbix</code>完整监控系统，各个部分负责的工作：</p></blockquote><ul><li><code>Zabbix Server</code>：负责接收<code>Agent</code>发送的报告信息的核心组件，所有配置，统计数据及操作数据均由其组织进行</li><li><code>Database Storage</code>：专用于存储所有配置信息，以及存储由<code>Zabbix</code>收集到的数据</li><li><code>Web interface</code>：<code>Zabbix</code>的<code>GUI</code>接口，通常与<code>Server</code>运行在同一台主机上</li><li><code>Proxy</code>：常用于分布监控环境中，代理<code>Server</code>收集部分被监控端的监控数据并统一发往<code>Server</code>端</li><li><code>Zabbix Agent</code>：部署在被监控主机上，负责收集本地数据并发往<code>Server</code>端或<code>Proxy</code>端</li></ul><blockquote><p><code>Zabbix</code>监控部署在系统中，会包含常见的四个程序：<code>zabbix_server</code> 、<code>zabbix_get</code>、<code>zabbix_agentd</code>、<code>zabbix_proxy</code>、<code>zabbix_sender</code>等。四个程序启动后分别对应四个进程，如下为每个进程的功能：</p></blockquote><ul><li><code>Zabbix_server</code>：<code>Zabbix</code>服务端守护进程，其中<code>zabbix_agentd</code>、<code>zabbix_get</code>、<code>zabbix_sender</code>、<code>zabbix_proxy</code>的数据最终均是提交给<code>Zabbix_Server</code></li><li><code>Zabbix_Agentd</code>：客户端守护进程，负责收集客户端数据，例如收集<code>cpu</code>负载、内存、硬盘使用情况等</li><li><code>Zabbix_get</code>：<code>Zabbix</code>数据获取工具，单独使用的命令，通常在<code>server</code>或者<code>proxy</code>端执行获取远程客户端信息的命令</li><li><code>Zabbix_sender</code>：<code>zabbix</code>数据发送工具，用于发送数据给<code>server</code>或者<code>proxy</code>，通常用于耗时比较长的检查。很多检查非常耗时间，导致<code>zabbix</code>超时。于是我们在脚本执行完毕之后，使用<code>sender</code>主动提交数据</li><li><code>Zabbix_proxy</code>：<code>zabbix</code>分布式代理守护进程，分布式监控架构需要部署<code>Zabbix_Proxy</code></li></ul><h5 id="Zabbix监控方式及数据采集"><a href="#Zabbix监控方式及数据采集" class="headerlink" title="Zabbix监控方式及数据采集"></a>Zabbix监控方式及数据采集</h5><blockquote><p><code>Zabbix</code>分布式监控系统监控客户端的方式常见有三种，分别是<code>Agent</code>方式、<code>SNMP</code>、<code>IPMI</code>方式，三种方式特点如下：</p></blockquote><ul><li><code>Agent</code>：<code>Zabbix</code>可以基于自身<code>zabbix_agent</code>客户端插件监控<code>OS</code>的状态，例如<code>CPU</code>、内存、硬盘、网卡、文件等</li><li><code>SNMP</code>：<code>Zabbix</code>可以通过简单网络管理协议（<code>Simple Network Management Protocol</code>，<code>SNMP</code>)协议监控网络设备或者<code>windows</code>主机等，通过设定<code>SNMP</code>的参数将相关监控数据传送至服务器端，交换机、防火墙等网络设备一般都支持<code>SNMP</code>协议</li><li><code>IPMI</code>：智能平台管理接口（<code>Intelligent  Platform Management Interface</code>，<code>IPMI</code>）即主要应用于设备的物理特性，包括：温度、电压、电扇工作状态、电源供应以及机箱入侵等。<code>IPMI</code>最大的优势在于无论<code>OS</code>在开机还是关机的状态下，只要接通电源就可以实现对服务器的监控</li></ul><blockquote><p><code>Zabbix</code>监控客户端分为主动监控与被动监控，主被动模式以客户端为参照，<code>Zabbix</code>监控客户端默认为被动模式，可以修改为主动模式，只需要在客户端配置文件中添加。可以关闭被动模式的方法：在配置文件中加入 <code>StartAgents</code>=0，即为关闭被动模式。主被动监控模式区别如下：</p></blockquote><ul><li><code>Zabbix</code>主动模式：<code>Agent</code>主动请求<code>server</code>获取主动的监控项列表，并主动将监控项内需要检测的数据提交给<code>server/proxy</code>，<code>zabbix agent</code>首先向<code>ServerActive</code>配置的<code>IP</code>请求获取<code>active items</code>，获取并提交<code>active tiems</code>数据值<code>server</code>或者<code>proxy</code></li><li><code>Zabbix</code>被动模式：<code>Server</code>向<code>Agent</code>请求获取监控项的数据，<code>Agent</code>返回数据，<code>Server</code>打开一个<code>TCP</code>连接，<code>Server</code>发送请求<code>Agent.ping</code>，<code>Agent</code>接收到请求并且响应，<code>Server</code>处理接收到的数据</li></ul><h5 id="Zabbix监控概念"><a href="#Zabbix监控概念" class="headerlink" title="Zabbix监控概念"></a>Zabbix监控概念</h5><blockquote><p><code>Zabbix</code>监控系统包括很多监控概念，掌握<code>Zabbix</code>监控概念能对<code>Zabbix</code>监控快速的理解，如下为<code>Zabbix</code>常用术语及解释。</p></blockquote><table><thead><tr><th>Zabbix常用术语</th><th align="left">Zabbix术语解释</th></tr></thead><tbody><tr><td>主机(host)</td><td align="left">被监控的网络设备，可以写IP或者DNS</td></tr><tr><td>主机组(host group)</td><td align="left">主机组用于管理主机，可以批量设置权限</td></tr><tr><td>监控项(item)</td><td align="left">具体监控项，items值由独立的keys进行识别</td></tr><tr><td>触发器(trigger)</td><td align="left">为某个items设置触发器，达到触发器会执行action动作</td></tr><tr><td>事件(event)</td><td align="left">例如达到某个触发器，称之为一个事件</td></tr><tr><td>动作(action)</td><td align="left">对于特定事件事先定义的处理方法，默认可以发送信息及发送命令</td></tr><tr><td>报警升级(escalation)</td><td align="left">发送警报或执行远程命令的自定义方案，如隔5分钟发送一次警报，共发送5次等</td></tr><tr><td>媒介(media)</td><td align="left">发送通知的方式，可以支持Mail、SMS、Scripts等</td></tr><tr><td>通知(notification)</td><td align="left">通过设置的媒介向用户发送的有关某事件的信息</td></tr><tr><td>远程命令</td><td align="left">达到触发器，可以在被监控端执行命令</td></tr><tr><td>模板(template)</td><td align="left">可以快速监控被监控端，模块包含：item、trigger、graph、screen、application</td></tr><tr><td>web场景(web scennario)</td><td align="left">用于检测web站点可用性，监控HTTP关键词</td></tr><tr><td>web前端(frontend)</td><td align="left">Zabbix的web接口</td></tr><tr><td>图形(graph)</td><td align="left">监控图像</td></tr><tr><td>屏幕(screens)</td><td align="left">屏幕显示</td></tr><tr><td>幻灯(slide show)</td><td align="left">幻灯显示</td></tr><tr><td>—</td><td align="left"></td></tr></tbody></table><h5 id="Zabbix工作模式"><a href="#Zabbix工作模式" class="headerlink" title="Zabbix工作模式"></a>Zabbix工作模式</h5><blockquote><p>我们知道，<code>agent</code>端会将采集完的数据主动发送给<code>server</code>端，这种模式我们称之为主动模式，即对于<code>agent</code>端来说是主动的</p><p>其实，<code>agent</code>端也可以不主动发送数据，而是等待<code>server</code>过来拉取数据，这种模式我们称之为被动模式</p><p>聪明如你一定已经明白，不管是主动模式还是被动模式，都是对于<code>agent</code>端来说的，而且，主动模式与被动模式可以同时存在，并不冲突</p><p>管理员可以在<code>agent</code>端使用一个名为<code>zabbix_sender</code>的工具，测试是否能够向<code>server</code>端发送数据</p><p>管理员可以在<code>server</code>端使用一个名为<code>zabbix_get</code>的工具，测试是否能够从<code>agent</code>端拉取数据</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Zabbix&quot;&gt;&lt;a href=&quot;#Zabbix&quot; class=&quot;headerlink&quot; title=&quot;Zabbix&quot;&gt;&lt;/a&gt;Zabbix&lt;/h4&gt;&lt;h5 id=&quot;Zabbix监控系统入门简介&quot;&gt;&lt;a href=&quot;#Zabbix监控系统入门简介&quot; class=&quot;headerlink&quot; title=&quot;Zabbix监控系统入门简介&quot;&gt;&lt;/a&gt;Zabbix监控系统入门简介&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Zabbix&lt;/code&gt;是一个基于&lt;code&gt;WEB&lt;/code&gt;界面的提供分布式系统监控的企业级的开源解决方案，&lt;code&gt;Zabbix&lt;/code&gt;能监视各种网络参数，保证服务器系统的安全稳定的运行，并提供灵活的通知机制以让SA快速定位并解决存在的各种问题。&lt;code&gt;Zabbix&lt;/code&gt;分布式监控系统的优点如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://qzloo.cn/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Django-Templates-模板层</title>
    <link href="https://qzloo.cn/2005/01/07/Django-Templates-%E6%A8%A1%E6%9D%BF%E5%B1%82/"/>
    <id>https://qzloo.cn/2005/01/07/Django-Templates-%E6%A8%A1%E6%9D%BF%E5%B1%82/</id>
    <published>2005-01-07T11:53:32.000Z</published>
    <updated>2020-01-03T05:53:38.411Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模板层"><a href="#模板层" class="headerlink" title="模板层"></a>模板层</h4><blockquote><p>Django中的HTML文件并不是一个简单的前端页面，他支持多种渲染方式；</p><p>比如<code>Smart</code>或是<code>Jinja</code>这样出名的模板语言引擎，默认django使用的是templates引擎来进行模板页面的渲染，这也被称为Django模板语言（DTL）</p></blockquote><a id="more"></a><ul><li>模板语言主要有<strong>模板变量</strong>和<strong>模板标签</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;&#123; account &#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模板变量通过视图函数传递字典变量，字典的<code>key</code>值为对应模板变量名，对应<code>value</code>是模板变量实际被渲染的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">content = &#123;<span class="string">'account'</span>:<span class="string">'test'</span>&#125;</span><br><span class="line"><span class="keyword">return</span> render(request,html,content)</span><br></pre></td></tr></table></figure><ul><li>最终渲染结果</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> test <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>模板引擎遇到这个变量，将会计算他，并且将结果覆盖；</p><p>如果视图函数中，并没有给这个模板变量赋值，也没有关系，模板会自动将这个``处理为一个空</p></blockquote><blockquote><p><strong>注意</strong>：模板变量名，只能以字母数字下划线构成，下划线不可以打头，并且也不可以使用表单符号组成模板变量</p></blockquote><h5 id="变量获取方式"><a href="#变量获取方式" class="headerlink" title="变量获取方式"></a>变量获取方式</h5><blockquote><p>当我们返回的是一个字符串数据，这应该是最简单的处理方式，前端模板会直接将它展示到页面中。</p><p>如果返回的是一个列表序列数据或者字典键值对数据，我们可以使用模板语言中的<code>.</code>符号来进行其中值的获取，当模板变量中有符号<code>.</code>的存在时，比如<code>content.key</code>他会按照如下顺序来进行查找：</p></blockquote><ol><li><p>字典查找：<code>content[key]</code></p></li><li><p>对应属性和方法查找：<code>content.key</code></p><ul><li><blockquote><p>注意：因为对应key值的查找优先级要低于属性方法，所以要尽量避免使用数据内置方法作为key值</p></blockquote></li></ul></li><li><p>序列索引方式查找：<code>content[index]</code></p></li></ol><h5 id="Python数据在模板"><a href="#Python数据在模板" class="headerlink" title="Python数据在模板"></a>Python数据在模板</h5><blockquote><p>Python常用数据有int，float，str，list，tuple，dict，set等</p><p>把他们都通过模板变量传递到模板页面试试</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    int_ = <span class="number">123</span></span><br><span class="line">    float_ = <span class="number">0.123</span> </span><br><span class="line">    str_ = <span class="string">'str'</span></span><br><span class="line">    list_ = [<span class="string">'l'</span>,<span class="string">'i'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>]</span><br><span class="line">    tuple_ = (<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'p'</span>,<span class="string">'l'</span>,<span class="string">'e'</span>)</span><br><span class="line">    dict_ = &#123;<span class="string">"key"</span>:<span class="string">"value"</span>&#125;</span><br><span class="line">    set_ = &#123;<span class="string">'s'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>,locals())</span><br></pre></td></tr></table></figure><ul><li><code>locals()</code>：该函数将当前作用域下的所有变量名和对应变量值组成字典，免去了我们构造存储字典的麻烦</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; int_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; float_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; list_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tuple_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dict_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dict_.key &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; set_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>到了模板页面上，这些变量值其实也都像变成了字符串一样，直接展示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">0.123</span><br><span class="line"></span><br><span class="line">str</span><br><span class="line"></span><br><span class="line">['l', 'i', 's', 't']</span><br><span class="line"></span><br><span class="line">('t', 'u', 'p', 'l', 'e')</span><br><span class="line"></span><br><span class="line">&#123;'key': 'value'&#125;</span><br><span class="line"></span><br><span class="line">&#123;'e', 's', 't'&#125;</span><br></pre></td></tr></table></figure><h5 id="for-标签"><a href="#for-标签" class="headerlink" title="for 标签"></a>for 标签</h5><blockquote><p>使用模板中使用标签语言&#123;% for %&#125;和&#123;% endfor%&#125;，对视图函数传递的数据集进行遍历访问，比如上面传递的字符串，列表，元祖，字典，集合这样的数据</p><p>和普通模板变量不同，模板标签使用大括号百分号的组合&#123;% lag %&#125;，具有有一些特殊的功能性</p></blockquote><blockquote><p>模板中的标签&#123;% for %&#125;与Python中的for循环类似，要记得有闭合模板标签&#123;&#123; endfor &#125;&#125;</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in sequence %&#125;</span><br><span class="line">&#123;&#123; var &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><ul><li>来把上面的数据进行访问</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in str_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in tuple_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in set_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看到的效果和在Python中迭代访问的结果是差不多的，并且模板循环还会使对应的标签也进行循环</p></blockquote><blockquote><p>接下来来看字典，通过模板循环从字典中取出来的是字典的key值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in dict_ %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125; &#123;&#123; dict_.var&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在for循环遍历访问字典的时候，不能再像Python语法里一样，直接通过迭代获取<code>key</code>之后通过</p><p><code>dict[key]</code>或是<code>dict.key</code>，拿到对应value；</p><p>模板变量不会把<code>var</code>解释成取到的对应<code>key</code>值，var只是作为了一个单纯的<code>var</code>字符串，除非在字典中，有<code>var</code>字符串做为字典的键值，否则是取不到的</p></blockquote><ul><li>正确的对字典中键值对进行获取的方式是通过内置字典<code>items</code>属性：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for key,value in dict_.items %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; key &#125;&#125; &#123;&#123; value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：模板语言中，不会出现索引超出范围的<code>IndexError</code>或者Key值不存在的<code>KeyError</code>，取不出任何东西则只是一个空</p></blockquote><ul><li>在&#123;% for %&#125;循环中，我们还可以使用很多有用的模板变量，方便我们控制循环</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in iterable %&#125;</span><br><span class="line">&#123;&#123; forloop.counter &#125;&#125; <span class="comment">&lt;!--当前循环次数，从1开始计数 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.counter0 &#125;&#125; <span class="comment">&lt;!--当前循环次数，从0开始计数 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.revcounter &#125;&#125; <span class="comment">&lt;!--当前循环次数，从最大长度开始 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.revcounter0 &#125;&#125; <span class="comment">&lt;!--当前循环次数，从最大索引开始 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.first &#125;&#125; <span class="comment">&lt;!-- 判断是否为第一次循环 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.last &#125;&#125; <span class="comment">&lt;!-- 判断是否为第一次循环 --&gt;</span></span><br><span class="line">&#123;&#123; forloop.parentloop &#125;&#125; <span class="comment">&lt;!-- 当循环嵌套时，访问上层循环 --&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><ul><li>通过&#123;% empty %&#125;标签判断迭代对象是否为空</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in test_list %&#125;</span><br><span class="line">&#123;&#123; var &#125;&#125;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">空空如也</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h5 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h5><blockquote><p>可以通过&#123;% if %&#125;标签语法来进行模板变量的值判断；</p><p>语法如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if test_list %&#125;</span><br><span class="line">    列表不为空</span><br><span class="line">&#123;% elif test_dict %&#125;</span><br><span class="line">    列表为空，字典不为空</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">列表字典均为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ul><li>并且<code>if</code>标签还支持<code>and</code>、<code>or</code>及<code>not</code>来进行变量的布尔判断</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if test_list and test_dict %&#125;</span><br><span class="line">    列表、字典均不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not test_list %&#125;</span><br><span class="line">    列表为空时才能满足IF条件判断</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if test_list or test_dict %&#125;</span><br><span class="line">    列表、字典某一个不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not test_list or test_dict %&#125;</span><br><span class="line">    列表为空或字典不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if test_list and not test_dict %&#125;</span><br><span class="line">    列表不为空并且字典为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ul><li>也支持同时使用and及or语句，但是and的条件判断优先级要高于or语句</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if a or b and c %&#125;</span><br><span class="line">等同于</span><br><span class="line">&#123;% if a or (b and c) %&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if</code>标签还支持<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>的判断用法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if var == "1" %&#125;</span><br><span class="line">这个值是"1"</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if var != "x" %&#125;</span><br><span class="line">判断不相等成立</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if var <span class="tag">&lt; <span class="attr">100</span> %&#125;</span></span><br><span class="line"><span class="tag">    <span class="attr">var</span>大于<span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#123;% <span class="attr">endif</span> %&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if var &gt;= 100 %&#125;</span><br><span class="line">    var大于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果判断的数据类型在后台传递到模板变量时具体数值类型为整型或浮点型而不是字符串;</p><p><strong>不需要在判断的时候加字符串的标识引号</strong></p></blockquote><ul><li>在模板语言中，不支持连续判断</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if 100 &gt; var &gt; 50 %&#125;</span><br><span class="line">    var大于50小于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>应该使用and语句写成这样</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if 100 &gt; var and var &gt; 50 %&#125;</span><br><span class="line">    var大于50小于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ul><li>除去运算符之外，<code>if</code>标签还支持<code>in</code>和<code>not in</code>的判断运算</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if 1 in test_list %&#125;</span><br><span class="line">    列表中有数字1</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h5 id="其他常用标签"><a href="#其他常用标签" class="headerlink" title="其他常用标签"></a>其他常用标签</h5><blockquote><p>其实<code>django</code>官方提供了不只<code>if</code>和<code>for</code>这样的模板标签，还提供了很多可以让我们在模板页面上实现之前只能在后台进行逻辑实现的功能标签，比如以下：</p></blockquote><h6 id="comment-标签"><a href="#comment-标签" class="headerlink" title="comment 标签"></a>comment 标签</h6><blockquote><p><code>comment</code>标签常用来注释，在&#123;% comment %&#125;和&#123;% endcomment %&#125;中间的部分内容会被忽略；</p><p>这个标签不能嵌套使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% comment %&#125;</span><br><span class="line">这里的内容会被忽略，相当于注释起来。</span><br><span class="line">&#123;% endcomment %&#125;</span><br></pre></td></tr></table></figure><h6 id="autoescape-标签"><a href="#autoescape-标签" class="headerlink" title="autoescape 标签"></a>autoescape 标签</h6><blockquote><p>默认情况下，为了安全起见，模板在接收到一个<code>HTML</code>标签或者<code>css</code>样式等具有实际意义的变量字符串时；</p><p>会对他进行转义，不会将这个字符串处理为HTML中实际的标签。一个<code>&lt;h1&gt;</code>标签到最后会被处理成：</p><h1>，这样浏览器就不会把他解释成一个标签的样式了<p></p></h1></blockquote><ul><li>转义规则</li></ul><table><thead><tr><th align="left">符号</th><th align="left">转义规则</th></tr></thead><tbody><tr><td align="left">&lt;</td><td align="left"><code>&amp;lt;</code></td></tr><tr><td align="left">&gt;</td><td align="left"><code>&amp;gt;</code></td></tr><tr><td align="left">‘（单引号）</td><td align="left"><code>&amp;#39;</code></td></tr><tr><td align="left">“（双引号）</td><td align="left"><code>&amp;quot;</code></td></tr><tr><td align="left">&amp;</td><td align="left"><code>&amp;amp;</code></td></tr></tbody></table><blockquote><p>那么有的时候，我们可能需要这样类似的HTML标签真正效果展示出来，</p><p>比如一个<code>&lt;h1&gt;</code>标签我们希望他真正展示出<code>h1</code>的样子，而不是一个朴素的<code>&lt;h1&gt;</code>字符串，那么就需要我们使用autoescape标签来进行防止转义处理</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str_ = "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是H1标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>"</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape on %&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure><h6 id="cycle-标签"><a href="#cycle-标签" class="headerlink" title="cycle 标签"></a>cycle 标签</h6><blockquote><p><code>cycle</code>标签提供一些可迭代数据；</p><p>它的结构像是一个环，其中的数据通过空格分割，你可以使用任意数量的值，作为接下里每一次循环迭代的数据</p><p>其他包含在单引号 <code>&#39;</code>或者双引号 <code>&quot;</code>中的值被认为是可迭代字符串，如果没有被字符串引号包围的值被当作模版变量</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_ = ['l','i','s','t'] # 视图定义的模板变量</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.blue</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"&#123;% cycle 'red' 'blue' %&#125;"</span>&gt;</span></span><br><span class="line">        &#123;&#123; var &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很简单的就可以通过<code>cycle</code>标签进行循环中的样式切换啦</p><p>循环遍历出来的列表中每一个字都是换着颜色展示</p></blockquote><blockquote><p>某些时候，我们可能希望在使用一次<code>cycle</code>之后，接下来使用不是继续向后迭代取值，而是继续沿用这一次取到的值；</p><p>那么我们可以通过<code>as</code>语法给<code>cycle</code>标签取别名，在接下来需要沿用的地方直接使用别名作为模板变量即可，比如这样</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;% cycle 'red' 'blue' as style %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><ul><li>每一次循环取到的cycle其中的值，都可以通过别名style在这次循环区域中重复利用而不递进</li></ul><blockquote><p>但是我们发现个问题，<code>as</code>语句本身在使用时也会造成对<code>cycle</code>中的数据进行一次取值，那有什么办法可以在第一次<code>as</code>语句出现时，我只做声明，而不是为了取值，<code>django</code>模板中提供了一个叫<code>silent</code>的属性，可以用来<code>as</code>命名时不进行取值动作</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% cycle 'red' 'blue' as style silent %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% cycle 'red' 'blue' as style silent %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% cycle style %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% cycle style %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>silent</code>可以在初次定义时不进行取值，</p><p>接下来使用<code>cycle</code>所创建的迭代器，每次访问得到当前值，不会继续向后迭代；</p><p>如果希望取到下一个值，可以使用迭代器标签&#123;% style %&#125;，这次访问不会生产数据，但是会让迭代访问位置向后推进一次，在接下来&#123;&#123; style &#125;&#125;使用将得到下一个值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">red</span><br><span class="line">red</span><br><span class="line">blue</span><br><span class="line">red</span><br><span class="line">red</span><br></pre></td></tr></table></figure><h6 id="ifchanged-标签"><a href="#ifchanged-标签" class="headerlink" title="ifchanged 标签"></a>ifchanged 标签</h6><blockquote><p><code>ifchanged</code>标签用在<code>for</code>标签中；</p><p>检测这一次迭代的值和上一次迭代的值是否有改变，可以搭配<code>else</code>标签使用，用来确定是没有改变；</p><p>检查标签&#123;% ifchanged %&#125;和&#123;% endifchanged %&#125;之间的数据在每一次迭代过程中是否发生改变</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_ = [1,1,1,2,3]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">&#123;% ifchanged %&#125; </span><br><span class="line">&#123;&#123; var &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">数据未发生变化</span><br><span class="line">&#123;% endifchanged %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">数据未发生变化 </span><br><span class="line">数据未发生变化 </span><br><span class="line">2 </span><br><span class="line">3</span><br></pre></td></tr></table></figure><h6 id="firstof-标签"><a href="#firstof-标签" class="headerlink" title="firstof 标签"></a>firstof 标签</h6><blockquote><p><code>firstof</code>标签用来查找到标签内变量中第一个为<code>True</code>的参数并输出，如果标签内变量均为<code>False</code>，那么输出空</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% firstof 0 0 0 0 0 "哈哈哈" %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈哈哈</span><br></pre></td></tr></table></figure><h6 id="ifequal-标签"><a href="#ifequal-标签" class="headerlink" title="ifequal 标签"></a>ifequal 标签</h6><blockquote><p><code>ifequal</code>标签接收两个变量，用来判断这两个值是否相等，如果相等，展示对应内容</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ifequal 1 "1" %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>两个值相等<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% else %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>两个值不等<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endifequal %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这都不用想的，俩类型都不一样</li></ul><h6 id="ifnotequal-标签"><a href="#ifnotequal-标签" class="headerlink" title="ifnotequal 标签"></a>ifnotequal 标签</h6><blockquote><p>上面的反义</p></blockquote><h6 id="now-标签"><a href="#now-标签" class="headerlink" title="now 标签"></a>now 标签</h6><blockquote><p>显示日期或时间，标签必须一个参数，用来指定当前时间日期的描述方式；</p><p>输出最终格式与项目时区及语言设置有关</p><p>参数是一个描述字符串，比较多，记着常用的就行</p></blockquote><table><thead><tr><th align="left">秒</th><th align="left"></th></tr></thead><tbody><tr><td align="left">u</td><td align="left">微妙，000000-999999</td></tr><tr><td align="left">s</td><td align="left">秒，00-59</td></tr><tr><td align="left">Z</td><td align="left">时区偏移量（UTC），单位为秒。-43200到43200</td></tr><tr><td align="left">U</td><td align="left">自Unix 时间以来的秒数。1970年1月1日00:00:00 UTC</td></tr></tbody></table><table><thead><tr><th align="left">分钟</th><th align="left"></th></tr></thead><tbody><tr><td align="left">i</td><td align="left">分钟，00-59</td></tr></tbody></table><table><thead><tr><th align="left">小时</th><th align="left"></th></tr></thead><tbody><tr><td align="left">g</td><td align="left">12小时格式，1-12’</td></tr><tr><td align="left">G</td><td align="left">24小时格式，00-23</td></tr><tr><td align="left">h</td><td align="left">12小时格式，00-12</td></tr><tr><td align="left">H</td><td align="left">24小时格式，00-23</td></tr><tr><td align="left">O</td><td align="left">时区差值，单位小时，如：Asia/Shanghai时区：+0800</td></tr><tr><td align="left">P</td><td align="left">当前几时几分，如：5:30 pm</td></tr><tr><td align="left">f</td><td align="left">当前几时几分，不包含上下午标示，如：5:30</td></tr><tr><td align="left">a</td><td align="left">小写字母：a.m.、p.m.</td></tr><tr><td align="left">A</td><td align="left">大写字母：AM、PM</td></tr></tbody></table><table><thead><tr><th align="left">月份</th><th align="left"></th></tr></thead><tbody><tr><td align="left">b</td><td align="left">月份英文字母的前三个表示，均小写。如：”aug”</td></tr><tr><td align="left">d</td><td align="left">这个月的第几天，01-31</td></tr><tr><td align="left">j</td><td align="left">这个月的第几天，1-31</td></tr><tr><td align="left">E</td><td align="left">当前时区月份英文单词全拼</td></tr><tr><td align="left">F</td><td align="left">当前月份英文单词全拼</td></tr><tr><td align="left">m</td><td align="left">第几月，01-12</td></tr><tr><td align="left">M</td><td align="left">月份英文字母的前三个表示，首字母大写。如：”Aug”</td></tr><tr><td align="left">n</td><td align="left">第几月，1-12</td></tr><tr><td align="left">N</td><td align="left">美联社月份缩写，如：’Jan.’，’Feb.’，’March’，’May’</td></tr></tbody></table><table><thead><tr><th align="left">星期</th><th align="left"></th></tr></thead><tbody><tr><td align="left">D</td><td align="left">星期几的英文单词前三个表示，首字母大写，如：’Fri’</td></tr><tr><td align="left">l</td><td align="left">星期几的英文单词全拼，如：’Friday’</td></tr><tr><td align="left">w</td><td align="left">星期几的数字，0（星期日）-6（星期六）</td></tr><tr><td align="left">W</td><td align="left">ISO-8601周数，今年第几周</td></tr></tbody></table><table><thead><tr><th align="left">年</th><th align="left"></th></tr></thead><tbody><tr><td align="left">L</td><td align="left">Bool值判断是否为闰年</td></tr><tr><td align="left">y</td><td align="left">第几年两位数字，如：2018年，返回18</td></tr><tr><td align="left">Y</td><td align="left">第几年，目前是：2018</td></tr><tr><td align="left">Z</td><td align="left">今天是今年的第几天</td></tr></tbody></table><table><thead><tr><th align="left">其他</th><th align="left"></th></tr></thead><tbody><tr><td align="left">c</td><td align="left">ISO 8601时间格式</td></tr><tr><td align="left">e</td><td align="left">当前时区名称：CST（美国-6:00，澳大利亚+9:30，中国+8:00，古巴-4:00）</td></tr><tr><td align="left">r</td><td align="left">RFC 5322格式化日期</td></tr><tr><td align="left">S</td><td align="left">一个月的第几天的英文序数后缀：’st’，’nd’，’rd’或’th’</td></tr><tr><td align="left">t</td><td align="left">当前月份的天数：28-31</td></tr><tr><td align="left">T</td><td align="left">当前时区</td></tr></tbody></table><ul><li>选出你想表达的时间，比如年月日，那么可以这样</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% now "Y-m-d" %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-03-26</span><br></pre></td></tr></table></figure><ul><li>除了以上自己组合的格式化字符，还有一些已经预定义好的字符串</li></ul><table><thead><tr><th align="left">字符串</th><th align="left">对应格式 时间</th></tr></thead><tbody><tr><td align="left">DATE_FORMAT</td><td align="left">‘N j, Y’ Feb. 5, 2018</td></tr><tr><td align="left">DATETIME_FORMAT</td><td align="left">‘N j, Y, P’ Feb. 4, 2013, 4 p.m.</td></tr><tr><td align="left">SHORT_DATE_FORMAT</td><td align="left">‘m/d/Y’ 12/31/2015</td></tr><tr><td align="left">SHORT_DATETIME_FORMAT</td><td align="left">‘m/d/Y P’ 12/31/2019 11:59 p.m.</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>DATE_FORMAT: &#123;% now "DATE_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>DATETIME_FORMAT: &#123;% now "DATETIME_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>SHORT_DATE_FORMAT: &#123;% now "SHORT_DATE_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>SHORT_DATETIME_FORMAT: &#123;% now "SHORT_DATETIME_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT: March 26, 2019</span><br><span class="line">DATETIME_FORMAT: March 26, 2019, 3:45 a.m.</span><br><span class="line">SHORT_DATE_FORMAT: 03/26/2019</span><br><span class="line">SHORT_DATETIME_FORMAT: 03/26/2019 3:45 a.m.</span><br></pre></td></tr></table></figure><blockquote><p>最后<code>now</code>标签也支持<code>as</code>的用法，可以方便我们在模板中使用一个已经格式化好的输出</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% now "Y-m-d H:i:s" as show_time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; show_time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>发现时间输出不正确，记得查看<code>settings</code>文件下的<code>TIME_ZONE</code>配置</li></ul><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote><p>除了模板标签可以帮助我们对数据或者进行逻辑处理</p><p><code>django</code>中还提供了一款工具叫做过滤器，过滤器也可以实现一些模板变量的运算，判断或是其他逻辑处理</p></blockquote><h6 id="add"><a href="#add" class="headerlink" title="add"></a>add</h6><blockquote><p>语法：&#123;&#123; var1|add:var2 &#125;&#125;</p></blockquote><blockquote><p><code>add</code>过滤器可以实现<code>var1</code>与<code>var2</code>的相加，并且在遇到其他相同数据类型的，比如列表时，加号还可以重载为拼接功能</p></blockquote><blockquote><p>过滤器首先会将数据转换成Int类型，进行相加，如果转换失败，则会尝试使用<code>Python</code>中的数据类型</p><p>列表、元祖等这样的数据类型来进行转换，并且执行对应类型的加法</p><p>如果都转换失败，那么结果为一个空字符串</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>add :&#123;&#123; value|add:10 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>add :&#123;&#123; list_1|add:list_2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="capfirst"><a href="#capfirst" class="headerlink" title="capfirst"></a>capfirst</h6><blockquote><p>语法：&#123;&#123; var|capfirst &#125;&#125;</p></blockquote><blockquote><p>将变量第一个字母变为大写，如果第一个字符不是字母，过滤器不生效</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>capfirst:&#123;&#123; "Abc"|capfirst &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>capfirst:&#123;&#123; "1abc"|capfirst &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="center"><a href="#center" class="headerlink" title="center"></a>center</h6><blockquote><p>语法：&#123;&#123; value|center:”length” &#125;&#125;</p></blockquote><blockquote><p>使<code>value</code>在给定的<code>length</code>范围内居中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>center: &#123;&#123; "abc"|center:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h6><blockquote><p>语法：&#123;&#123; value|cut:”str” &#125;&#125;</p></blockquote><blockquote><p>在<code>value</code>中移除所有<code>str</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>cut: &#123;&#123; "a*b*c"|cut:"*" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="date"><a href="#date" class="headerlink" title="date"></a>date</h6><blockquote><p>语法：&#123;&#123; value|date:SHORT_DATE_FORMAT” &#125;&#125;</p></blockquote><blockquote><p>与&#123;% now %&#125;标签所使用格式字符一致；<code>value</code>为一个<code>datetime</code>对象</p><p>输出最终格式与项目时区及语言设置有关</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime = datetime.datetime.now()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;date: &#123;&#123; datetime|date:&quot;H:i&quot; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;date: &#123;&#123; datetime|date:&quot;Y/m/d&quot; &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h6 id="default"><a href="#default" class="headerlink" title="default"></a>default</h6><blockquote><p>语法：&#123;&#123; value|default:”默认值” &#125;&#125;</p></blockquote><blockquote><p>如果<code>value</code>值为假，则取”默认值”，反之返回<code>value</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default: &#123;&#123; 0|default:"这是展示的默认值" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>非空非0为真，0或空为假</p></blockquote><h6 id="default-if-none"><a href="#default-if-none" class="headerlink" title="default_if_none"></a>default_if_none</h6><blockquote><p>语法：&#123;&#123; value|default_if_none:”默认值” &#125;&#125;</p></blockquote><blockquote><p>如果<code>value</code>值为<code>None</code>，则取”默认值”，反之返回<code>value</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default_if_none: &#123;&#123; None|default_if_none:"value值为None" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default_if_none: &#123;&#123; 0|default_if_none:"aaaa" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="dictsort"><a href="#dictsort" class="headerlink" title="dictsort"></a>dictsort</h6><blockquote><p>语法：&#123;&#123; value|dictsort:”attr” &#125;&#125;</p></blockquote><blockquote><p><code>value</code>为字典列表数据，列表中数据均为类字典数据：<code>[ {1:&#39;a&#39;}, {2:&#39;b&#39;}, ]</code></p><p>根据给定<code>attr</code>值进行排序，一般是<strong>从小到大</strong>的顺序</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sort_list_dict = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小绿'</span>, <span class="string">'department'</span>: <span class="string">'Development'</span>, <span class="string">'age'</span>: <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小红'</span>, <span class="string">'department'</span>: <span class="string">'Leader'</span>, <span class="string">'age'</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小飞'</span>, <span class="string">'department'</span>: <span class="string">'Test'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小落'</span>, <span class="string">'department'</span>: <span class="string">'Development'</span>, <span class="string">'age'</span>: <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'大胖'</span>, <span class="string">'department'</span>: <span class="string">'Leader'</span>, <span class="string">'age'</span>: <span class="number">43</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>dictsort: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% for var in sort_list_dict|dictsort:"age" %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; var.name &#125;&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h6 id="dictsortreversed"><a href="#dictsortreversed" class="headerlink" title="dictsortreversed"></a>dictsortreversed</h6><blockquote><p>语法：&#123;&#123; value|dictsortreversed:”attr” &#125;&#125;</p></blockquote><blockquote><p>与<code>dictsort</code>功能相同，但是排序方式与<code>dictsort</code>相反，从大到小</p></blockquote><h6 id="divisibleby"><a href="#divisibleby" class="headerlink" title="divisibleby"></a>divisibleby</h6><blockquote><p>语法：&#123;&#123; value|divisibleby:num &#125;&#125;</p></blockquote><blockquote><p>如果给定的<code>value</code>可以被<code>num</code>整除，返回<code>True</code>；反之，返回<code>False</code></p><p>常用来做整除判断</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>divisibleby: &#123;&#123; 8|divisibleby:2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h6><blockquote><p>语法：&#123;&#123; value|escape &#125;&#125;</p></blockquote><blockquote><p>将value值转义输出；</p><p>可以在取消转义autoescape标签下，选择性的打开某些需要转义的数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    &#123;&#123; str_|escape &#125;&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure><h6 id="safe"><a href="#safe" class="headerlink" title="safe"></a>safe</h6><blockquote><p>语法：&#123;&#123; value|safe &#125;&#125;</p></blockquote><blockquote><p>取消转义，与&#123;% autoescape off %&#125;标签意义相同</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str_|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="safeseq"><a href="#safeseq" class="headerlink" title="safeseq"></a>safeseq</h6><blockquote><p>语法：&#123;&#123; value|safeseq &#125;&#125;</p></blockquote><blockquote><p>处理一个包含标签字符串的列表数据，简单的<code>safe</code>是不行的，因为<code>safe</code>过滤器会把内容先整体处理为字符串；而不是依次过滤序列中的数据，而<code>safeseq</code>过滤器则会依次处理序列中的每一个数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_ = [</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h2</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>",</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h3</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>",</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; list_|safe|join:&quot;&quot; &#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">------------------</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123; list_|safeseq|join:&quot;&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><h6 id="filesizeformat"><a href="#filesizeformat" class="headerlink" title="filesizeformat"></a>filesizeformat</h6><blockquote><p>语法：&#123;&#123; value|filesizeformat &#125;&#125;</p></blockquote><blockquote><p>格式化value值为人类可读的计算机存储单位。如：1 bytes、1.2 MB；</p><p>如果不是一个可以处理的数值类型，返回0。</p><p>最小单位为byte</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>filesizeformat : &#123;&#123; "1"|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>filesizeformat : &#123;&#123; "3758331"|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="first"><a href="#first" class="headerlink" title="first"></a>first</h6><blockquote><p>语法：&#123;&#123; value|first &#125;&#125;</p></blockquote><blockquote><p>返回序列数据<code>value</code>中的第一项</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>first : &#123;&#123; "abc"|first &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="last"><a href="#last" class="headerlink" title="last"></a>last</h6><blockquote><p>语法：&#123;&#123; value|last &#125;&#125;</p></blockquote><blockquote><p>返回序列数据<code>value</code>中的最后一项</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>last : &#123;&#123; "abc"|last &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="floatformat"><a href="#floatformat" class="headerlink" title="floatformat"></a>floatformat</h6><blockquote><p>语法：&#123;&#123; value|floatformat:”精度” &#125;&#125;</p></blockquote><blockquote><p>设置浮点数<code>value</code>的精度，没有参数时，默认四舍五入<strong>保留小数点后一位</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.2332"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.2550"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.0000"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><blockquote><p>语法：&#123;&#123; value|join:”str” &#125;&#125;</p></blockquote><blockquote><p>将序列数据<code>value</code>通过<code>str</code>进行拼接</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>join : &#123;&#123; "abc"|join:"*" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="length-is"><a href="#length-is" class="headerlink" title="length_is"></a>length_is</h6><blockquote><p>语法：&#123;&#123; value|length_is:”num” &#125;&#125;</p></blockquote><blockquote><p>判断序列<code>value</code>的长度是否为<code>num</code>，如果是，返回<code>True</code>，反之返回<code>False</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;length_is : &#123;&#123; &quot;abc&quot;|length_is:4 &#125;&#125;&lt;/p&gt;&lt;p&gt;length_is : &#123;&#123; &quot;abcd&quot;|length_is:4 &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h6 id="linebreaksbr"><a href="#linebreaksbr" class="headerlink" title="linebreaksbr"></a>linebreaksbr</h6><blockquote><p>语法：&#123;&#123; value|linebreaksbr &#125;&#125;</p></blockquote><blockquote><p>将字符串<code>value</code>中的所有换行符<code>\n</code>转换为<code>HTML</code>换行符<code>&lt;br&gt;</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str_ = "abc\nbbb"</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linebreaksbr : &#123;&#123; str_|linebreaksbr &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="linenumbers"><a href="#linenumbers" class="headerlink" title="linenumbers"></a>linenumbers</h6><blockquote><p>语法：&#123;&#123; value|linenumbers &#125;&#125;</p></blockquote><blockquote><p>显示<code>value</code>数据的行号，一般来说，是根据<code>value</code>字符串中的<code>\n</code>换行来确定每一行</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str_ = "abc\nbbb"</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linenumbers :<span class="tag">&lt;<span class="name">br</span>&gt;</span> &#123;&#123; str_|linenumbers &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linenumbers :<span class="tag">&lt;<span class="name">br</span>&gt;</span> &#123;&#123; str_|linenumbers|linebreaksbr &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="ljust"><a href="#ljust" class="headerlink" title="ljust"></a>ljust</h6><blockquote><p>语法：&#123;&#123; value|ljust:”num” &#125;&#125;</p></blockquote><blockquote><p>将字符串<code>value</code>按照给定宽度<code>num</code>左对齐</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>ljust : &#123;&#123;"test"|ljust:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>HTML中</code>空格是被忽略的，所以直观的我们并看不到这个过滤器的对齐效果</p><p>需要使用<code>&amp;nbsp</code>才可以在<code>HTML</code>中展示真正的空格效果，这个操作会在之后的自定义过滤器中为大家介绍</p></blockquote><h6 id="rjust"><a href="#rjust" class="headerlink" title="rjust"></a>rjust</h6><blockquote><p>语法：&#123;&#123; value|rjust:”num” &#125;&#125;</p></blockquote><blockquote><p>将字符串<code>value</code>按照给定宽度<code>num</code>右对齐</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>rjust : &#123;&#123; "test"|rjust:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h6><blockquote><p>语法：&#123;&#123; value|lower &#125;&#125;</p></blockquote><blockquote><p>将字符串<code>value</code>中的全部字符串小写</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>rjust : &#123;&#123; "Aa123Bb"|lower &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h6><blockquote><p>语法：&#123;&#123; value|upper &#125;&#125;</p></blockquote><blockquote><p>将字符串<code>value</code>中的全部字符串大写</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>upper : &#123;&#123; "Aa123Bb"|upper &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="title"><a href="#title" class="headerlink" title="title"></a>title</h6><blockquote><p>语法：&#123;&#123; value|title &#125;&#125;</p></blockquote><blockquote><p>将<code>value</code>字符串中每一个单词首字母大写，其余字符小写</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>title : &#123;&#123; "heLLO a12b world"|title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="make-list"><a href="#make-list" class="headerlink" title="make_list"></a>make_list</h6><blockquote><p>语法：&#123;&#123; value|make_list &#125;&#125;</p></blockquote><blockquote><p>将<code>value</code>转换为列表</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>make_list : &#123;&#123; "a1好a2a"|make_list &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">['a', '1', '好', 'a', '2', 'a']</span><br></pre></td></tr></table></figure><h6 id="random"><a href="#random" class="headerlink" title="random"></a>random</h6><blockquote><p>语法：&#123;&#123; value|random &#125;&#125;</p></blockquote><blockquote><p>返回<code>value</code>序列中的一个随机值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>random : &#123;&#123; "12345"|random &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h6><blockquote><p>语法：&#123;&#123; value|slice:”start:stop:step” &#125;&#125;</p></blockquote><blockquote><p>与<code>Python</code>中序列切片用法类似，取出一定范围内的数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:5" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:6" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:6:2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><blockquote><p>语法：&#123;&#123; value|time:”time_format” &#125;&#125;</p></blockquote><blockquote><p>与<code>date</code>过滤器类似，但该过滤器只处理时、分、秒；</p><p>根据时间格式化字符输出时间，输出最终格式与项目时区及语言设置有关</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime = datetime.datetime.now()</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time: &#123;&#123; datetime|time:"H:i" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time: &#123;&#123; datetime|time:"Y/m/d" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="timesince"><a href="#timesince" class="headerlink" title="timesince"></a>timesince</h6><blockquote><p>语法：&#123;&#123; start_time|timesince:end_time &#125;&#125;</p></blockquote><blockquote><p>计算从<code>start_time</code>一直到<code>end_time</code>的时间间隔，<code>end_time</code>为可选，没有该值，截至从当前时间开始</p><p>分钟为返回最小单位</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_time = datetime.datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>)</span><br><span class="line">end_time = datetime.datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time : &#123;&#123; start_time|timesince:end_time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span></span></span><br><span class="line">&lt;p&gt;time : &#123;&#123; start_time|timesince &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time : 2 days, 2 hours</span><br><span class="line">time : 3 weeks, 2 days</span><br></pre></td></tr></table></figure><h6 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h6><blockquote><p>语法：&#123;&#123; value|urlencode &#125;&#125;</p></blockquote><blockquote><p>使用连接编码格式处理<code>value</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlencode : &#123;&#123; "http://example.com"|urlencode &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlencode : http%3A//example.com</span><br></pre></td></tr></table></figure><h6 id="urlize"><a href="#urlize" class="headerlink" title="urlize"></a>urlize</h6><blockquote><p>语法：&#123;&#123; value|urlize &#125;&#125;</p></blockquote><blockquote><p>使连接字符串<code>value</code>变为可点击的a标签连接</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlize : &#123;&#123; "http://example.com"|urlize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlize : &#123;&#123; "http://example.com" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="人性化过滤器"><a href="#人性化过滤器" class="headerlink" title="人性化过滤器"></a>人性化过滤器</h5><blockquote><p>除去上面所介绍的过滤器，django还提供了一个专门人性化处理数据的过滤器组件；</p><p>使用时，需要将<strong>‘django.contrib.humanize’</strong>添加到<code>settings.py</code>文件中的<code>INSTALLED_APPS</code>属性中</p><p>之后在模板页面加载&#123;% load humanize %&#125;就可以使用到<code>humanize</code>中的人性化过滤器</p></blockquote><h6 id="apnumber"><a href="#apnumber" class="headerlink" title="apnumber"></a>apnumber</h6><blockquote><p>语法：&#123;&#123; value|apnumber &#125;&#125;</p></blockquote><blockquote><p>将整数转化为字符串，并按照语言设置返回对应的数字表示方式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intcomma : &#123;&#123; "3000"|intcomma &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intcomma : &#123;&#123; "23300"|intcomma &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="intword"><a href="#intword" class="headerlink" title="intword"></a>intword</h6><blockquote><p>语法：&#123;&#123; value|intword &#125;&#125;</p></blockquote><blockquote><p>将一个大型数字转换成友好的文字表达形式，适合超过<code>100万</code>的数字</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intword : &#123;&#123; "310100100"|intword &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="naturalday"><a href="#naturalday" class="headerlink" title="naturalday"></a>naturalday</h6><blockquote><p>语法：&#123;&#123; value|naturalday &#125;&#125;</p></blockquote><blockquote><p>返回value时间相对于今天。返回”今天”，”明天”或者”昨天”</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">today = datetime.datetime.now()</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>naturalday : &#123;&#123; today|naturalday &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="naturaltime"><a href="#naturaltime" class="headerlink" title="naturaltime"></a>naturaltime</h6><blockquote><p>语法：&#123;&#123; value|naturaltime &#125;&#125;</p></blockquote><blockquote><p>获得<code>value</code>与当前时间的时间间隔，并使用合适的文字来描述；</p><p>如果超过一天间隔，将会使用<code>timesice</code>过滤器格式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_time = datetime.datetime(2019, 3, 3, 15)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>naturalday : &#123;&#123; start_time|naturaltime &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><blockquote><p>虽然有了django给我们提供的这么多方便的标签和过滤器；</p><p>但是有些时候，还不能达成我们想要的功能，那么就需要我们自定义标签和过滤器</p><p>django默认的过滤器及标签文件夹：</p><p> <code>django/template/defaultfilters.py</code></p><p> <code>django/template/defaulttags.py</code></p></blockquote><ol><li><p>在<strong>当前app下</strong>创建保存自定义标签及过滤器的文件夹，这个文件夹常命名为<code>templatetags</code></p></li><li><p>为了支持该文件夹可以作为模块导入，<code>templatetags</code>文件夹下创建<code>__init__.py</code>文件</p></li><li><p>创建过滤器<code>xxxx.py</code>文件，文件名自定义</p></li><li><p>过滤器文件头部必须包含名为<code>register</code>的全局变量，该变量是<code>template.Library</code>对象的实例</p></li><li><p>自定义过滤器为一个<code>Python</code>函数，参数可以是<code>1-2</code>个</p><ul><li>比如&#123;&#123; value|upper &#125;&#125;，过滤器函数名为<code>upper</code>，参数为<code>value</code></li></ul><blockquote><p>注意：过滤器参数可以是一个字符串，也可以使类似列表的其他类型，参数可以设置默认值。另外需要注意的是模板中无法进行异常处理，过滤器一旦出现错误，将会引发服务器错误</p></blockquote></li><li><p>最重要的一步，所有编写完成的过滤器函数，都要记得：使用<code>register.filter()</code>函数将其注册为<code>Library</code>实例</p><ul><li><p><code>register.filter(name=None, filter_func=None)</code>：注册过滤函数</p><blockquote><p><code>name</code>：一个字符串，表示过滤器在模板的使用名称</p><p><code>filter_func</code>：编写好的过滤器函数</p></blockquote></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/templatetags/my_filter.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_length</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment">#  返回变量长度</span></span><br><span class="line">    <span class="keyword">return</span> len(str(value))</span><br><span class="line"></span><br><span class="line">register.filter(<span class="string">"return_length"</span>,return_length)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 'abc'|return_length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 返回3 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此外：除了我们使用<code>register.filter</code>函数来对过滤器函数进行注册；</p><p>还可以将<code>register.filter</code>作为装饰器<code>@register.filter</code>来使用，可以更加方便的进行过滤器函数注册</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter(name="delete_space")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_space</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment"># 去掉value数据中所有空格</span></span><br><span class="line"><span class="keyword">return</span> value.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br></pre></td></tr></table></figure><blockquote><p>但是，这里有个问题，我们的过滤器经常期望处理的数据类型是一个字符串，但是以上过滤器如果在对数字类型进行处理时，会引发<code>&#39;int&#39; object has no attribute &#39;replace&#39;</code>，这样的错误，那么需要我们对传入过滤器的value参数进行字符串转变的处理</p><p>解决办法也很简单，大家可能想到了直接用字符串工厂函数去转换传入参数、但是这里有更加优雅安全的方式，通过<code>django.template.defaultfilter</code>模块下的<code>stringfilter</code>装饰器来对过滤器函数进行装饰</p><p><code>stringfilter</code><strong>这个装饰器可以帮助我们把传入过滤器函数的参数转换为它的字符串值</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template.defaultfilters <span class="keyword">import</span> stringfilter</span><br><span class="line"><span class="meta">@register.filter(name="delete_space")</span></span><br><span class="line"><span class="meta">@stringfilter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_space</span><span class="params">(value)</span>:</span></span><br><span class="line"><span class="keyword">return</span> value.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br></pre></td></tr></table></figure><blockquote><p>现在过滤器函数的<code>value</code>参数将会先被装饰器<strong>@stringfilter</strong>处理成对应的字符串类型之后</p><p>才会被作为参数传递到过滤器函数<code>delete_space</code>中</p><p>接下来通过这个过滤器处理一个<strong>非字符串类型</strong>也就不会在报错了</p></blockquote><h5 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h5><blockquote><p>标签要实现的功能可以比过滤器更加强大，可以支持接收更多参数！</p></blockquote><blockquote><p>基本使用语法 &#123;% tag “arg1” “arg2” “arg3” … %&#125;</p></blockquote><blockquote><p>很多模板标签可以接收多个参数，字符串或者模板变量；并且可以将这些变量经过一系列处理之后返回一个字符串这样的标签我们可以通过django为我们提供的<code>simple_tag()</code>注册函数来进行编写，该函数来自于<code>django.template.Library</code></p></blockquote><blockquote><p>同样的，编写自定义标签函数完成之后，也需要进行注册，也可以直接将<code>@simple_tag</code>作为装饰器使用注册</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line"></span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag(name="myUpper")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myUpper</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment"># 将模板变量处理为纯大写的模板标签</span></span><br><span class="line">    <span class="keyword">return</span> str(value).upper()</span><br><span class="line"><span class="comment"># register.simple_tag(name="myUpper",func=myUpper)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>simple_tag()</code>函数在这里帮助我们做了如下工作：</p><ul><li><p>检查标签函数所需参数数量</p></li><li><p>截掉参数中的引号，确保函数接收到的是一个普通的字符串</p></li><li><p>截掉参数中的引号，确保函数接收到的是一个普通的字符串</p></li></ul></li></ul><blockquote><p>如果我们希望标签函数可以访问到当前模板中其他全部的模板变量值；</p><p>那么可以使用simple_tag(takes_context=True)参数</p><p>比如通过视图函数向模板返回了</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = '哈哈哈哈哈哈'</span><br><span class="line">return render(request, template, locals())</span><br></pre></td></tr></table></figure><blockquote><p>可以在自定义标签处通过<code>simple_tag(takes_context=True)</code>来进行视图函数中<code>content</code>值的获取；</p><p>但是还要注意的是，此时自定义标签函数参数位置第一个必须为<code>context</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@register.simple_tag(takes_context=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_context</span><span class="params">(context)</span>:</span></span><br><span class="line">value = context.get(<span class="string">"value"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"获取到的模板变量:%s"</span> % value</span><br></pre></td></tr></table></figure><blockquote><p>模板页面直接使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;% get_context %&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h5><blockquote><p>关于模板，经常重复的编写页面是一个非常痛苦的事情；</p><p>那么在<code>django</code>中也提供了一种非常舒服方便的方法，可以使新的模板页面来继承自一个已编写好的<code>html</code>页面实现复用，免去重复工作；这就是模板继承</p></blockquote><h6 id="block"><a href="#block" class="headerlink" title="block"></a>block</h6><blockquote><p>页面的继承不能说全部都拿过来，有时候只需要已经编写好的页面某些部分</p><p>其他部分提前挖好一些坑，去填充不同内容</p><p>挖坑可以通过模板中的&#123;% block %&#125;标签</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block name %&#125;</span><br><span class="line">预留区域，可供未来继承的页面覆盖</span><br><span class="line">&#123;% endblock name %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设计一个可以被继承的父模板，我们经常叫做base.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% block title %&#125;</span><br><span class="line">        父模板标题</span><br><span class="line">        &#123;% endblock title %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% block top %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>这里是父模板页面内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个页面中，我们设计了三个<code>block</code>标签块<code>title</code>、<code>content</code>以及<code>top</code>；</p><p>每一个块都可以被之后继承的页面所覆盖新的内容</p></blockquote><ul><li>继承页面使用&#123;% extends “base.html” %&#125;标签进行页面的继承，现在编写一个test.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">    子模版</span><br><span class="line">&#123;% endblock title %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block top %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子模版<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% block other %&#125;</span><br><span class="line">    哈哈哈哈哈</span><br><span class="line">    这里的内容不会显示</span><br><span class="line">    父模板并没有这样的block块</span><br><span class="line">&#123;% endblock other%&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了对应<code>block</code>标签内容被子模板修改，其余内容均默认使用父模板中的</p></blockquote><ul><li><p>注意：</p><ul><li><p>如果父模板内有模板变量或者其他上下文数据，不会被子模板继承，但是子模板可以为父模板内的模板数据赋值</p></li><li><p>如果需模板中具有模板变量等上下文数据，只有放到<code>block</code>标签块内数据才会显示</p></li><li><p>子模板中修改父模板中并不存在的block块，子模板不会显示</p></li></ul></li></ul><h5 id="模板加载"><a href="#模板加载" class="headerlink" title="模板加载"></a>模板加载</h5><blockquote><p>除了&#123;% extends %&#125;与&#123;% block %&#125;结合的方式可以继承一个父模板</p><p>我们还可以使用&#123;% include %&#125;一个新的标签进行模板加载，<code>include</code>标签使用语法与<code>extends</code>类似</p></blockquote><h6 id="include"><a href="#include" class="headerlink" title="include"></a>include</h6><blockquote><p>现在新建一个html文件，名为<code>li.html</code>，用来写一个简单的列表</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>玩耍<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在需要导入的页面中使用&#123;% include “li.html” %&#125;进行引入</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">    子模版</span><br><span class="line">&#123;% endblock title %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block top %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子模版<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% include "li.html" %&#125;</span><br><span class="line">&#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>被<code>include</code>引入的新模板，会在渲染完成之后添加到父模板所给定的对应<code>block</code>块中</p></blockquote><blockquote><p>与<code>extends</code>不同，<code>extends</code>常用来控制整个模板的样式和效果；</p><p>而<code>include</code>更加细化，可以在一个模板内包含其他多个模板</p><p><strong>如果include所包含的模板页面中有模板变量需要被填充，会在包含include的页面下进行渲染</strong></p><p>这种行为也好像是，把一个新的渲染好的<code>html</code>页面嵌入了进来一样</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;模板层&quot;&gt;&lt;a href=&quot;#模板层&quot; class=&quot;headerlink&quot; title=&quot;模板层&quot;&gt;&lt;/a&gt;模板层&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Django中的HTML文件并不是一个简单的前端页面，他支持多种渲染方式；&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;Smart&lt;/code&gt;或是&lt;code&gt;Jinja&lt;/code&gt;这样出名的模板语言引擎，默认django使用的是templates引擎来进行模板页面的渲染，这也被称为Django模板语言（DTL）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://qzloo.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://qzloo.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Urls-路由层</title>
    <link href="https://qzloo.cn/2005/01/05/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/"/>
    <id>https://qzloo.cn/2005/01/05/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/</id>
    <published>2005-01-05T11:12:31.000Z</published>
    <updated>2020-01-03T05:53:51.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h4><blockquote><p>路由是Web服务的入口，就好像办事大厅有各个服务窗口一样</p></blockquote><a id="more"></a><blockquote><p>Django奉行DRY主义，提倡使用简洁、优雅的URL：</p><p> 可以不用<code>.html</code>、<code>.php</code>或<code>.cgi</code>之类后缀</p><p> 尽量不要单独使用无序随机数字这样无意义的东西</p><p> 让你随心所欲设计你的URL，不受框架束缚</p></blockquote><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><h6 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h6><blockquote><p>urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系</p><p>用户发起的请求<code>URL</code>都会首先进入主控制目录下的这个<code>urls.py</code>文件中进行查找匹配</p></blockquote><ol><li>首先找到<code>urls.py</code>下的<code>urlpatterns</code>全局变量，这是一个路由规则实例的列表数据。</li><li>按照先后定义顺序，进行路由匹配。</li><li>找到第一个匹配项时停止匹配，执行匹配到的视图函数。</li><li>遍历完全，未发现匹配，<code>django</code>进行异常处理</li></ol><blockquote><p>其中<code>urlpatterns</code>中的每一个路由映射规则可以由<code>path</code>或<code>re_path</code>进行构造</p></blockquote><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑<code>HTTP</code>请求方式，仅根据URL进行路由；即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><ul><li><p><code>path(regex, view, kwargs=None, name=None)</code></p><blockquote><p><code>regex</code>：一个匹配对应url地址的规则字符串。</p><p><code>view</code>：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函</p><p><code>kwargs</code>：视图函数的关键字参数。</p><p><code>name</code>：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为<code>url</code>取变量名，接下来全局使用该命名值即可；当对应<code>url</code>路由改变之后，结合路由反向解析使用的地方不需要更改路由</p><p>此外，<code>django</code>还提供了一个兼容老版本<strong>url</strong>路由配置函数的<strong>re_path</strong>函数；<code>re_path</code>：第一个参数部分为一个正则匹配规则，其他与path同</p></blockquote></li></ul><h5 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h5><blockquote><p>静态路由用来映射对应视图函数，以下是一个简单的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Worlds!'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.index),</span><br><span class="line">    re_path(<span class="string">r"^"</span>,views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><blockquote><p>有的时候，我们的路由设置不能一直维持一个一成不变的状态；</p><p>比如遇到一些内容翻页的场景，那么我们的连接可能是：<code>xx.com/airticle_list/1/</code>、<code>xx.com/airticle_list/2/</code></p><p>那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request,x,y)</span>:</span></span><br><span class="line">    content = <span class="string">"x:%s\ny:%s"</span> % (x,y)  </span><br><span class="line"><span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><p>定义如上函数，将会接收连接中的后两部份<code>path</code>值作为参数，分别依次给到<code>x</code>和<code>y</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;int:x&gt;/&lt;str:y&gt;/'</span>,views.index),</span><br><span class="line">    <span class="comment">#指明类型</span></span><br><span class="line">    path(<span class="string">"&lt;x&gt;/&lt;y&gt;/"</span>,views.index)</span><br><span class="line">    <span class="comment">#不指明类型</span></span><br><span class="line">    re_path(<span class="string">r"^(?P&lt;x&gt;\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$"</span>),</span><br><span class="line">    <span class="comment"># (?P&lt;name&gt;pattern) 正则分组</span></span><br><span class="line">    re_path(<span class="string">r"^(\d+)/([a-zA-Z]+)/$"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上；</p><p>访问：<code>http://127.0.0.1:8000/1/abc/</code></p><p>其中<code>1</code>将作为x的参数值，<code>abc</code>将作为y的参数</p><p>但如果访问连接是：<code>http://127.0.0.1:8000/abc/abc/</code>，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定</p></blockquote><ul><li>内置Path转换器：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式</span><br><span class="line">int：匹配正整数，包含<span class="number">0</span></span><br><span class="line">slug：匹配字母、数字以及横杠、下划线组成的字符串</span><br><span class="line">uuid：匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00</span><br><span class="line">path：匹配任何非空字符串，包含了路径分隔符</span><br></pre></td></tr></table></figure><h6 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h6><blockquote><p>除了以上<code>django</code>所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义<code>path</code>转换器</p></blockquote><ol><li><p>定义转换器类，类名随意</p></li><li><p>定义类中必须属性</p><blockquote><p><code>regex</code>：一个字符串形式的正则表达式，也是对应的路由规则</p><p><code>to_python(self, value)</code>：用于将匹配到的路由字符串转换为<code>Python</code>中的数据类型，并传递给视图函数，<strong>如果转换失败，必须抛出ValueError</strong>，路由映射视图函数时使用</p><p><code>to_url(self, value)</code>：将<code>Python</code>数据类型转换为一段url的方法，<code>to_python</code>方法的反向操作，反向解析时使用</p></blockquote></li><li><p>通过django.urls模块中的register_converter函数进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数第一个参数为转换器类</span><br><span class="line">函数第二个参数为转换器别名</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以下定义一个路由参数只能是三位字符的路由规则</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将转换器类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeChar</span>:</span></span><br><span class="line">    regex = <span class="string">"[a-zA-Z]&#123;3&#125;"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"to_python"</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        <span class="comment"># 当通过反向路由解析时，将会调用该函数</span></span><br><span class="line">        print(<span class="string">'to_url'</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)[:<span class="number">3</span>] </span><br><span class="line">    <span class="comment">#此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则</span></span><br><span class="line"><span class="comment">#注册转换器</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converter</span><br><span class="line">register_converter(ThreeChar,<span class="string">'tc'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index)</span><br><span class="line">]</span><br><span class="line"><span class="comment">#127.0.0.1:8000/aaa/bbb/</span></span><br></pre></td></tr></table></figure><blockquote><p>接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">app_name = <span class="string">"app"</span></span><br><span class="line">path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index, name=<span class="string">"threechr"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app:threechr"</span>,args=(<span class="string">'aaaa'</span>,<span class="string">'bbbb'</span>)))</span><br><span class="line"><span class="comment">#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位</span></span><br></pre></td></tr></table></figure><h5 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h5><blockquote><p>我们的路由编写都是在项目主要目录下的<code>urls.py</code>文件中，但是如果<code>app</code>有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情</p><p>其实在之前的练习中，我们使用的方式均是路由分发，每个子<code>app</code>都拥有自己独立的<code>urls.py</code>路由映射文件，而主控路由文件里只需要使用<code>include</code>函数导入子<code>app</code>下路由文件即可，这就是路由分发</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"urlapp.urls"</span>)) <span class="comment"># 使用include 实现路由分发，找到子app下的路由文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>路由分发为我们带来的好处有很多，可以让我们在多个<code>app</code>的项目中更加方便有效的管理每一个路由</p><p>并且也可以让我们的用户在访问时看到浏览器中的<code>URL</code>地址更加<strong>赏心悦目</strong></p></blockquote><h5 id="路由反向解析"><a href="#路由反向解析" class="headerlink" title="路由反向解析"></a>路由反向解析</h5><blockquote><p>到了这里，思考一下，之前我们已经设置过了很多路由；</p><p>但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把<code>aaa</code>换成了<code>aba</code>，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难</p></blockquote><blockquote><p><code>django</code>也为我们提供了一个解决办法，通过为路由映射使用<code>name</code>参数，来为每一个路由映射设置一个独立唯一的变量名</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'left/&lt;str:x&gt;/'</span>,views.left, name=<span class="string">"left"</span>),</span><br><span class="line">path(<span class="string">'right/&lt;int:x&gt;/'</span>,views.right, name=<span class="string">"right"</span>),</span><br><span class="line"><span class="comment"># 通过正则命名分组方式</span></span><br><span class="line">re_path(<span class="string">r'^left/([a-zA-Z]+)/$'</span>,views.left,name=<span class="string">"left"</span>),</span><br><span class="line">re_path(<span class="string">r'^right/(?P&lt;x&gt;\d+)/$'</span>,views.right, name=<span class="string">"right"</span>)</span><br></pre></td></tr></table></figure><ul><li>两个视图函数对应如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: str</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"left.html"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: int</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"right.html"</span>,content)</span><br></pre></td></tr></table></figure><ul><li>两个HTML页面</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;我是左页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'right' 123 %&#125;"&gt;右页面&lt;/a&gt;</span><br><span class="line">&lt;!-- ------另一个页面------ --&gt;</span><br><span class="line">&lt;p&gt;我是右页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'left' 'abc' %&#125;"&gt;右页面&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在模板页面中，对于已命名路由可以通过 &#123;% url “name” “arg” %&#125;模板标签进行反向解析</p><p>参数以空格隔开，在标签后传入</p></blockquote><ul><li>视图函数反向解析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">"left"</span>,args=(<span class="string">'aaa'</span>,) ))</span><br></pre></td></tr></table></figure><blockquote><p>在视图函数中需要使用到路由命名时，进行反向解析需要我们通过<code>django.shortcuts</code>模块下的<code>reverse</code>函数</p></blockquote><ul><li><code>reverse(viewname,args=None,kwargs=None)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数介绍</span><br><span class="line">viewname：视图函数、命名路由映射、或视图函数路径的字符串</span><br><span class="line">args：元组形式路由传参。</span><br><span class="line">kwargs：字典形式路由传参</span><br></pre></td></tr></table></figure><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><blockquote><p>如果想在多个<code>app</code>下使用相同的<code>name</code>路由命名，那么我们可以通过路由分发过程中的include函数来指定不同<code>app</code>所属的命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include((<span class="string">"app1.urls"</span>,<span class="string">'app1'</span>))),</span><br><span class="line">    <span class="comment">#直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间</span></span><br><span class="line">    path(<span class="string">'app2/'</span>,include((<span class="string">"app2.urls"</span>,<span class="string">'app2'</span>)))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当为每个<code>app</code>的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app1:left"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' %&#125;"</span>&gt;</span>app2:left<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="应用命名空间：app-name"><a href="#应用命名空间：app-name" class="headerlink" title="应用命名空间：app_name"></a>应用命名空间：app_name</h6><blockquote><p>使用<code>app_name</code>指明命名空间，在子<code>app</code>的<code>urls.py</code>文件下配置全局变量<code>app_name</code>，这个值是唯一的</p><p>在这个路由文件中定义的其他映射关系，将具有命名空间<code>app1</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app_name = <span class="string">"app1"</span> <span class="comment"># 这个值应该是唯一的</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">   ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h6 id="实例命名空间：namespace"><a href="#实例命名空间：namespace" class="headerlink" title="实例命名空间：namespace"></a>实例命名空间：namespace</h6><blockquote><p>当有多个子<code>app</code>同时引入同一个子路由映射文件，比如这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆，</p><p>此时需要给每一个路由分发的规则设置<code>namespace</code>属性，为实例进行命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app1"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app2"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这样做的好处，可以在不同路由导向同一<code>app</code>下时，为他们的不同命名空间；</p><p>虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作</p><p>接下来视图及模板页面中使用<code>namespace</code>的值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:right' 123 %&#125;"</span>&gt;</span>app1的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:left' 'abc' %&#125;"</span>&gt;</span>app1的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ----------------------------------------- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:right' 123 %&#125;"</span>&gt;</span>app2的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' 'abc' %&#125;"</span>&gt;</span>app2的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;路由层&quot;&gt;&lt;a href=&quot;#路由层&quot; class=&quot;headerlink&quot; title=&quot;路由层&quot;&gt;&lt;/a&gt;路由层&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;路由是Web服务的入口，就好像办事大厅有各个服务窗口一样&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://qzloo.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://qzloo.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Views-视图层</title>
    <link href="https://qzloo.cn/2005/01/03/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/"/>
    <id>https://qzloo.cn/2005/01/03/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/</id>
    <published>2005-01-03T09:51:53.000Z</published>
    <updated>2020-01-03T05:53:58.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><blockquote><p>视图函数一般用来接收一个<code>Web</code>请求<code>HttpRequest</code>，之后返回一个Web响应<code>HttpResponse</code></p></blockquote><a id="more"></a><h4 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h4><blockquote><p>一个视图函数用来响应用户的<code>Request</code>请求，每个视图函数默认的第一个位置参数<code>request</code>用来接收用户发起请求的<code>HttpRequest</code>信息。</p><p>视图函数的返回值，为一个<code>HttpResponse</code>值，包括我们要返回给用户的<code>HTML</code>页面或者字符串等等，以及对应的头部字段信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'Hello world'</span>)</span><br></pre></td></tr></table></figure><h4 id="常见请求方式"><a href="#常见请求方式" class="headerlink" title="常见请求方式"></a>常见请求方式</h4><blockquote><p><code>POST</code>和<code>GET</code>是<code>HTTP</code>协议定义的与服务器交互的方法。</p><p><code>GET</code>一般用于获取/查询资源信息，而<code>POST</code>一般用于更新资源信息。另外，还有<code>PUT</code>和<code>DELETE</code>方法</p></blockquote><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><blockquote><p>常用来从指定地址请求数据；</p><p>如果需要在请求时提交某些数据，则以路由形式传递参数，查询<code>Query</code>字符串如下格式所示：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?key=abc&amp;pos=hebei</span><br></pre></td></tr></table></figure><ul><li><code>get</code>请求可被浏览器缓存，保存在历史记录中</li><li><code>get</code>不应在使用敏感数据时使用，明文包路在请求地址中</li><li><code>get</code>有长度限制</li></ul><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><blockquote><p>向指定的资源提交要被处理的数据</p><p>使用<code>POST</code>，提交的数据保存在<code>HTTP</code>协议中的消息主体部分</p></blockquote><ul><li><code>post</code>请求不会被浏览器缓存</li><li><code>post</code>提交数据长度无限制</li><li><code>post</code>比<code>get</code>更加安全</li></ul><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><blockquote><p>如果说<code>urls.py</code>是<code>Django</code>中前端页面和后台程序桥梁，那么<code>request</code>就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于<code>requests</code>中</p></blockquote><h5 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h5><blockquote><p>获取当前用户请求方式，</p><p>请求方式字符串为纯大写：<code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code></p><p>如用户以<code>get</code>方式发起请求，对应代码中获取到的结果以及在判断时像是这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h5 id="request-GET"><a href="#request-GET" class="headerlink" title="request.GET"></a>request.GET</h5><blockquote><p>当用户通过<code>get</code>方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(request.GET) </span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt;</span></span><br><span class="line">    print(type(request.GET)) </span><br><span class="line">    <span class="comment"># &lt;class 'django.http.request.QueryDict'&gt;</span></span><br><span class="line">    name_ = request.GET.get(<span class="string">'name'</span>)</span><br><span class="line">    id_ = request.GET.get(<span class="string">'id'</span>)</span><br><span class="line">    content = <span class="string">'%s:%s'</span> % (name_,id_)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><p><code>request.GET</code>是一个类似字典的数据类型：<code>QueryDict</code></p><p>其中也支持类似对字典的<code>get</code>或直接<code>dict.[key]</code>键值访问方式，当然使用<code>get</code>方式进行对应<code>key</code>获取会更好，因为<code>get</code>在访问不到时不会报错</p></blockquote><ul><li>如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/?name=jack&amp;id=1</span><br></pre></td></tr></table></figure><ul><li>这里对应页面会显示的结果：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack:1</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：使用<code>GET</code>方法在连接中进行参数提交，后台接收到的数据类型均是字符串</p></blockquote><hr><h5 id="request-POST"><a href="#request-POST" class="headerlink" title="request.POST"></a>request.POST</h5><blockquote><p>获取用户以<code>post</code>形式提交的数据并保存在后台，为类字典数据，这里和<code>request.GET</code>是一个东西；</p><p>在网页中，一般我们通过<code>html</code>的表单进行数据的提交，<code>POST</code>方式可以提交空数据</p></blockquote><ul><li>因为涉及到了表单页面，所以我们先来弄一个<code>HTML</code>页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个关于POST的测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加<code>csrf_token</code>标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。</p></blockquote><blockquote><p>在接下来的视图函数中会使用到<code>input</code>标签中的<code>name</code>属性；</p><p><code>name</code>值属性维护了<code>post</code>的数据传入到后台时的标示，会与表单的数据组合成类字典格式</p><p>如<code>name</code>属性为<code>account</code>的输入框中输入了<code>test</code>，那么后台数据接收到的值类似：<code>{&#39;account&#39;:&#39;test&#39;}</code></p></blockquote><ul><li>写一个视图函数用来捕获当前表单使用POST形式提交的数据：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method=<span class="string">"POST"</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        print(type(request.POST))</span><br><span class="line">        account = request.POST.get(<span class="string">"account"</span>)</span><br><span class="line">        passwd = request.POST.get(<span class="string">"passwd"</span>)</span><br><span class="line">        content = <span class="string">"%s:%s"</span> % (account,passwd)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(content)</span><br><span class="line">   <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>) <span class="comment">#在使用get形式请求时，返回表单页面</span></span><br></pre></td></tr></table></figure><ul><li>如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2&apos;], &apos;account&apos;: [&apos;test&apos;], &apos;passwd&apos;: [&apos;123456&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure><h6 id="表单夺表提交"><a href="#表单夺表提交" class="headerlink" title="表单夺表提交"></a>表单夺表提交</h6><blockquote><p>在<code>request.POST</code>中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框<code>CheckBox</code>，直接使用<code>request.POST.get()</code>进行获取是有一些问题的，比如修改模板页`面如下所示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"eat"</span>&gt;</span>吃</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"sleep"</span>&gt;</span>睡</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"play"</span>&gt;</span>耍</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个<code>name</code>值为<code>taste</code>的兴趣爱好采集的多选框，<code>value</code>值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k&apos;], &apos;taste&apos;: [&apos;eat&apos;, &apos;sleep&apos;, &apos;play&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>但是问题接踵而至，我们发现使用<code>get</code>函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项</p></blockquote><ul><li><p><code>request.POST.get(key, default=None)</code></p><blockquote><p>返回对应<code>key</code>值的数据中的<strong>最后一个</strong>数据单独返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><blockquote><p>要想真正拿出所有的结果，应该使用<code>getlist</code>函数</p></blockquote><ul><li><p><code>request.POST.getlist(key, default=None)</code></p><blockquote><p>将对应<code>key</code>值的所有数据以<strong>一个列表</strong>形式返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><h5 id="request-META"><a href="#request-META" class="headerlink" title="request.META"></a>request.META</h5><blockquote><p><code>request.MAT</code>E获取的是一个标准的<code>python</code>字典。它包含了所有的<code>HTTP</code>请求信息</p><p>比如用户IP地址和用户<code>Agent</code>（通常是浏览器的名称和版本号）。</p><p>注意，<code>Header</code>信息的完整列表取决于用户所发送的<code>Header</code>信息和服务器端设置的<code>Header</code>信息</p></blockquote><ul><li><code>CONTENT_LENGTH</code>：请求的正文的长度，字符串类型</li><li><code>CONTENT_TYPE</code>：请求的正文的<code>MIME</code> 类型</li><li><code>HTTP_ACCEPT</code>：响应可接收的<code>Content-Type</code></li><li><code>HTTP_ACCEPT_ENCODING</code>：响应可接收的编码</li><li><code>HTTP_ACCEPT_LANGUAGE</code>：响应可接收的语言</li><li><code>HTTP_HOST</code>：客服端发送的<code>HTTP Host</code>头部</li><li><code>HTTP_REFERER</code>：请求前的连接地址</li><li><code>HTTP_USER_AGENT</code>：客户端的<code>user-agent</code>字符串</li><li><code>QUERY_STRING</code>：单个字符串形式的查询字符串（未解析过的形式）</li><li><code>REMOTE_ADDR</code>：客户端的IP 地址</li><li><code>REMOTE_HOST</code>：客户端的主机名</li><li><code>REMOTE_USER</code>：服务器认证后的用户</li><li><code>REQUEST_METHOD</code>：一个字符串，例如<code>GET</code> 或<code>POST</code></li><li><code>SERVER_NAME</code>：服务器的主机名</li><li><code>SE0RVER_PORT</code>：服务器的端口，字符串类型</li></ul><h5 id="request-FILES"><a href="#request-FILES" class="headerlink" title="request.FILES"></a>request.FILES</h5><blockquote><p>接收用户上传文件及相关信息。同样类似于<code>request.POST</code>，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息</p></blockquote><ul><li><p><code>f = request.FILES.get(&#39;upload_file&#39;)</code></p><blockquote><p><code>file_data = f.read()</code>：读取整个上传文件的内容，适合小文件上传</p><p><code>yiled = f.chunks()</code>：返回一个类似生成器<code>（&lt;class &#39;generator&#39;&gt;）</code>的数据，每一次读取按块返回文件，可以通过<code>for</code>迭代访问其中数据；适合上传大文件到服务器。</p><p><code>f.multiple_chunks()</code>：返回文件大小，当文件大小大于<code>2.5M</code>时，返回<code>True</code>，反之返回<code>False</code>，可以通过该函数来选择是否使用<code>chunks</code>方法或<code>read</code>直接存储。</p><p>如果想要修改这个文件判定的默认值，可以通过：<code>FILE_UPLOAD_MAX_MEMORY_SIZE</code>在<code>settings</code>文件下进行设置</p><p><code>f.content_type</code>：上传文件时头部中的<code>Content-Type</code>字段值，参考MIME类型</p><p><code>f.name</code>：上传文件名字</p><p><code>f.charset</code>：上传文件编码</p><p><code>f.size</code>： 上传文件大小，字节为单位：<code>byte</code></p></blockquote></li></ul><blockquote><p>创建好静态资源目录，并在下面创建一个<code>img</code>文件夹，保存我们即将上传的图片；</p><p>完成上传文件的<code>HTML</code>表单页面</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload_file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'img/1.jpg' %&#125;"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上传文件的页面表单，一定要记得设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p></blockquote><ul><li>视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        f = request.FILES.get(<span class="string">"upload_files"</span>)</span><br><span class="line">        path = os.path.join(settings.STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/'</span>+f.name)</span><br><span class="line">  <span class="comment"># 上传文件本地保存路径</span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">if</span> f.multiple_chunks: <span class="comment">#判断到上传文件为大于2.5MB的大文件</span></span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> f.chunks(): <span class="comment">#迭代写入文件</span></span><br><span class="line">                    fp.write(buf)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fp.write(f.read())</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"Success!"</span>)</span><br><span class="line">  <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>测试上传一个名为<code>1.jpg</code>的图片，如果成功上传，那么后台<code>static</code>目录下会出现该图片，并且模板页面也可以展示对应图片效果</p></blockquote><h4 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h4><blockquote><p>一个视图的返回值经常是为了向用户返回一个<code>HttpResponse</code>响应，</p><p>有如下常用的可以返回<code>HttpResponse</code>的函数</p></blockquote><h5 id="response"><a href="#response" class="headerlink" title="response"></a>response</h5><ul><li><p><code>HttpResponse(content=b&#39;&#39;)</code></p><blockquote><p>返回一个字符串内容</p><p><em>from</em> django.http <em>import</em> HttpResponse</p></blockquote></li><li><p><code>render(request,template_name,context=None,content_type=None,status=None)</code></p><blockquote><p>返回一个可渲染HTML页面，状态码为<code>200</code></p><p><em>from</em> django.shortcuts <em>import</em> render</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request`：固定参数，响应的`request`请求，来自于参数部分接收的`HttpRequest</span><br></pre></td></tr></table></figure><p><code>template_name</code>：返回的模板页面路径</p><p><code>context</code>：模板页面渲染所需的数据，默认为字典格式</p><p><code>content_type</code>：生成之后的结果使用的<code>MIME</code>类型</p><p><code>status</code>：响应的状态码，默认为<code>200</code></p></blockquote></li><li><p>redirect(to, permanent=False)</p><blockquote><p>一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码<code>302</code></p><p><em>from</em> django.shortcuts <em>import</em> redirect</p></blockquote><blockquote><p><code>to</code>：可以是一个<code>django</code>项目中视图函数的路由映射，也可以是一个<code>reverse</code>的反向路由解析</p><p><code>permanent</code>：如果设置为<code>True</code>，将返回<code>301</code>状态码，代表永久重定向</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">302</span>：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。</span><br><span class="line"><span class="number">301</span>：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址</span><br></pre></td></tr></table></figure></li></ul><h4 id="视图错误处理"><a href="#视图错误处理" class="headerlink" title="视图错误处理"></a>视图错误处理</h4><blockquote><p>为了方便我们开发，<code>django</code>提供了一个异常叫做<code>Http404</code>异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后<code>django</code>项目会自动捕获该异常，并会展示默认的<code>404</code>页面</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.GET.get(<span class="string">"id"</span>) == <span class="string">"1"</span>:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure><blockquote><p>在<code>settings</code>中的<code>debug</code>配置项为<code>false</code>时，访问<code>http://127.0.0.1:8000/?id=1</code>，可以看到<code>django</code>为我们提供的错误页面；</p><p>除了<code>django</code>默认提供的，我们还可以可以在模板目录下定义全局<code>404.html</code>进行错误页面的定制</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    抱歉，找不到你要的东西</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="自定义错误处理视图"><a href="#自定义错误处理视图" class="headerlink" title="自定义错误处理视图"></a>自定义错误处理视图</h5><blockquote><p>除去<code>404</code>错误的自定义，<code>django</code>还提供了覆盖默认错误行为处理的办法；</p><p>有些时候，<code>django</code>自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数，</p><p>来覆盖掉<code>django</code>所提供的错误处理视图函数，最后在<code>urls.py</code>路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handler404：覆盖page_not_found()视图。</span><br><span class="line">handler500：覆盖server_error()视图。</span><br><span class="line">handler403：覆盖permission_denied()视图。</span><br><span class="line">handler400：覆盖bad_request()视图。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">"viewapp.urls"</span>)),</span><br><span class="line">]</span><br><span class="line">handler404 = <span class="string">"viewapp.views.error_404"</span></span><br><span class="line"><span class="comment"># APP.模块.视图函数</span></span><br><span class="line">handler500 = <span class="string">"viewapp.views.error_500"</span></span><br></pre></td></tr></table></figure><blockquote><p>相关定义好的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是404错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_403</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是403错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_500</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是500错误"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;视图函数一般用来接收一个&lt;code&gt;Web&lt;/code&gt;请求&lt;code&gt;HttpRequest&lt;/code&gt;，之后返回一个Web响应&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://qzloo.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://qzloo.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django初识</title>
    <link href="https://qzloo.cn/2005/01/01/Django%E5%88%9D%E8%AF%86/"/>
    <id>https://qzloo.cn/2005/01/01/Django%E5%88%9D%E8%AF%86/</id>
    <published>2005-01-01T11:32:43.000Z</published>
    <updated>2020-01-03T05:54:05.216Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开始玩耍Django"><a href="#开始玩耍Django" class="headerlink" title="开始玩耍Django"></a>开始玩耍Django</h4><blockquote><p><em>Django</em>是一个开放源代码的<code>Web</code>应用框架，由<code>Python</code>写成。采用了<code>MVT</code>的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是<code>CMS</code>（内容管理系统）软件</p><p>框架是以比利时的吉普赛爵士吉他手<code>Django Reinhardt</code>来命名的</p></blockquote><a id="more"></a><h5 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h5><blockquote><p><code>pip install django==2.0.4</code>(版本号)</p><p><code>pip install django</code>默认安装最新版本</p></blockquote><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><blockquote><p><code>django-admin startproject myproject</code></p></blockquote><h5 id="开启开发服务器"><a href="#开启开发服务器" class="headerlink" title="开启开发服务器"></a>开启开发服务器</h5><blockquote><p><code>cd myproject</code>：进入项目目录</p><p><code>python manage.py runserver</code>：开启服务</p><p><code>python manage.py runserver 7000</code>：改变服务监听端口</p><p><code>python manage.py runserver 0:8000</code>：改变服务监听IP:端口</p></blockquote><h5 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">manage.py：用来管理当前项目的一个命令行工具</span><br><span class="line">myproject/： 项目主文件夹</span><br><span class="line">myproject/__init__.py：空文件，用来指明当前的myproject为一个可导入的模块包</span><br><span class="line">myproject/settings.py：项目主要配置文件</span><br><span class="line">myproject/urls.py：项目主要路由配置文件</span><br><span class="line">myproject/wsgi.py：项目部署WSGI并发服务器时所需要的配置文件</span><br></pre></td></tr></table></figure><h5 id="Settings-py"><a href="#Settings-py" class="headerlink" title="Settings.py"></a>Settings.py</h5><blockquote><p>该文件是整个项目的主控文件，其中相关配置选项如下</p><p><code>https://docs.djangoproject.com/zh-hans/2.1/ref/settings/</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径</span><br><span class="line">- SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥</span><br><span class="line">- DEBUG: 调试模式</span><br><span class="line">- ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。</span><br><span class="line">- INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！</span><br><span class="line">- MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等</span><br><span class="line">- SecurityMiddleware: xss脚本过滤，一些安全设置</span><br><span class="line">- SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器</span><br><span class="line">- CommonMiddleware: 通用组件，比如为路由添加末尾斜杠</span><br><span class="line">- CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值</span><br><span class="line">- AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性</span><br><span class="line">- MessageMiddleware: 消息中间件 展示一些后台消息给前端</span><br><span class="line">- XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗</span><br><span class="line">- ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径</span><br><span class="line">- TEMPLATES: 模板文件配置项</span><br><span class="line">- WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件</span><br><span class="line">- DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库</span><br><span class="line">- AUTH_PASSWORD_VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义</span><br><span class="line">- LANGUAGE_CODE: django所使用语言文件</span><br><span class="line">- TIME_ZONE: django所使用时区</span><br><span class="line">- USE_I18N: 国际化支持 <span class="number">18</span>表示Internationalization这个单词首字母I和结尾字母N之间的字母有<span class="number">18</span>个</span><br><span class="line">- USE_L10N: 是localization的缩写形式，意即在l和n之间有<span class="number">10</span>个字母</span><br><span class="line">- USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括<span class="keyword">print</span>显示的时间将是是UTC时间格式</span><br><span class="line">- STATIC_URL: URL访问静态资源时的路径</span><br></pre></td></tr></table></figure><h4 id="来搞个Hello-World"><a href="#来搞个Hello-World" class="headerlink" title="来搞个Hello World"></a>来搞个Hello World</h4><h5 id="django创建子应用"><a href="#django创建子应用" class="headerlink" title="django创建子应用"></a>django创建子应用</h5><blockquote><p>项目和应用有啥区别？</p><p>应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序</p><p>项目则是一个网站使用的配置和应用的集合。项目可以包含很多个<code>app</code>应用，应用可以被很多个项目使用</p></blockquote><ul><li><p><code>python manage.py startapp myapp</code></p><blockquote><p>创建子应用</p></blockquote></li></ul><h5 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- admin.py: app在admin注册展示时需要的文件</span><br><span class="line">- views.py: app的功能视图函数文件</span><br><span class="line">- models.py: app需要使用数据库时的文件</span><br><span class="line">- urls.py: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的</span><br></pre></td></tr></table></figure><h5 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h5><blockquote><p>打开<code>app</code>下的<code>views.py</code>文件</p><p><code>Web</code>访问起始就是通过一个<code>URL</code>连接地址访问到服务器上的一个函数</p><p>在<code>views.py</code>中我们通过编写函数的形式，接收用户请求的<code>request</code>并返回一个<code>response</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每一个视图函数都需要有一个必须参数 request,用来接收用户访问时的请求内容</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello world&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>HttpResponse</code>函数用来向用户返回一个字符串</li></ul><h5 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h5><blockquote><p>创建好了一个可以在请求时返回<code>H1</code>标签的视图函数，但是现在通过浏览器还是访问不到</p><p>需要我们为这个<code>app</code>下的函数进行路由配置</p></blockquote><blockquote><p>第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls), <span class="comment">#admin控制界面路由</span></span><br><span class="line">    path(<span class="string">''</span>,views.index) </span><br><span class="line">    <span class="comment">#path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时</span></span><br><span class="line">    <span class="comment">#第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来访问<code>127.0.0.1:8000</code>，那么你会看到一个非常大的<code>Hello world</code></li></ul><blockquote><p>以上将视图函数的查找直接写到主控路由并不是最好的办法</p><p>我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护</p></blockquote><ul><li>我们可以在对应<code>app</code>下创建一个子路由控制文件，并在其中设置视图的路由配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">""</span>,views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>现在虽然配置了<code>app</code>下的路由文件，但是访问时，是看不到对应视图的结果</p><p>这是因为默认的<code>url</code>查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置</p><p>让主控路由可以找到子<code>app</code>下的路由映射文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    <span class="comment">#path('',views.index)</span></span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"myapp.urls"</span>)),</span><br><span class="line">    <span class="comment"># 函数 include() 允许引用其它 URLconfs</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！</li></ul><h6 id="路由查找流程"><a href="#路由查找流程" class="headerlink" title="路由查找流程"></a>路由查找流程</h6><ol><li>查找主控路由文件下的<code>urlpatterns</code>全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则</li><li>如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数</li><li>如果对应的不是一个执行函数，而是一个<code>include</code>路由包含，那么截断与此项匹配的<code>URL</code>的部分，并将剩余的路由字符串发送到<code>include</code>所包含的子路由文件中以供进一步处理</li><li>如果没有匹配到的任何结果，<code>django</code>默认抛出<code>Page not found (404)</code></li></ol><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑HTTP请求方式，仅根据<code>URL</code>进行路由，即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><blockquote><p><code>path</code>函数用来处理一个路由对应的视图映射</p></blockquote><ul><li><p><code>path(route, view, name)</code></p><blockquote><p><code>route</code>： 匹配规则，是一个字符串</p><p><code>view</code>：对应的视图函数</p><p><code>name</code>：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用</p></blockquote></li></ul><h6 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h6><blockquote><p><code>re_path</code>是<code>path</code>函数的加强版</p><p>可以在<code>re_path</code>函数的第一个位置的字符串参数，是一个标准<code>Python</code>正则表达式，其余参数与<code>path</code>相同</p></blockquote><blockquote><p><strong>注意</strong>：匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个<code>url</code>都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的<code>/</code></p></blockquote><h5 id="模板页面"><a href="#模板页面" class="headerlink" title="模板页面"></a>模板页面</h5><blockquote><p>返回一个字符串这肯定是不行的，太<code>low</code>了，也不好看，现在来返回一个正式的<code>HTML</code>页面</p><p>并在<code>HTML</code>页面中加入模板变量，由视图函数动态传递值；</p></blockquote><ul><li>配置<code>django</code>中模板页面的保存路径，在项目目录下的<code>settings.py</code>文件中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'template'</span>)], <span class="comment"># 就是这一行 设置静态模板路径</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>创建template</code>目录并在其中创建<code>index.html</code>文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>HTML</code>页面中，我们并没有明确指出<code>H1</code>标签的内容；通过一个``来等待接收视图函数传来的数据，在<code>HTML</code>页面中这样的变量也叫做<strong>模板变量</strong>，双大括号为使用语法</p></blockquote><ul><li>接下来修改之前的视图函数，由视图函数传递变量给到<code>HTML</code>页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#return HttpResponse("&lt;h1&gt;Hello world&lt;/h1&gt;")</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"message"</span>:<span class="string">"你好，世界"</span> <span class="comment">#此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,content)</span><br></pre></td></tr></table></figure><h6 id="render"><a href="#render" class="headerlink" title="render"></a>render</h6><blockquote><p>render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染</p></blockquote><ul><li><p><code>render(request, template_name, context=None)</code></p><blockquote><p>返回一个HTTP响应</p></blockquote><blockquote><p><code>request</code>： 固定接收<code>request</code>请求</p><p><code>template_name</code>： 为一个可以找到的模板页面</p><p><code>context</code>： 模板页面所需模板变量</p></blockquote></li></ul><h6 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h6><blockquote><p>在<code>django</code>中的<code>HTML</code>页面，不光可以编写原本的标签等内容，还可以像<code>Vue</code>一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到<code>HTML</code>模板页面中</p></blockquote><blockquote><p>模板变量可以由后台视图函数构建一个<strong>字典数据类型</strong>传递，</p><p>字典的<code>key</code>是模板变量名，<code>value</code>值该模板变量对应的数据</p><p>当然，模板变量的内容远不止此，还会再后面继续为大家叙述</p></blockquote><h5 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h5><blockquote><p>虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋</p><p>我们还要继续引入一些类似<code>css、img</code>这样的静态资源，来装饰我们的页面</p><p>在<code>django</code>中模板页面的静态资源使用，不能像之前写<code>HTML</code>代码直接引入</p><p>需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为<code>static</code></p></blockquote><ul><li>在settings中配置静态文件保存目录，<strong>添加</strong>如下内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录</span></span><br></pre></td></tr></table></figure><ul><li>在项目中创建<code>static</code>目录，<code>static</code>目录下创建专门保存图片的<code>img</code>目录，在里面存一张图片<code>1.jpg</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时的目录结构</span></span><br><span class="line">myproject/</span><br><span class="line">myproject/</span><br><span class="line">myapp/</span><br><span class="line">template/</span><br><span class="line">static/</span><br><span class="line">img/</span><br><span class="line"><span class="number">1.j</span>pg</span><br></pre></td></tr></table></figure><ul><li>有了图片，接下来在模板页面中去引入并使用它，打开<code>index.html</code>进行修</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;% static "img/1.jpg" %&#125;'</span> <span class="attr">alt</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里用到了一个特殊语法：&#123;% tag %&#125;这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的&#123;% if %&#125;，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能</p></blockquote><blockquote><p>在页面中要引入静态资源：图片，<code>CSS</code>，<code>JS</code>文件在引入时都需要通过&#123;% static “path” %&#125;来进行引入</p></blockquote><blockquote><p>最后，需要使用静态标签<code>static</code>前使用&#123;% load staticfiles %&#125;标签进行静态资源路径的加载</p></blockquote><h5 id="模型数据库"><a href="#模型数据库" class="headerlink" title="模型数据库"></a>模型数据库</h5><blockquote><p>有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据</p></blockquote><ul><li>创建数据库，这里使用项目自带的<code>SQLite3</code>数据库，默认已经是配置好的，接下来需要我们进入到<code>app</code>下的<code>models.py</code>文件中，编写一个类，这个类就对应数据库中的一张表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    weather = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">"天气"</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name_plural = <span class="string">"天气"</span></span><br><span class="line">        <span class="comment"># 设置当前表名的一个可读的性更好的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weather</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们使用到了<code>django</code>的<code>orm</code>映射关系用来创建数据库表，继承自<code>django</code>的<code>models.Model</code>类，</p><p><strong>一个类用来表示一张表，类中的一个属性代表一个字段，</strong></p></blockquote><blockquote><p>这里我们定义了一个类型为<code>CharField</code>，长度为<code>100</code>的字段，用来存储天气</p><p><code>models.CharField(max_length=100,verbose_name=&quot;天气&quot;)</code></p></blockquote><hr><blockquote><p>下面的<code>class Meta</code>是模型类的元类，用来设置当前表的一些属性；</p><p>这里我们使用<code>verbose_name_plural</code>属性设置当前表在<code>admin</code>后台查看时的名字</p></blockquote><blockquote><p>在这里我们还定义了一个属于实例的函数<code>__str__</code>，用来描述当前数据在返回时的默认展示结果，为<code>weather</code>字段的值</p></blockquote><blockquote><p><code>django</code>在创建模型类对应的数据表时，默认使用 <code>应用名</code>加<code>下划线</code>加<code>模型类名</code>作为表的名字；比如当前<code>Weather</code>表名为：<code>myapp_Weather</code></p></blockquote><blockquote><p><code>orm</code>映射关系，是<code>django</code>与数据库之间的一个桥梁，可以使开发者不再关注如何去编写<code>SQL</code>语句，直接通过一套<code>ORM</code>所提供的<code>API</code>接口即可方便对各种数据库进行交互</p></blockquote><ul><li>当某个子应用<code>APP</code>涉及到了数据库的使用时，要记得在<code>settings</code>文件中进行配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来通过<code>manage.py</code>命令行管理工具提供的两条，创建我们所需要的数据</li></ul><blockquote><p><strong>注意</strong>：默认<code>django</code>本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的</p></blockquote><blockquote><p><code>python manage.py migrate</code>：根据数据库迁移文件生成对应<code>SQL</code>语句并执行</p><p>初次执行是为了先把默认django需要的数据库创建出来</p></blockquote><blockquote><p><code>python manage.py makemigrations</code>：创建数据库迁移文件</p><p>这次执行是为了创建APP中Weather模型类的迁移文件</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>将新添加的模型类迁移文件生成对应<code>SQL</code>，实际创建出对应的<code>Weather</code>表</p></blockquote><ul><li>如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到<code>django</code>为我们提供的<code>admin</code>（数据库管理界面）来进行相关表的操作了！</li></ul><h5 id="admin控制台"><a href="#admin控制台" class="headerlink" title="admin控制台"></a>admin控制台</h5><blockquote><p><code>admin</code>控制台是<code>django</code>为我们提供的一个非常便捷的用来管理数据库的界面</p><p>在主控路由文件下，其实你已经看到了它对应的路由设置：<code>path(&#39;admin/&#39;, admin.site.urls),</code></p></blockquote><blockquote><p>进入<code>admin</code>界面，初次访问连接：<code>127.0.0.1/admin</code>，会提示我们输入账号密码，这是因为<code>django</code>的<code>admin</code>界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的<code>admin</code>界面下的超级用户</p></blockquote><ul><li>创建<code>admin</code>超级用户，使用<code>manage.py</code>命令行工具执行如下命令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Username (leave blank to use <span class="string">'lienze'</span>): root</span><br><span class="line">Email address:</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too short. It must contain at least <span class="number">8</span> characters.</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure><blockquote><p>以上是我们创建超级用户的过程，非常坎坷；</p><p>可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的</p><p>所以我们把用户账号创建为<code>root</code>，而密码创建为<code>a1234567</code>，</p></blockquote><ul><li>接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的<code>admin</code>界面啦</li></ul><blockquote><p><code>admin</code>界面已经展示出了默认<code>django</code>所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的<code>root</code>。</p></blockquote><h5 id="admin注册表"><a href="#admin注册表" class="headerlink" title="admin注册表"></a>admin注册表</h5><blockquote><p>问题还是有的，虽然<code>admin</code>界面已经可以登入，但是为什么看不到刚才创建的<code>Weather</code>表呢</p><p>这是因为默认的表创建之后，还需要通过对应app下的<code>admin.py</code>文件进行<code>admin</code>后台注册，只有注册在这个文件中的模型类对应的表才可以在<code>admin</code>界面所看到</p></blockquote><ul><li>在app下的admin.py文件中进行模型类的注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">admin.site.register(models.Weather)</span><br><span class="line"><span class="comment">#使用register函数接收模型类作为参数即可完成注册</span></span><br></pre></td></tr></table></figure><blockquote><p>注册成功之后，在服务器，通过浏览器访问<code>admin</code>界面，就可以看到创建好的<code>Weather</code>表了</p></blockquote><ul><li>鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阴天，晴天，打雷了</span><br></pre></td></tr></table></figure><h5 id="视图操作模型"><a href="#视图操作模型" class="headerlink" title="视图操作模型"></a>视图操作模型</h5><blockquote><p>最终我们希望可以在视图函数中通过<code>orm</code>接口来访问到表中的数据，那么来打开视图文件吧：<code>views.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    </span><br><span class="line">    weathers = models.Weather.objects.all()</span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"weathers"</span>:weathers,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, content)</span><br></pre></td></tr></table></figure><ul><li>光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的<code>HTML</code>页面哦：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for weather in weathers %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; weather &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有任何天气<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>模板标签&#123;% for xxx in xxxs %&#125;可以用来在模板页面出迭代访问取出每一个数据</p><p>具体对于不同序列数据的访问我们会在后面详细为大家介绍</p><p>&#123;% empty %&#125;标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有&#123;% endfor %&#125;标签进行结束；因为<code>HTML</code>中并没有像<code>Python</code>缩进这样的方式来控制代码块。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>至此，我们的<code>HELLO WORLD</code>项目已经涵盖了<code>django</code>框架中的大部分常用的组件；</p><p><strong>路由</strong>、<strong>视图</strong>、<strong>模板</strong>、<strong>静态</strong>、<strong>模型</strong>，<strong>admin</strong></p><p>那么其中每一部分都还有很多内容等着我们去了解！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始玩耍Django&quot;&gt;&lt;a href=&quot;#开始玩耍Django&quot; class=&quot;headerlink&quot; title=&quot;开始玩耍Django&quot;&gt;&lt;/a&gt;开始玩耍Django&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Django&lt;/em&gt;是一个开放源代码的&lt;code&gt;Web&lt;/code&gt;应用框架，由&lt;code&gt;Python&lt;/code&gt;写成。采用了&lt;code&gt;MVT&lt;/code&gt;的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是&lt;code&gt;CMS&lt;/code&gt;（内容管理系统）软件&lt;/p&gt;
&lt;p&gt;框架是以比利时的吉普赛爵士吉他手&lt;code&gt;Django Reinhardt&lt;/code&gt;来命名的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://qzloo.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://qzloo.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Python代码</title>
    <link href="https://qzloo.cn/2000/01/01/Python/"/>
    <id>https://qzloo.cn/2000/01/01/Python/</id>
    <published>2000-01-01T11:32:43.000Z</published>
    <updated>2020-01-03T05:55:03.136Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(blist)</span>:</span></span><br><span class="line">    count = len(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] = blist[j], blist[i]</span><br><span class="line">    <span class="keyword">return</span> blist</span><br><span class="line"></span><br><span class="line">blist = bubble_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">print(blist)</span><br></pre></td></tr></table></figure><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><blockquote><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(nlog₂n)</p><p>稳定性：不稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]    <span class="comment">#找到一个基准值</span></span><br><span class="line">        <span class="comment">#遍历整个列表，将小于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#遍历整个列表，将大于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line">        <span class="comment">#首先，明确我们对元素为0个/1个的列表无需要排序</span></span><br><span class="line">        <span class="comment">#使用函数递归</span></span><br><span class="line">        <span class="comment">#目标：让我们在一个基准值的一侧变为有序，然后依次返回，让我们的每个基准值的两侧都变得有序</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less)+[pivot]+quicksort(greater)</span><br><span class="line"><span class="comment">#这是一些测试样例</span></span><br><span class="line">print(quicksort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">11</span>]))</span><br><span class="line">print(quicksort([<span class="number">152</span>,<span class="number">134</span>,<span class="number">38796</span>,<span class="number">7438415</span>,<span class="number">1</span>,<span class="number">2272</span>,<span class="number">34345</span>,<span class="number">24</span>,<span class="number">127</span>]))</span><br></pre></td></tr></table></figure><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><blockquote><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p>优点：对唯一实例的受控访问，相当于全局变量，但是又可以防止变量被篡改</p><p>通过<strong>new</strong>方法，将类的实例在创建的时候绑定到类属性_inst上。如果cls._inst为None，说明类还未实例化，实例化并将实例绑定到cls._inst，以后每次实例化的时候都返回第一次实例化创建的实例。注意从Singleton派生子类的时候，不要重载<strong>new</strong>。</p><p>因为类每一次实例化后产生的过程都是通过<strong>new</strong>来控制的，所以通过重载<strong>new</strong>方法，我们 可以很简单的实现单例模式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) , id(single2))</span><br></pre></td></tr></table></figure><blockquote><p><strong>new</strong>方法</p><p>使用类名()创建对象时，Python的解释器首先会调用<strong>new</strong>方法为对象分配空间</p><p><strong>new</strong>是一个有object基类提供的内置的静态方法，主要作用有两个：</p><p>1）在内存中为对象分配空间</p><p>2）返回对象的引用</p><p>Python的解释器获得对象的引用后，将引用作为第一个参数，传递给<strong>init</strong>方法。</p><p><strong>重写<strong>new</strong>方法的代码非常固定</strong></p><ul><li>重写<strong>new</strong>方法一定要return super.<strong>new</strong>(cls)</li><li>否则Python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li><li>注意：<strong>new</strong>是一个静态方法，在调用时需要主动传递参数cls</li><li><strong>new</strong>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供</li></ul></blockquote><h4 id="递归斐波那契书列"><a href="#递归斐波那契书列" class="headerlink" title="递归斐波那契书列"></a>递归斐波那契书列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fun(i<span class="number">-2</span>) + fei(i<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(fun(i),end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><h4 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">        i = os.path.join(p,i)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(i):</span><br><span class="line">            <span class="keyword">return</span> fun(i)</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(i)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">                <span class="keyword">print</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> fun(i)</span><br><span class="line">path = unicode(<span class="string">r'F:\My Study\linux学习笔记\test'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">f(path)</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote><p>闭包的定义：</p><p>在一个外函数中定义了一个内函数</p><p>内函数里运用了外函数的临时变量</p><p>并且外函数的返回值是内函数的引用。</p><p>这样就构成了一个闭包。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        b = a + <span class="number">10</span></span><br><span class="line">        print(<span class="string">"b ="</span>,b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">outer()()</span><br></pre></td></tr></table></figure><h4 id="装饰器测试程序运行时间"><a href="#装饰器测试程序运行时间" class="headerlink" title="装饰器测试程序运行时间"></a>装饰器测试程序运行时间</h4><blockquote><p>使用装饰器测试（1000以内的三个数，相加等于1000的情况，有多少组）这个案例的运行时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        s_time = time.time() <span class="comment">#获取程序运行的开始时间</span></span><br><span class="line">        fun()    <span class="comment">#运行程序</span></span><br><span class="line">        e_time = time.time() <span class="comment">#获取程序运行的结束时间</span></span><br><span class="line">        <span class="keyword">return</span> e_time-s_time</span><br><span class="line">    <span class="keyword">return</span> inner   </span><br><span class="line"></span><br><span class="line"><span class="meta">@time_</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">            c = <span class="number">1000</span> - a - b</span><br><span class="line">            <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == c ** <span class="number">2</span>:</span><br><span class="line">                print(<span class="string">"a = %d , b = %d , c = %d"</span> % (a,b,c)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(func())</span><br></pre></td></tr></table></figure><h4 id="python树-实现先中后遍历和层次遍历"><a href="#python树-实现先中后遍历和层次遍历" class="headerlink" title="python树,实现先中后遍历和层次遍历"></a>python树,实现先中后遍历和层次遍历</h4><blockquote><p>广度遍历：层次遍历</p><p>深度遍历：先、中、后序遍历</p><p>层次遍历：一层一层的遍历</p><p>先序遍历：依据 <strong>根–左–右</strong> 的顺序遍历</p><p>中序遍历：依据 <strong>左–根–右</strong> 的顺序遍历</p><p>后序遍历：依据 <strong>左–右–根</strong> 的顺序遍历</p><p>遍历这棵树：</p></blockquote><p><img src="/2000/01/01/Python/shu.jpg" alt="树"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''树的节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span>  <span class="comment">#左孩子</span></span><br><span class="line">        self.rchild = <span class="literal">None</span>  <span class="comment">#右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span>    <span class="comment"># 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''添加的方法'''</span></span><br><span class="line">        node = Node(item)   <span class="comment"># 先构造一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment">#     如果是空树 直接添加元素</span></span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]  <span class="comment"># 一个队列 用来存放的就是要遍历和处理的元素</span></span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment">#队列只要不为空 就始终能拿出节点进行判断</span></span><br><span class="line">            <span class="comment"># 先从队列中取出一个节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 看当前这个节点左边的孩子是否为空 如果是空 直接挂节点</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不为空则认定左孩子存在 追加到队列</span></span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 查看节点右孩子 与左孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breadth_trvael</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''层次遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment"># 只要队列不为空就一直取元素</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem,end=<span class="string">' '</span>)</span><br><span class="line">            <span class="comment"># 如果左孩子存在 添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 右孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, node)</span>:</span>   <span class="comment">#传一个根节点</span></span><br><span class="line">        <span class="string">'''先序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:    <span class="comment">#递归的终结条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem,end=<span class="string">' '</span>)    <span class="comment">#先打印根</span></span><br><span class="line">        self.preorder(node.lchild)  <span class="comment">#处理左半部分</span></span><br><span class="line">        self.preorder(node.rchild)  <span class="comment">#处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''中序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment">#输出根</span></span><br><span class="line">        self.inorder(node.rchild)  <span class="comment">#再处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''后序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        self.postorder(node.rchild)  <span class="comment"># 然后处理右半部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment"># 最后输出根</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tree = Tree()</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    tree.add(<span class="number">0</span>)</span><br><span class="line">    tree.add(<span class="number">1</span>)</span><br><span class="line">    tree.add(<span class="number">2</span>)</span><br><span class="line">    tree.add(<span class="number">3</span>)</span><br><span class="line">    tree.add(<span class="number">4</span>)</span><br><span class="line">    tree.add(<span class="number">5</span>)</span><br><span class="line">    tree.add(<span class="number">6</span>)</span><br><span class="line">    tree.add(<span class="number">7</span>)</span><br><span class="line">    tree.add(<span class="number">8</span>)</span><br><span class="line">    tree.add(<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'层次遍历：'</span>)</span><br><span class="line">    tree.breadth_trvael()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'先序遍历：'</span>)</span><br><span class="line">    tree.preorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'中序遍历：'</span>)</span><br><span class="line">    tree.inorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'后序遍历：'</span>)</span><br><span class="line">    tree.postorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span>    <span class="comment">#如果头节点为空 列表就为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        cur = self.head <span class="comment">#cur游标 用来移动遍历节点</span></span><br><span class="line">        count = <span class="number">0</span>        <span class="comment">#记录数量</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next    <span class="comment">#移动游标</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历整个链表'''</span></span><br><span class="line">        cur = self.head <span class="comment">#代表第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''在链表头部添加元素，头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.head   <span class="comment"># 新元素的下一个节点指向链表第一个元素</span></span><br><span class="line">        self.head = node    <span class="comment">#头节点指向新元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''向链表的尾部添加元素,尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment">#如果链表为空</span></span><br><span class="line">            self.head = node    <span class="comment">#头节点指向添加的元素</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#不为空</span></span><br><span class="line">            cur = self.head     <span class="comment"># 游标</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>: <span class="comment"># 游标下一个位置不为空开始进入循环 为空则不进入循环</span></span><br><span class="line">                cur = cur.next  <span class="comment"># 游标移动</span></span><br><span class="line">            cur.next = node <span class="comment">#当游标下一位置为空时添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span>    <span class="comment"># 传入一个插入位置pos 一个插入元素item</span></span><br><span class="line">        <span class="string">'''指定位置添加元素'''</span></span><br><span class="line">        <span class="comment"># 如果添加位置在头部 直接使用头插入方法</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span> :</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):   <span class="comment">#插入位置超出列表范围 使用尾插法</span></span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 当循环退出后cur指向 pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''删除元素,根据具体的数据删除'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span>    <span class="comment"># 前一位置</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断子节点是否为头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = cur.next <span class="comment"># 直接改变头指针指向的地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next <span class="comment"># 如果删除尾部 cur.next刚好指向none</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:  <span class="comment"># 列表不为空时</span></span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    ll.append(<span class="number">2</span>)    <span class="comment">#尾部添加</span></span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)   <span class="comment">#头部添加</span></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'开始遍历链表元素：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="comment"># 删除一个元素</span></span><br><span class="line">    ll.remove(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'删除后遍历：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">9</span>))</span><br></pre></td></tr></table></figure><h4 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h4><blockquote><p>栈和队列是两种基本的数据结构，同为容器类型。两者根本的区别在于： </p><p><strong>栈stack:</strong>后进先出</p></blockquote><p><img src="/2000/01/01/Python/zhan.jpg" alt="栈"></p><blockquote><p><strong>队列queue:</strong>先进先出</p></blockquote><p><img src="/2000/01/01/Python/duilie.jpg" alt="队列"></p><blockquote><p><strong>栈的构造</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Stack() 创建一个新的空栈</span></span><br><span class="line"><span class="string">push(item) 添加一个新的元素item到栈顶</span></span><br><span class="line"><span class="string">pop() 弹出栈顶元素</span></span><br><span class="line"><span class="string">peek() 返回栈顶元素</span></span><br><span class="line"><span class="string">is_empty() 判断栈是否为空</span></span><br><span class="line"><span class="string">size() 返回栈的元素个数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""栈类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空栈"""</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""添加一个新的元素到栈顶"""</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断栈是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈元素的个数"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">6</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    print(s.stack)</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br></pre></td></tr></table></figure><blockquote><p><strong>队列的构造</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Queue() 创建一个空的队列</span></span><br><span class="line"><span class="string">enqueue(item) 往队列中添加一个item元素</span></span><br><span class="line"><span class="string">dequeue() 从队列头部删除一个元素</span></span><br><span class="line"><span class="string">is_empty() 判断一个队列是否为空</span></span><br><span class="line"><span class="string">size() 返回队列的大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空队列"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素"""</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ie_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断一个队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    q.enqueue(<span class="number">6</span>)</span><br><span class="line">    q.enqueue(<span class="number">7</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。&lt;/p&gt;
&lt;p&gt;时间复杂度：O(n²)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;p&gt;稳定性：稳定&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://qzloo.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="https://qzloo.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>nginx(4)：Nginx模块、配置指令、块之间的关系</title>
    <link href="https://qzloo.cn/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://qzloo.cn/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>1995-01-07T06:41:01.000Z</published>
    <updated>2020-01-03T10:10:05.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><blockquote><p>通过前文我们已经了解到，安装<code>nginx</code>以后，<code>nginx</code>会提供一个默认<code>server</code>，我们可以从<code>nginx.conf</code>文件中找到这个默认<code>server</code>的相关配置，如下</p></blockquote><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前文中已经解释过上述配置的大致含义，而且我们知道，一个<code>http</code>块中可以配置多个<code>server</code>块，一个<code>server</code>块中可以配置多个<code>location</code>，那么此处，我们就来多配置几个<code>location</code>试试，我已经配置好了一个用于演示的示例，如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       81;</span><br><span class="line">      server_name  localhost;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          root   html;</span><br><span class="line">          index  index.html index.htm;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">location /demo&#123;</span><br><span class="line">   root /opt;</span><br><span class="line">   index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      error_page   500 502 503 504  /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">          root   html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如你所见，我在默认配置之上，添加了一个<code>location</code>块，这个<code>location</code>对应的<code>url</code>为’<code>/demo</code>‘，此<code>location</code>块中的’<code>root /opt;</code>‘配置指令表示这个<code>location</code>的文档根目录为’<code>/opt</code>‘目录，所以，当我们在浏览器中访问’<code>/demo/a.jpg</code>‘这个<code>url</code>时，访问的其实是服务器中的’<code>/opt/demo/a.jpg</code>‘文件，如果你不明白为什么<code>url</code>与服务器路径存在这种对应关系，不用担心，我们会在之后的文章中总结<code>root</code>指令和<code>location</code>块之间的具体关系以及它们的用法，此处我们先不用纠结这些，我们先把关注的重点放在别的地方，为了方便示例，我已经在服务器上创建了<code>/opt/demo/</code>目录，并且在此目录中创建了一个名为<code>index.html</code>的文件，<code>index.html</code>内容如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/demo/index.html</span></span><br><span class="line">www.qzloo.cn</span><br></pre></td></tr></table></figure><blockquote><p>由于我在完成上述配置之前已经启动了<code>nginx</code>，所以此处执行’<code>nginx -s reload</code>‘命令重载配置，以便在不停止<code>nginx</code>服务的情况下使新的配置能够立即生效，重载配置以后，在浏览器中访问链接地址’<code>http://116.62.188.230:81/demo/</code>‘，效果如下</p></blockquote><p><img src="/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/4-1.jpg" alt="4-1"></p><blockquote><p>如你所见，我们自定义的<code>location</code>已经生效了，当我们访问’<code>http://116.62.188.230:81/demo/</code>‘这个<code>url</code>时，即可访问到服务器的’<code>/opt/demo/index.html</code>‘文件，通过上述示例，你应该已经明白了，在同一个<code>web</code>服务中，我们可以将不同的<code>url</code>对应到不同的服务器路径中，上例中，除了默认的<code>location</code>，我们又手动配置了一个新的<code>location</code>，默认的<code>location</code>为’<code>/</code>‘，我们手动配置的新的<code>location</code>为’<code>/demo</code>‘，所以，访问这两个<code>url</code>时，会分别对应的不同的文档根目录，从不同的目录中查找对应的资源，又因为<code>index</code>配置指令的原因，会默认访问对应目录中的<code>index.html</code>文件或<code>index.htm</code>文件，所以最终效果就像你刚才看到的那样</p><p>那么你一定发现了，默认的<code>location</code>和我们新加入的<code>location</code>中，<code>index</code>配置指令的值是完全相同的，那么，我们能不能把<code>index</code>配置项提取出来呢？是可以的，由于这两个<code>location</code>的<code>index</code>配置完全相同，所以，我们可以把这个<code>index</code>配置项提取到上一级的<code>server</code>块中，以便这两个<code>location</code>共享这个<code>index</code>配置，配置如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       81;</span><br><span class="line">      server_name  localhost;</span><br><span class="line"></span><br><span class="line">index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          root   html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">location /demo&#123;</span><br><span class="line">    root   /opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      error_page   500 502 503 504  /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">          root   html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么你一定也看明白了，由于两个<code>location</code>块中的<code>index</code>配置项完全相同，所以我们将<code>index</code>配置指令提取到了这两个<code>location</code>块的上一级<code>server</code>块中，以便两个<code>location</code>块能够共享这个<code>index</code>配置，换句话说就是，<code>server</code>块中的<code>index</code>指令是对当前<code>server</code>块中的所有<code>location</code>生效的，当然，如果某个<code>location</code>块中有自己的<code>index</code>配置，那么针对当前<code>location</code>块来说，还是以自己的<code>index</code>配置为准，比如如下配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       81;</span><br><span class="line">      server_name  localhost;</span><br><span class="line"></span><br><span class="line">index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          root   html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">location /demo&#123;</span><br><span class="line">   root   /opt;</span><br><span class="line">   index  a.jpg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      error_page   500 502 503 504  /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">          root   html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述配置中，<code>server</code>块中<code>index</code>配置是对当前<code>server</code>块中的所有<code>location</code>块生效的，但是由于’<code>location /demo</code>‘中有自己的<code>index</code>配置，那么针对’<code>location /demo</code>‘来说，自己的<code>index</code>配置的优先级更高，自己的<code>index</code>配置会覆盖上一级的<code>index</code>配置，所以，当我们访问’<code>/demo</code>‘这个<code>url</code>时，默认会在对应的目录中查找<code>a.jpg</code>这个文件，而不是<code>index.html</code>文件，但是另外一个<code>location</code>中由于没有配置<code>index</code>指令，所以它仍然会以上一级<code>server</code>块中的<code>index</code>配置为准</p><p>通过上述示例，你肯定明白了一个道理，同一个配置指令，配置在不同的块中时，对应的’作用域’是不同的</p><p>还记得我们在之前的文章中总结过如下这段话吗</p><p>某些配置指令只能在<code>http</code>块中配置，某些配置指令只能在<code>location</code>块中配置，有些配置指令既能在<code>server</code>块中配置又能在<code>http</code>块中配置，而有些配置指令只能在<code>main</code>区中进行配置</p><p>其实，刚才示例中的<code>index</code>指令就属于那种既能在<code>location</code>块中配置，又能在<code>server</code>块中配置，还能在<code>http</code>块中配置的指令，只不过，当<code>index</code>指令配置在不同的块中时，对应的作用域不同</p><p>举一反三，有些指令既能配置在<code>server</code>块中，也能配置在<code>http</code>块中，当多个<code>server</code>存在相同的配置时，我们可以将这些完全相同的配置指令提取到上一级的<code>http</code>块中，以便多个<code>server</code>块共用这些配置，当然，如果你在某个<code>server</code>中单独配置了对应的配置指令，那么这个<code>server</code>仍然会以自己的配置为准</p><p>通过上述示例，你是不是对’配置指令’和’块’之间的关系理解的更加透彻了呢？</p><p>其实，’配置指令’不仅和’块’有一定的关系，’配置指令’和’模块’也有着非常紧密的对应关系，之前总结过，<code>nginx</code>是模块化的，不同的’模块’负责不同的’功能’，所以，当我们需要针对某个’功能’进行配置时，就需要使用到对应的’配置指令’从根本上来说，每个’配置指令’都属于某一个’模块’，一个’模块’中会有一个或多个’配置指令’，当我们想要对相关模块或者功能进行设置时，就会使用到对应模块中的配置指令。在第一篇文章中我们就提到过，除了内置的标准模块，还有一些可选模块，我们可以在编译安装时选择安装哪些可选模块，如果你没有安装对应的可选模块，那么你也无法使用对应的配置指令。原因刚才已经说过，每个配置指令都属于某一个模块</p><p>当然，作为用户，没有人天生就会使用<code>nginx</code>的这些配置指令，也没有人能够记住所有模块、配置指令、块之间的关系，所以，我们可以通过官方的文档进行查询，那么此处，我们就来介绍一下怎样通过官网文档找到我们想要的答案</p><p>首先，打开<code>nginx</code>开源版官网，<code>nginx.org</code>，打开官网后，可以看到如下页面，在如下页面的右侧菜单中，可以找到’<code>documentation</code>‘链接，点击此链接，即可看到<code>nginx</code>官网文档</p></blockquote><p><img src="/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/4-2.jpg" alt="4-2"></p><blockquote><p>打开文档页面后，你可以看到一些关于<code>nginx</code>的相关链接，这些链接中包含了与<code>nginx</code>相关的各种信息，我们可以从这些连接中找到我们想要的答案，仍然拿刚才的<code>index</code>指令作为示例，如果，我们想要找到<code>index</code>指令的使用方法，该怎么办呢？方法如下</p><p>下拉文档页面，找到如下图所示的’<code>modules reference</code>‘部分，点击下图中标注出的’<code>Alphabetical index of directives</code>‘链接</p></blockquote><p><img src="/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/4-3.jpg" alt="4-3"></p><blockquote><p>点击上述链接后，你会看到一个指令列表，这个指令列表里面就是所有我们能用到的配置指令，这些配置指令按照字母顺序排序，在浏览器中使用’<code>ctrl + f</code>‘进行搜索，此处，我搜索刚才我们用于示例的<code>index</code>配置指令，如下</p></blockquote><p><img src="/1995/01/07/Nginx%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E3%80%81%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/4-4.jpg" alt="4-4"></p><blockquote><p>点击<code>index</code>链接，即可看到<code>index</code>指令的相关信息，此处就不截图了，首先，页面最上方会显示当前指令属于哪个模块，你看到的应该是一行黑体字’<code>Module ngx_http_index_module</code>‘，也就是说，<code>index</code>配置指令属于<code>ngx_http_index_module</code>模块，由于这个模块中只有<code>index</code>一个指令，所以你在当前页面中只会看到<code>index</code>指令的用法与示例，如果你查看的指令所在的模块包含很多条指令，那么这个模块中所包含的所有指令的用法与示例都会展示在这个页面中，你在当前页面中，应该可以看到<code>index</code>的基本语法概述，如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:index file ...;</span><br><span class="line">Default: index index.html;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><blockquote><p>上述这段示例告诉了我们index指令的基本语法、默认值、以及上下文位置</p><p><code>Syntax</code>表示指令的基本语法</p><p><code>Default</code>表示指令的默认值是什么</p><p><code>Context</code>表示指令所处的上下文位置，上下文位置是什么意思呢？说白了，就是我们之前说的，指令能够配置在哪个块中，从官网的示例中可以看出，<code>index</code>指令只能配置在<code>http</code>块、<code>server</code>块或者<code>location</code>块中</p><p>基本语法概述之后，还有该指令对应的一些示例，你可以参考官网给出的示例学习该指令的用法</p><p>经过上述描述，你肯定已经明白了怎样通过指令列表找到它所在的模块以及指令的用法</p><p>不过在使用的过程中，你可能还会有另一种需求，就是想要了解某个模块的作用，以及这个模块中包含哪些指令，那么，怎样才能找到自己想要了解的模块呢？其实与刚才的步骤非常类似，仍然是打开官网，点击右侧菜单中的’<code>documentation</code>‘链接，进入文档页面，下拉页面，找到’<code>modules reference</code>‘部分，’<code>modules reference</code>‘部分下面其实就是所有模块的模块列表，如果你想要的了解某个模块，只要点击模块对应的链接，就能够看到模块以及对应指令的使用方法了，此处，点击模块列表中的’<code>ngx_http_index_module</code>‘链接，你会发现，此链接中的内容与之前通过指令列表查找到的内容完全相同，其实，我们只是通过两种方式查找到了相同的内容而已，第一种方式是通过指令列表查找，第二种方式是通过模块列表查找，只是查找方式不同，但最终得到的内容是完全相同的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;通过前文我们已经了解到，安装&lt;code&gt;nginx&lt;/code&gt;以后，&lt;code&gt;nginx&lt;/code&gt;会提供一个默认&lt;code&gt;server&lt;/code&gt;，我们可以从&lt;code&gt;nginx.conf&lt;/code&gt;文件中找到这个默认&lt;code&gt;server&lt;/code&gt;的相关配置，如下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx(3)：Nginx基础命令</title>
    <link href="https://qzloo.cn/1995/01/05/Nginx%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://qzloo.cn/1995/01/05/Nginx%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</id>
    <published>1995-01-05T01:49:49.000Z</published>
    <updated>2020-01-03T05:54:52.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><blockquote><p>在前两篇文章中，我们介绍了安装<code>nginx</code>的方法以及配置文件的基础语法结构，现在呢，我们来了解一下<code>nginx</code>的常用基础命令</p><p>上一篇文章中我们已经提到了怎样启动<code>nginx</code>，如果你是通过编译安装的方式安装了<code>nginx</code>，那么我们可以通过<code>nginx</code>安装目录的<code>sbin</code>目录中的<code>nginx</code>二进制文件启动<code>nginx</code>，由于我将<code>nginx</code>安装到了<code>/srv/nginx/</code>目录中，所以，使用如下命令启动<code>nginx</code></p></blockquote><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /srv/nginx/sbin/nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>没错，<code>nginx</code>命令就是我们最常用到的命令了，上例<code>nginx</code>命令没有使用任何参数，我们还可以配合一些参数来使用<code>nginx</code>命令，如果你使用的是<code>yum</code>源的方法安装的<code>nginx</code>，你可以在任何路径下输入如下命令启动<code>nginx</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>yum</code>源安装<code>nginx</code>后，可以在任何目录中直接使用<code>nginx</code>命令，这是因为通过<code>yum</code>源安装<code>nginx</code>后，<code>nginx</code>二进制文件默认会放在<code>/usr/sbin/</code>目录中，而这个目录正好属于默认环境变量<code>PATH</code>变量中的一部分，所以，如果你通过编译安装的方式安装了<code>nginx</code>，也可以将<code>nginx</code>的安装目录中的<code>/sbin</code>目录配置到<code>PATH</code>环境变量中，以便在任何路径中都可以直接使用<code>nginx</code>命令，以我的编译安装环境作为示例，步骤如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、 创建/etc/profile.d/nginx.sh文件,以便写入环境变量配置</span><br><span class="line"></span><br><span class="line">2、 在/etc/profile.d/nginx.sh文件中写入如下内容:</span><br><span class="line">nginx_home=/srv/nginx</span><br><span class="line">PATH=$nginx_home/sbin:$PATH</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">3、 使用如下命令重载刚才的配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><blockquote><p>完成上述步骤，即可在编译安装<code>nginx</code>后，方便的执行<code>nginx</code>命令了</p><p>说完上述快捷配置后，我们再来聊一下<code>nginx</code>命令的一些常用选项</p><p>不加任何选项直接执行<code>nginx</code>命令，就是用于启动<code>nginx</code>服务的，如果你想要看看<code>nginx</code>命令都有哪些可用的选项，则可以使用’<code>-h</code>选项’或者’<code>-?</code>选项’，如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx -h</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx -?</span></span><br></pre></td></tr></table></figure><blockquote><p>使用’<code>-v</code>‘选项(小写v)可以查看<code>nginx</code>的版本信息，如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx -v</span></span><br><span class="line">nginx version: nginx/1.16.1</span><br></pre></td></tr></table></figure><blockquote><p>使用’<code>-V</code>‘选项(大写V)可以查看当前<code>nginx</code>的编译信息，在最开始的文章中我们就介绍过了，编译安装<code>nginx</code>时，有很多’可选模块’可供我们使用，我们可以选择安装或不安装对应的可选模块，同时，我们还可以在编译安装时，设置一些编译选项，比如安装目录、各种文件的目录、编译器选项等等，这些信息都属于编译信息，所以，我们可以通过如下命令查看这些编译信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx -V</span></span><br><span class="line">nginx version: nginx/1.16.1</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/srv/nginx --with-file-aio --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_geoip_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module</span><br></pre></td></tr></table></figure><blockquote><p>当然，即使你使用的是<code>yum</code>源的方式安装的<code>nginx</code>，同样可以通过上述命令查看这些编译信息，只不过<code>yum</code>源中的<code>nginx</code>二进制文件是别人提前为我们编译好的，那些编译信息也是别人为我们编译<code>nginx</code>时所使用的编译设置</p><p>使用’<code>-c</code>‘选项可以指定使用哪个配置文件来启动<code>nginx</code>服务，默认情况下，会使用<code>nginx</code>安装目录中的<code>conf</code>目录中的<code>nginx.conf</code>文件作为主配置文件，你也可以在命令行中使用’<code>nginx -c /xxxpath/nginx.conf</code>‘来指定具体路径下的配置文件启动<code>nginx</code>服务</p><p>使用’<code>-t</code>‘选项或者’<code>-T</code>‘选项可以测试<code>nginx.conf</code>配置文件中是否存在语法错误，前一篇文章中我们提到过，<code>nginx.conf</code>中的配置指令需要以分号结尾，如果没有以分号结尾，会在启动<code>nginx</code>时报语法错误，其实，在启动<code>nginx</code>服务之前，我们就可以使用’<code>nginx -t</code>‘命令对<code>nginx.conf</code>文件进行语法检查，如果配置文件中存在语法错误，那么相应的错误信息会输出，如果配置语法没有问题，则会出现类似如下信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx -t</span></span><br><span class="line">nginx: the configuration file /srv/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /srv/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure><blockquote><p>无论语法是否正确，’<code>nginx -t</code>‘命令都不会启动<code>nginx</code>服务，’<code>nginx -t</code>‘命令只用于检查是否存在语法错误，此处所谓的语法错误包括’非法指令’、’重复指令’、’指令没有以分号结尾’等</p><p>当存在语法错误时，’<code>nginx -t</code>‘命令和’<code>nginx -T</code>‘命令输出的错误信息是完全相同的，只有在语法正确时，这两个命令才存在区别，’<code>nginx -T</code>‘命令会在语法正确时，将配置文件中的内容输出到屏幕中，我们可以将这些内容重定向到一个文件中，以便将当前的正确配置进行备份</p><p>还有一个非常常用的选项，就是’<code>-s</code>‘选项，’<code>-s</code>‘选项的作用就是向正在运行的<code>nginx</code>进程发送信号，这也解释可能不容易理解，我们换个角度来说吧，比如，当<code>nginx</code>服务已经启动，我们想要停止<code>nginx</code>服务，则可以使用’<code>nginx -s stop</code>‘命令停止<code>nginx</code>服务，’<code>nginx -s stop</code>‘命令表示向<code>nginx</code>进程发送<code>stop</code>信号，这也解释你应该明白了吧，使用’<code>-s</code>‘选项除了能够发送<code>stop</code>信号，还能发送<code>quit</code>信号、<code>reopen</code>信号以及<code>reload</code>信号，那么这三种信号分别代表什么意思呢？我们一一道来</p><p><strong>quit信号</strong>：与<code>stop</code>信号的作用类似，<code>quit</code>信号作用也是用于停止<code>nginx</code>服务，<code>quit</code>信号和<code>stop</code>信号的区别在于，<code>nginx</code>进程收到<code>stop</code>信号以后会立即停止服务，而收到<code>quit</code>信号后，不会再接收新的请求，但是会先处理完已经接受的链接请求，处理完这些请求之后再停止服务，这种停止方式被称之为’优雅的停止’</p><p><strong>reload信号</strong>：<code>reload</code>信号的作用就是在不停止服务的情况下重载配置文件，比如，<code>nginx</code>正在正常的提供服务，此时，管理员修改了<code>nginx.conf</code>文件中的配置指令，管理员希望新的配置立刻生效，但是又不希望重启<code>nginx</code>服务，此时就可以使用’<code>nginx -s reload</code>‘命令重载配置文件，以便在不重启<code>nginx</code>的情况下载入新的配置，同时避免了因重启而造成的服务中断</p><p><strong>reopen信号</strong>：利用<code>reopen</code>信号可以使<code>nginx</code>进程重新打开日志文件，以便实现日志分割的效果，关于日志切割的话题会单独总结一篇文章，<code>reopen</code>信号也会在届时进行演示，此处不用纠结</p><p>此处将上述常用选项进行总结，以便回顾：</p><p><strong>不加选项</strong>：启动<code>nginx</code>服务</p><p><strong>-h或-?选项</strong>：查看<code>nginx</code>命令帮助</p><p><strong>-v选项</strong>：查看<code>nginx</code>版本信息</p><p><strong>-V选项</strong>：查看<code>nginx</code>编译信息</p><p><strong>-c选项</strong>：启动<code>nginx</code>时指定配置文件</p><p><strong>-t或-T选项</strong>：测试<code>nginx.conf</code>文件是否存在语法错误</p><p><strong>-s选项</strong>：向正在运行的<code>nginx</code>主进程发送信号，信号的可用值有<code>stop</code>、<code>quit</code>、<code>reopen</code>、<code>reload</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在前两篇文章中，我们介绍了安装&lt;code&gt;nginx&lt;/code&gt;的方法以及配置文件的基础语法结构，现在呢，我们来了解一下&lt;code&gt;nginx&lt;/code&gt;的常用基础命令&lt;/p&gt;
&lt;p&gt;上一篇文章中我们已经提到了怎样启动&lt;code&gt;nginx&lt;/code&gt;，如果你是通过编译安装的方式安装了&lt;code&gt;nginx&lt;/code&gt;，那么我们可以通过&lt;code&gt;nginx&lt;/code&gt;安装目录的&lt;code&gt;sbin&lt;/code&gt;目录中的&lt;code&gt;nginx&lt;/code&gt;二进制文件启动&lt;code&gt;nginx&lt;/code&gt;，由于我将&lt;code&gt;nginx&lt;/code&gt;安装到了&lt;code&gt;/srv/nginx/&lt;/code&gt;目录中，所以，使用如下命令启动&lt;code&gt;nginx&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx(2)：Nginx第一个web服务器</title>
    <link href="https://qzloo.cn/1995/01/03/Nginx%E7%AC%AC%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://qzloo.cn/1995/01/03/Nginx%E7%AC%AC%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>1995-01-03T11:38:51.000Z</published>
    <updated>2020-01-03T05:54:36.795Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><blockquote><p>今天的目标就是利用<code>nginx</code>搭建一个静态的<code>web</code>服务器，然后访问这个<code>web</code>服务中的一些资源，通过这个目标，来了解<code>nginx</code>的一些基础目录结构和基础语法</p><p>首先，请确保你已经安装了<code>nginx</code>，安装方法可以参见上一篇文章</p><p>通过上一篇的安装方法，我们知道，有两种方法可以安装<code>nginx</code>，通过<code>yum</code>源或者通过编译，但是通过两种方式安装后的<code>nginx</code>的目录结构略有不同，默认提供的资源与配置略有不同，所以，我们暂且先以编译安装的方式进行介绍，之后再按照<code>yum</code>源安装的方式进行介绍，以免发生混淆</p><p>我们已经将<code>nginx</code>编译安装到了<code>srv</code>目录，在没有启动过<code>nginx</code>的情况下，<code>/srv/nginx</code>目录的结构如下</p></blockquote><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /srv/nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -l</span></span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 27 20:41 conf</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 27 20:41 html</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 27 20:41 logs</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 27 20:41 modules</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 27 20:41 sbin</span><br></pre></td></tr></table></figure><blockquote><p>此处我们大致介绍一下上述目录的作用，之后会详细的进行解释，如有疑问，不必纠结</p><p><code>conf</code>目录中存放了<code>nginx</code>相关的配置文件</p><p><code>html</code>目录是默认提供的web服务的’根目录’</p><p><code>logs</code>目录是<code>nginx</code>日志的存放目录</p><p><code>modules</code>目录中存放了一些模块会用到的库</p><p><code>sbin</code>目录中存放了<code>nginx</code>的二进制文件，我们需要使用<code>nginx</code>二进制文件启动<code>nginx</code></p><p>好了，我们并没有做任何其他配置，那么现在让我们来启动之前安装好的<code>nginx</code>，命令如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /srv/nginx/sbin/nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>执行上述命令即可启动<code>nginx</code></p><p>由于我的服务器<code>80</code>端口已经被占用，在此我改为<code>81</code>端口运行<code>nginx</code></p><p><code>nginx</code>启动以后，我们就可以访问它了，虽然我们没有进行任何配置，但是<code>nginx</code>会默认为我们创建一个<code>http</code>服务器，这个默认的<code>http</code>服务会监听在<code>80</code>端口上，安装<code>nginx</code>的服务器<code>IP</code>地址为<code>116.62.188.230</code>，访问这个<code>IP</code>地址即可访问到<code>nginx</code>的默认提供的<code>http</code>服务，如下</p></blockquote><p><img src="/1995/01/03/Nginx%E7%AC%AC%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/1-1.jpg" alt="1-1"></p><blockquote><p>如上图所示，我们看到的页面是<code>nginx</code>默认提供的一个<code>html</code>页面，在[<code>http</code>基础概念]一文中我们提到过，网络上的资源不是凭空产生的，都是别人为我们准备好的，上图中默认的<code>html</code>页面也是一个提前准备好的资源，那么，这个<code>html</code>页面到底放在了那里呢？它就在<code>nginx</code>的<code>html</code>目录中，如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /srv/nginx/html/</span></span><br><span class="line">50x.html  index.html</span><br></pre></td></tr></table></figure><blockquote><p>刚才访问到的<code>html</code>页面就是此目录中的<code>index.html</code>页面，稍后我们会解释为什么默认会访问这个<code>index.html</code>文件</p><p>我们知道，<code>nginx</code>的最核心的功能就是提供<code>http</code>服务，而且刚才已经演示过，安装<code>nginx</code>以后，即使不做任何配置，<code>nginx</code>也会默认提供一个<code>http</code>服务供我们使用，其实，之所以有默认的<code>http</code>服务可以使用，是因为<code>nginx</code>的配置文件中默认就有对应的配置，我们一起来看看这个配置文件，它就是<code>conf</code>目录中的<code>nginx.conf</code>配置文件，这个配置文件是<code>nginx</code>的主配置文件，我们大多数的配置工作都要在这个配置文件中完成，所以，我们先打开这个文件看个究竟</p><p>默认情况下，<code>nginx.conf</code>文件中会有很多注释的行，这些注释行是<code>nginx</code>官方为我们准备的一些配置示例，如果你没有参考这些示例的需求，完全可以将这些行删除掉，从初学者的角度考虑，我们先把这些注释行删除，以免从心里上带来负担，不要着急，这些配置并不困难，我们会慢慢搞懂它们的，此处，我先执行如下命令，将默认的注释行删除</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">'/^[[:space:]]*#/'</span>d nginx.conf</span></span><br></pre></td></tr></table></figure><blockquote><p>同时，为了演示方便，我已经删除了一些没用的空行，最终，<code>nginx.conf</code>中真正有用的部分如下</p></blockquote><p><img src="/1995/01/03/Nginx%E7%AC%AC%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/1-2.jpg" alt="1-2"></p><blockquote><p>其实，就是因为有上述配置的存在，<code>nginx</code>才能为我们提供一个默认的<code>http</code>服务，我们暂且先放下这个配置文件不管，来聊聊<code>nginx</code>的基本配置语法，等聊完这些基本语法，再来看上图中的配置，就简单多了</p><p>先来说说最常用到的配置语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">location ... &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上述语法配置可以看出，上述示例可以分为几个逻辑部分，<code>http</code>部分，<code>server</code>部分，<code>location</code>部分，或者说，上述示例可以分为几个逻辑块，<code>http</code>块，<code>server</code>块，<code>location</code>块，你也一定看出来了，每个’配置块’都是使用大括号’<code>{}</code>‘作为分界线的，而且，从缩进可以看出，它们是有层级关系的，<code>http</code>中可以配置多个<code>server</code>，一个<code>server</code>中可以配置多个<code>location</code>，我们知道，<code>nginx</code>最基础的功能就是用来提供<code>http</code>服务，所以，跟<code>http</code>有关的公共配置，可以放置在<code>http</code>块中，<code>http</code>块中又可以配置多个<code>server</code>，那么<code>server</code>代表了什么呢？我们在一台主机中安装了<code>nginx</code>，那么能不能让这台<code>nginx</code>主机同时提供多个<code>web</code>服务呢？答案是肯定的，每一个<code>server</code>就代表一个<code>http</code>服务，我们可以同时配置多个<code>server</code>，以便同时提供多个<code>http</code>服务，不同的<code>server</code>可以使用不同的配置，写入到某个<code>server</code>块中的配置只对对应的<code>http</code>服务生效，如果多个<code>server</code>存在共同的公用配置，则可以将共同的配置写在<code>http</code>块中，以便多个<code>server</code>共享这些配置，一个<code>server</code>块中又可以有一个或多个<code>location</code>，<code>location</code>又是什么意思呢？当我们访问一个网络上的资源时，都是通过<code>url</code>访问的，你可以把<code>location</code>当做<code>url</code>的一部分，此处，我们使用如下<code>url</code>作为示例：</p><p><code>https://qzloo.cn/1995/01/01/Nginx安装</code></p><p>上述链接中的’<code>/1995/01/01</code>‘部分就是一个<code>location</code>，我们可以通过<code>location</code>将<code>url</code>中的路径和服务器的某个目录建立起关联关系，此处不再纠结，在用到它时我们再来细说</p><p>通过上述描述，你应该已经对刚才的<code>nginx.conf</code>有了一个初步的了解，<code>nginx.conf</code>中包含了我们最常用到的配置块：<code>http</code>块、<code>server</code>块和<code>location</code>块，当然，<code>nginx</code>中不止有这三种块，还有一些其他的块，比如<code>events</code>块、<code>stream</code>块等，还是那句话，先有一个大致概念，细节之处用到了再说，了解了上述概念以后，再回过头来看刚才的配置文件，是不是觉得顺眼多了，你可能已经发现了，示例中的<code>nginx.conf</code>中有一些配置不在任何’块’中，而是放在了<code>nginx.conf</code>文件的对顶部，比如’<code>worker_processes</code>‘配置项，它没有配置到任何一个块中，而是配置的到了这些’块’之外的最上方，你可以把最上方这一片区域理解成’全局配置区’或者’主配置区’，我们暂且把这片区域称之为’<code>main</code>‘配置区，’<code>main</code>‘配置区不属于任何一个块</p><p>你也会从<code>nginx.conf</code>中看到各种各样的配置项，比如刚才提到的’<code>worker_processes</code>‘，以及你在示例文件中看到的’<code>include</code>‘、’<code>listen</code>‘等，我们可以把这些配置项称之为’配置指令’，而配置指令后面通常会跟随一个或多个’值’，我们也可以称这些’值’为’配置参数’，一个配置指令通常会跟随一个或多个配置参数，想要正确的配置这些指令，最好先理解这些指令对应的功能，不过此处，我们先搞明白它们的基本配置语法，你一定发现了，每个指令都是以分号结尾的，分号代表了指令的配置结束，每添加一个配置指令，都不要忘记加分号，否则会因为配置语法错误，而导致无法正常启动<code>nginx</code>，为了清晰明了，方便查看，通常每个指令单独配置在一行中，你也可以将多个指令配置在一行中，每个指令用分号隔开，但是大家通常不会这样做</p><p>再回过头来聊聊’块’，从示例中的各种块可以看出，块的基本结构就是大括号’<code>{}</code>‘，每个块后面都有一对大括号，’<code>{</code>‘代表块配置的开始，’<code>}</code>‘代表块配置的结束，而’块’和’配置指令’是有一定的对应关系的，比如，某些配置指令只能在<code>http</code>块中配置，某些配置指令只能在<code>server</code>块中配置，某些配置指令只能在<code>location</code>块中配置，有些配置指令既能在<code>server</code>块中配置又能在<code>http</code>块中配置，而有些配置指令只能在<code>mail</code>区中进行配置，比如刚才提到的’<code>worker_processes</code>‘配置项，就只能在<code>main</code>区中配置，不能配置在块中，那么哪些配置指令能在哪些块中进行配置呢？让我们记住所有指令与块的对应关系显然不太可能，我们可以通过官网查看对应的指令都能在哪些块中进行配置，以及指令的具体作用，具体方法会在之后的文章中进行介绍</p><p>刚刚在准备<code>nginx.conf</code>示例文件时，我已经通过命令把注释行去掉了，正如你看到的，在<code>nginx</code>配置文件中，也是使用’#’作为注释符的</p><p>好了，看到这里，我们再来仔细看看刚才的<code>nginx.conf</code>配置文件，我们知道，<code>nginx</code>会提供一个默认的<code>http</code>服务，这个服务其实就是<code>nginx.conf</code>中默认配置的一个<code>server</code>块，如上述示例文件<code>nginx.conf</code>所示，这个默认<code>server</code>监听在<code>80</code>端口上，没错，’<code>listen 80;</code>‘这条指令就是用来配置<code>server</code>所监听的端口的，当我们访问一个<code>http</code>网站时，如果没有明确指明端口，默认会访问<code>80</code>端口</p><p>正如本文开头的示例所示，当我访问’<code>http://116.62.188.230:81/&#39;</code>这个网址时，默认会访问到<code>nginx</code>服务器上的<code>/srv/nginx/html/index.html</code>文件，之所以会访问到这个文件，是由下面这段配置决定的</p></blockquote><p><img src="/1995/01/03/Nginx%E7%AC%AC%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/1-3.jpg" alt="1-3"></p><blockquote><p>刚才说过，<code>location</code>可以理解成<code>url</code>的一部分，那么当我们访问’<code>http://116.62.188.230:81/</code>‘这个<code>url</code>时，这个<code>url</code>的最后一个’<code>/</code>‘其实就是上图中的’<code>location /</code>‘，换句话说就是，上图中红线标记处的’<code>/</code>‘其实对应的就是’<code>http://116.62.188.230:81/</code>‘这个<code>url</code>的最后一个’<code>/</code>‘，这个<code>location</code>块中有两条配置指令，它们分别是<code>root</code>和<code>index</code>，<code>root</code>配置项是什么意思呢？<code>root</code>配置指令的意思是：当前<code>location</code>所对应的文档根目录是哪里，’<code>root html;</code>‘表示当前<code>location</code>的文档根目录是<code>html</code>目录，那么’文档根目录’又是什么意思呢？说白了，文档根目录的意思就是当有人访问’<code>/</code>‘这个路径时，去服务器的哪个目录中找对应的资源，举个例子，如果我在<code>html</code>目录中放了一张图片，图片名为<code>a.jpg</code>，那么我就能通过’<code>http://116.62.188.230:81/a.jpg</code>‘访问到这张图片，<code>url</code>中的’<code>/</code>‘对应了’<code>location /</code>‘配置段，而’<code>location /</code>‘又对应到了服务器的<code>html</code>目录，所以，<code>url</code>中的’<code>/</code>‘就与服务器的<code>html</code>目录建立了对应关系，当我们访问’<code>http://116.62.188.230:81/a.jpg</code>‘这个地址时，其实访问的是服务器上<code>html</code>目录中的<code>a.jpg</code>，再换句话说，<code>html</code>目录就是当前<code>location</code>的资源目录。注意：上例中的<code>html</code>路径是一个相对路径，表示<code>nginx</code>安装目录中的<code>html</code>目录，因为我将<code>nginx</code>安装到了<code>/srv/nginx</code>目录中，所以上例中的<code>html</code>目录的绝对路径就是’<code>/srv/nginx/html/</code>‘，你可以在’<code>/srv/nginx/html/</code>‘目录中放一张<code>a.jpg</code>图片，然后尝试使用’<code>http://116.62.188.230:81/a.jpg</code>‘这个地址访问它，其实，要想完全搞明白<code>location</code>还是要费一番口舌的，不要怕，之后会有专门总结<code>location</code>的文章。说完<code>root</code>指令，再聊聊<code>index</code>指令，<code>index</code>指令表示当没有指明任何资源时，默认访问哪个资源，什么意思呢？仍然拿刚才的<code>url</code>作为示例，当我们访问’<code>http://116.62.188.230:81/a.jpg</code>‘这个地址时，<code>nginx</code>知道我们想要获取<code>a.jpg</code>这张图片资源，但是如果我们直接访问’<code>http://116.62.188.230:81/</code>‘这个地址，没有指明我们想要获取什么，那么<code>nginx</code>会默认去把<code>index.html</code>或者<code>index.htm</code>返回给我们，原因就是上图中配置的’<code>index index.html index.htm;</code>‘起的作用</p><p>好了，通过上述描述，你的脑海中应该已经有了大致的框架与概念，有了自己的理解以后，剩下的就好办了</p><p>刚才我们所有的描述都是基于编译安装的方式进行的，由于通过<code>yum</code>源安装<code>nginx</code>后的目录结构与编译安装后的目录结构略有不同，所以此处我再将两种方式安装后的区别与注意点描述一下</p><p>编译安装后，我们通过如下二进制文件启动<code>nginx</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/nginx安装路径/sbin/nginx</span><br></pre></td></tr></table></figure><blockquote><p>通过<code>yum</code>源安装<code>nginx</code>后，对应的二进制文件已经自动拷贝到了<code>/usr/sbin</code>目录中，而此目录默认已经加入到环境变量中，所以我们可以在任意目录直接访问’<code>nginx</code>‘命令启动<code>nginx</code></p><p>编译安装后，<code>nginx</code>相关的配置文件存放在如下路径中</p><p><code>/nginx安装路径/conf/</code></p><p>而通过<code>yum</code>源安装<code>nginx</code>后，相关的配置文件存放在如下路径中</p><p><code>/etc/nginx/</code></p><p>通过编译安装的方式安装<code>nginx</code>以后，默认的’<code>server</code>块’直接配置到了<code>nginx.conf</code>文件中，而通过官方<code>yum</code>源安装<code>nginx</code>后，默认的’<code>server</code>块’会配置在’<code>/etc/nginx/conf.d/default.conf</code>‘文件中，换句话说就是，如果你通过官方<code>yum</code>源安装了<code>nginx</code>，那么你在<code>/etc/nginx/nginx.conf</code>文件中无法找到默认提供的<code>server</code>块，只能在<code>/etc/nginx/conf.d/default.conf</code>文件中找到默认的<code>server</code>块，这是为什么呢？其实，我们从<code>/etc/nginx/nginx.conf</code>文件中就能找到答案，打开<code>/etc/nginx/nginx.conf</code>文件，查看默认的<code>http</code>块的配置，你会在<code>http</code>块中发现如下配置指令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure><blockquote><p>出现上述情况的根本原因就是在于这条配置指令，<code>include</code>指令表示将指定的文件中的内容包含到当前位置中，举个例子，如果我在<code>http</code>配置块中的第三行设置了’<code>include test.conf;</code>‘指令，那么<code>test.conf</code>文件中的所有内容都会替换到<code>http</code>配置块的第三行，换句话说就是，虽然文本内容写在<code>test.conf</code>文件中，但是通过<code>include</code>指令替换后，相当于<code>test.conf</code>中的文本写在了<code>http</code>块中的第三行</p><p>那么，理解了<code>include</code>指令的作用以后，再回过头看刚才的配置，就一目了然了</p><p>‘<code>include /etc/nginx/conf.d/\*.conf;</code>‘这条指令的作用就是将’<code>/etc/nginx/conf.d/\*.conf</code>‘文件中的内容替换到当前指令所在的位置，由于使用了’*‘作为通配符，所以<code>/etc/nginx/conf.d/</code>目录中所有以’<code>.conf</code>‘作为后缀名的文件都会被匹配到，<code>/etc/nginx/conf.d/default.conf</code>文件自然也会被匹配到，所以最终，<code>http</code>块中<code>include</code>指令所在位置的文本内容会被替换成<code>/etc/nginx/conf.d/default.conf</code>文件中的内容，而<code>/etc/nginx/conf.d/default.conf</code>文件中的内容恰好是默认提供的<code>server</code>块配置，当然，如果你在<code>/etc/nginx/conf.d/</code>目录中放了一些其他以’<code>.conf</code>‘结尾的文本文件，那么这些文件中的内容也会因为刚才的<code>include</code>指令而被包含到<code>nginx.conf</code>文件中</p><p>综上所述，通过官方<code>yum</code>源安装<code>nginx</code>后，虽然<code>/etc/nginx/nginx.conf</code>文件中看不到默认<code>server</code>块的配置，但是并不代表没有提供默认的<code>server</code>块配置，只是通过<code>include</code>指令的方式，将默认<code>server</code>块的配置单独放置在了<code>/etc/nginx/conf.d/default.conf</code>文件中，最终效果与直接将<code>server</code>块配置写入到<code>http</code>块中无异。其实，即使是通过编译安装的方式安装的<code>nginx</code>，也可以借鉴这种配置方式，当我们配置了多个<code>server</code>块时，可以将各个<code>server</code>块分别提取出来，单独放置到一个配置文件中，然后再使用<code>include</code>指令引用对应的配置文件，这样就能从逻辑上将各个<code>server</code>块的配置隔离到不同的配置文件中，结构上更加分明，也方便我们进行配置管理，这些操作在以后都会进行实际的演示，不必着急，此时，你只要搞明白大概的原理即可</p><p>通过官方<code>yum</code>安装后，如果你查看了<code>/etc/nginx/conf.d/default.conf</code>中提供的默认<code>server</code>块配置，那么你会发现，默认<code>server</code>块中的<code>location</code>块配置的<code>root</code>指令对应的路径是’<code>/usr/share/nginx/html</code>‘，也就是说，默认提供的<code>server</code>对应的文档根目录是此路径，我们需要将对应的资源放置到此目录中，即可通过默认的服务进行访问了</p><p>其实，上述注意点多数是因为两种安装方式的默认路径和结构的不同造成的，如果你是通过<code>yum</code>源安装了<code>nginx</code>，那么你可以通过如下命令查看安装<code>nginx</code>后都使用到了哪些目录和文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -ql nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你没有使用官方<code>yum</code>源，而是使用了<code>epel</code>源安装了<code>nginx</code>，那么配置文件和默认的<code>index.html</code>页面可能又是另外一番样子了，但是只要搞明白原理，都是可以轻松应对的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;今天的目标就是利用&lt;code&gt;nginx&lt;/code&gt;搭建一个静态的&lt;code&gt;web&lt;/code&gt;服务器，然后访问这个&lt;code&gt;web&lt;/code&gt;服务中的一些资源，通过这个目标，来了解&lt;code&gt;nginx&lt;/code&gt;的一些基础目录结构和基础语法&lt;/p&gt;
&lt;p&gt;首先，请确保你已经安装了&lt;code&gt;nginx&lt;/code&gt;，安装方法可以参见上一篇文章&lt;/p&gt;
&lt;p&gt;通过上一篇的安装方法，我们知道，有两种方法可以安装&lt;code&gt;nginx&lt;/code&gt;，通过&lt;code&gt;yum&lt;/code&gt;源或者通过编译，但是通过两种方式安装后的&lt;code&gt;nginx&lt;/code&gt;的目录结构略有不同，默认提供的资源与配置略有不同，所以，我们暂且先以编译安装的方式进行介绍，之后再按照&lt;code&gt;yum&lt;/code&gt;源安装的方式进行介绍，以免发生混淆&lt;/p&gt;
&lt;p&gt;我们已经将&lt;code&gt;nginx&lt;/code&gt;编译安装到了&lt;code&gt;srv&lt;/code&gt;目录，在没有启动过&lt;code&gt;nginx&lt;/code&gt;的情况下，&lt;code&gt;/srv/nginx&lt;/code&gt;目录的结构如下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://qzloo.cn/tags/Nginx/"/>
    
  </entry>
  
</feed>
