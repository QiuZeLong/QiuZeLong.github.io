<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Zabbix(6)：zabbix触发器、事件、动作 相关概念</title>
    <url>/2010/01/11/zabbix%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8A%A8%E4%BD%9C%20%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote>
<p>这篇文章将会初步的介绍<code>zabbix</code>中的触发器、事件、动作等相关概念</p>
<p>我有一个朋友，我很佩服他，他的行动能力特别强，想到了，计划好了，就去做，比如说养鸡，他在农村找了一片地，盖了一个养鸡场，然后就开始养鸡，并且把土鸡下的蛋加以包装，以绿色无污染的优势在市场上售卖，后来，他还去考了一个飞机驾照，我知道养鸡和飞机并没有什么关系，我只是单纯的感觉他的人生非常精彩而已，有的客官看到这里就怒了，我是来了解<code>zabbix</code>的，不是来看什么’养鸡’和’飞机’的，能不能别瞎<code>BB</code>，耽误大爷时间，这位大爷您息怒，听我慢慢道来</p>
<p>其实，我们可以从养鸡场的某个场景去理解<code>zabbix</code>的触发器、事件、动作等相关概念，在养鸡场，温度是非常重要的，温度要适中，要让鸡感觉很舒服，不同年龄段的鸡对温度的要求也不一样<del>咳咳</del>扯远了，我们不考虑这么多，假设，养鸡场的温度不能低于<code>30</code>度，如果低于<code>30</code>度，鸡们就会很不满意，就会吃不好睡不好，导致身体亚健康，鸡的身体不好，我们把它们做成鸡肉的时候口感就不好，口感不好客户就不会购买我们的鸡肉，我们作为鸡场老板来说，是不能允许这样的事情发生的，所以，我们必须时刻监控着养鸡场的温度，如果养鸡场的温度低于<code>30</code>度，必须马上亮起红灯警报，工作人员发现红灯亮起，就必须马上采取措施，比如，把暖气打开，或者马上报告老板</p>
</blockquote><a id="more"></a>
<p>![6-1](zabbix触发器、事件、动作 相关概念/6-1.jpg)</p>
<blockquote>
<p>那么现在，我们把刚才说的养鸡场的场景与我们的<code>zabbix</code>联系起来，我们要监控养鸡场的温度，就好像我们要监控服务器的磁盘使用率一样，无论是养鸡场的温度，还是磁盘的使用率，都是我们要监控的指标，我们在前文已经描述过，一个被监控的指标被称作一个’监控项’(<code>item</code>)，那么，养鸡场的温度，在<code>zabbix</code>中就是一个<code>item</code>，而我们规定，养鸡场的温度低于<code>30</code>度时就要亮起红灯，也就是说，<code>30</code>度就是温度这个指标的阈值，那么，养鸡场的温度低于<code>30</code>度，在<code>zabbix</code>中怎样表达呢？在<code>zabbix</code>中，我们可以这样描述：养鸡场温度 &lt; <code>30</code></p>
<p>没错，就是这么简单，而’养鸡场温度 &lt; <code>30</code>‘不过是一个数学上的’比较表达式’而已，这个表达式，在<code>zabbix</code>中被称为’触发器’(<code>Triggers</code>)，换种角度解释，我们还可以从字面上理解’触发器’，触发器是会被触发的机器，但是只有满足触发条件时，触发器才会被触发，当触发器被触发以后，会产生某个’事件’(<code>Events</code>)，比如，当养鸡场温度低于<code>30</code>度时，红灯会亮起，那么’红灯亮起’就可以理解为’养鸡场温度 &lt; <code>30</code>‘这个’触发器’所产生的’事件’，当温度低于<code>30</code>时，触发器的条件被满足，就会产生’红灯事件’，当’红灯事件’产生以后，工作人员就会采取相应的措施，比如通知老板或者打开暖气，那么，’打开暖气’或者’报告老板’的一系列措施，在<code>zabbix</code>中被称为’动作’(<code>Actions</code>)。好了，我想我已经解释清楚了，为了解决这些概念，还要描述怎么养鸡，真实不容易~</p>
<p>那么，我们现在抛开’养鸡场’的概念，纯粹的总结一边<code>zabbix</code>中的触发器、事件、动作等相关概念</p>
<p><strong>触发器(<code>Triggers</code>)</strong>：我们可以把<code>zabbix</code>的触发器理解成一个条件表达式，我们往往通过触发器定义被监控项的阈值，当触发器对应的表达式被满足时，则代表被监控项达到了我们设定的阈值，也就意味着发生了我们不想要遇到的问题，换句话说，当监控项的值处于合理范围时，触发器不会被触发，当监控项的值超出合理范围(即达到阈值)，触发器则会被触发，当触发器被触发时，往往代表着出现了问题，触发器未被触发时，其的状态为’<code>OK</code>‘，当触发器被触发时，触发器的状态为’<code>Problem</code>‘，当被监控项的值达到阈值时，触发器的状态’<code>OK</code>‘变为’<code>Problem</code>‘，当监控项的值再次回归到合理范围时，触发器的状态会从’<code>Problem</code>‘转换回’<code>OK</code>‘</p>
<p><strong>事件(<code>Events</code>)</strong>：当触发器的状态发生改变时，则会产生对应的’事件’，当然，由触发器的状态改变而产生的事件被称为’触发器事件’，<code>zabbix</code>中，事件分为几种类型，除了’触发器事件’，还有一些别的事件，此处为了方便描述，暂且不提及它们，我们可以把’事件’大概理解成一个重要的事情</p>
<p><strong>动作(<code>Actions</code>)</strong>：当某个事件产生时，需要对应的处理措施，这种处理措施被称为动作</p>
<p>好了，这篇文章中，我们只是大概的描述了触发器、事件、动作的相关概念，但是并没有实际使用它们，我们会在以后的文章中，给出对应的应用示例，并且在实际使用时再更加详细的了解它们</p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix(5)：zabbix添加带有参数的监控项</title>
    <url>/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/</url>
    <content><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote>
<p>在前文中，我们已经解释了’监控项’(<code>item</code>)、’键’(<code>key</code>)、’应用集’(<code>application</code>)等概念，并且为<code>testzabbix1</code>主机添加了一个监控项，其作用是监控主机的<code>cpu</code>上下文切换速率</p>
<p>这次，我们再为<code>testzabbix1</code>主机添加一个监控项，用于监控磁盘分区的使用率，因为创建监控项的过程我们在前文已经详细的演示过，重复的地方我们就不再赘述，这次创建的监控项与上次创建的监控项只有些许不同而已，我会重点介绍它们的不同之处</p>
</blockquote><a id="more"></a>
<blockquote>
<p>点击<code>zabbix</code>控制台的’配置’—-‘主机’，点击<code>testzabbix1</code>主机的监控项</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-1.jpg" alt="5-1"></p>
<blockquote>
<p>点击’创建监控项’按钮</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-2.jpg" alt="5-2"></p>
<blockquote>
<p>假设我们想要监控<code>testzabbix1</code>主机上的’根分区’的磁盘使用率，所以，我们命名监控项名称为<code>RootPartitionUsed</code></p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-3.jpg" alt="5-3"></p>
<blockquote>
<p>我们说过，如果想要获取监控指标的数据，可以通过指定的<code>key</code>获取，如果<code>zabbix</code>自带的<code>key</code>不能满足我们，我们可以自定义<code>key</code>，而此处，我们的需求是监控根分区磁盘使用率，而<code>zabbix</code>自带的<code>key</code>中，正好有一个<code>key</code>能够获得某个磁盘分区的使用率，所以，我们点击上图中的’选择’按钮</p>
</blockquote>
<blockquote>
<p>点击选择按钮以后，从列表中找到如下图中的键，键名为’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘，从解释中可以了解到，通过这个键获取到信息与磁盘容量相关</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-4.jpg" alt="5-4"></p>
<blockquote>
<p>细心的你一定发现了，我们这次选择的’键’与上一次选择的’键’有哪些地方好像不太一样，没错，格式好像不太一样</p>
<p>我们来对比一下，上次，我们为了监控<code>cpu</code>的上下文切换次数，选择了如下键</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-5.jpg" alt="5-5"></p>
<blockquote>
<p>而这次，为了监控磁盘分区的使用率，我们选择了如下键</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-6.jpg" alt="5-6"></p>
<blockquote>
<p>这次我们选择的键，除了键名以外，还多出了传入参数的位置</p>
<p>对于’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘这个键来说，’<code>vfs.fs.size</code>‘就是键名，’<code>[fs,&lt;mode&gt;]</code>‘就是这个键需要的参数</p>
<p>而’<code>[fs,&lt;mode&gt;]</code>‘这两个参数中，<code>fs</code>是不可省参数，<code>mode</code>是可省参数</p>
<p>聪明如你一定已经发现了，如果参数被尖括号括起，则代表这个参数是可省参数，例如上述的&lt;<code>mode</code>&gt;，如果参数没有被尖括号括起，则代表是不可省参数，例如上述的<code>fs</code></p>
</blockquote>
<blockquote>
<p>那么这个键到底怎么使用呢，<code>fs</code>和<code>mode</code>这两个参数分别代表了什么呢，我们可以通过官网帮助手册，查看这些’键’的含义与使用方法</p>
<p><code>zabbix3.0</code>版本的所有’键’的含义及用法的官方在线手册地址如下</p>
<p><code>https://www.zabbix.com/documentation/3.0/manual/config/items/itemtypes/zabbix_agent</code></p>
<p>打开上述网址后，查询对应’键’的名称，从在线帮助手册中可以看到，这个键的描述，返回值，参数的含义与值，以及示例等信息</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-7.jpg" alt="5-7"></p>
<blockquote>
<p>从上图可以看出，用过这个键，获取的返回信息可以有两种类型，一种是整形，一种是浮点型，这取决于我们需要获取哪种信息，如果是获取磁盘的使用百分比，则会返回给我们浮点型，如果是获取使用量，则会返回整形，代表使用了多少<code>bytes</code>，上图中解释了两个参数的用法，<code>fs</code>代表对应的文件系统，我们可以理解为对应的文件系统所在的分区，<code>mode</code>的值可以为<code>total</code>，<code>free</code>，<code>used</code>，<code>pfree</code>，<code>pused</code>，分别表示获取对应文件系统的总大小(省略<code>mode</code>参数时，此为默认值)，空余空间大小，已经使用的空间的大小，空闲率和使用率，还记得这个键返回的两种数据类型吗，如果我们将<code>mode</code>设置为<code>total</code>，<code>free</code>，<code>used</code>，那么，这个键返回的数据类型将为整形(就是一个整数)，如果我们将<code>mode</code>设置为<code>pfree</code>或者<code>pused</code>，那么这个键返回的信息的数据类型就是浮点型(带有小数点的数字)。而且，帮助文档中还给出了这个’键’的使用示例，<code>vfs.fs.size[/tmp,frss]</code>，示例表示获取/<code>tmp</code>所对应的文件系统的剩余空间大小</p>
</blockquote>
<blockquote>
<p>好了，我们大概对<code>vfs.fs.size[fs,&lt;mode&gt;]</code>这个键有了一些了解，通过这个键，可以获取到文件系统对应分区的磁盘空间使用情况信息，我们可以通过<code>fs</code>参数指定对应的文件系统，通过<code>mode</code>参数，指定我们想要获取的信息的格式，还记得我们上次使用的<code>zabbix_get</code>命令吗，没错，我们现在<code>server</code>端，通过命令行测试一下，试试能否通过<code>zabbix_get</code>，调用对应的键，获取对应的磁盘信息，在<code>server</code>端执行如下命令</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-8.jpg" alt="5-8"></p>
<blockquote>
<p>上图中，我们使用了<code>zabbix_get</code>命令，调用了<code>vfs.fs.size</code>这个键，并且指定了对应的文件系统，我们指定<code>fs</code>参数的值为’<code>/</code>‘，而我们并没有设置<code>mode</code>参数的值，我们说过，<code>mode</code>参数是可省参数，当<code>mode</code>参数省略时，默认值为<code>total</code>，表示获取对应文件系统的总大小，由于是以字节为单位，所以返回的数值比较大，换算成<code>G</code>，应该为<code>39.2G</code>，那么我们到<code>agent</code>端验证一下，看看其’根分区’的大小是否与此值相同，如下命令在<code>agent</code>端执行</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-9.jpg" alt="5-9"></p>
<blockquote>
<p>可以看到，被监控主机的根分区大小为<code>40G</code>，与<code>39.2G</code>相差一点，这是因为换算的关系引起的，我们可以认为，我们获得到的信息是没有错的</p>
<p>那么，我们再次在<code>server</code>端执行如下几条命令，这次，我们设置了<code>mode</code>参数的值</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-10.jpg" alt="5-10"></p>
<blockquote>
<p>上图中的三条命令分别获取了根分区的使用量，空余量，以及磁盘使用率</p>
<p>好了，经过测试，通过’<code>vfs.fs.size[fs,&lt;mode&gt;]</code>‘这个键，的确能够获得磁盘的使用情况统计信息，那么，我们回到我们的监控项配置页面</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-11.jpg" alt="5-11"></p>
<blockquote>
<p>当我们选择了对应的键以后，我们还需要做出适当的修改，将其参数值改成我们所需要的值，如下</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-12.jpg" alt="5-12"></p>
<blockquote>
<p>由于我们获取的数据为根分区的使用率，返回的信息为浮点型，所以，信息类型选择浮点型，由于返回的信息为磁盘使用率，所以单位设置为’<code>%</code>‘</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-13.jpg" alt="5-13"></p>
<blockquote>
<p>好了，其他的设置我们在前一篇文章中已经解释过了，此处不再赘述，但是为了演示方便，我并没有将数据更新间隔设置为<code>3600</code>，而是设置<code>10</code>秒收集一次磁盘数据，再次强调，这样设置只是为了快速获取演示效果，生产环境中对于类似这样的数据不要监控的如此频繁，配置如下后，点击添加按钮</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-14.jpg" alt="5-14"></p>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-15.jpg" alt="5-15"></p>
<blockquote>
<p>监控项添加完毕后，等待一分钟左右，查看对应的监控数据，如下，点击监控项对应的’图形’连接</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-16.jpg" alt="5-16"></p>
<blockquote>
<p>可以看到，监控到的磁盘使用率为<code>16.88%</code>，而且界面上显示的单位也是’<code>%</code>‘，还记得我们在监控项中配置的单位吗，就是这个作用，如果数据较多，我们可以拖动监控视图的’镜头’，调整’镜头’的远近以及位置，即可看到不同时间段的监控数据，但是因为我们磁盘使用率一直没有多大变化，所以，看不出镜头移动时的效果，如果是长时间的波动的数据，拖动镜头时的效果则比较明显</p>
</blockquote>
<p><img src="/2010/01/09/zabbix%E6%B7%BB%E5%8A%A0%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9/5-17.jpg" alt="5-17"></p>
<blockquote>
<p>这次，我们又添加了一个监控项，只是与上一次相比，我们这次添加的监控项可以传入参数</p>
<p>而且，我们已经了解到，如果想要搞明白<code>zabbix</code>的各种自带<code>key</code>的作用，可以参考<code>zabbix</code>官方在线手册</p>
<p><code>https://www.zabbix.com/documentation/3.0/manual/config/items/itemtypes/zabbix_agent</code></p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix(4)：zabbix添加监控项</title>
    <url>/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/</url>
    <content><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote>
<p>前文中，已经描述了怎样在<code>zabbix</code>中添加主机，但是，我们并没有对主机进行任何指标的实际监控，那么现在，我们来说说，具体怎样监控我们想要监控的指标</p>
</blockquote><a id="more"></a>
<blockquote>
<p>在具体操作之前，我们先聊聊理论，假设我们想要监控磁盘的使用率，在没有<code>zabbix</code>这种监控工具时，我们该怎样监控呢，再或者，我们不仅没有<code>zabbix</code>这种监控工具，我们也不会写脚本，更不会写任何程序，我们该如何监控磁盘的使用率呢。没错，人工监控，当我们无法依赖任何工具或者脚本等外部助力时，我们只能不停的看着屏幕，查看当前磁盘的使用率，如果磁盘使用率达到了我们设定的阈值，我们就会作出相应的处理动作。即使我们是通过人工完成监控的，我们也要想办法能够获取到被监控目标的数据，比如我们想要监控磁盘使用率，那么我们就要不停的获取磁盘的使用率信息，以便我们能够随时的了解磁盘的空间使用情况，那么我们怎样获取磁盘的使用率呢，就拿<code>Centos</code>为例，我们可能会通过如下命令，获取每个分区的磁盘使用率</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-1.jpg" alt="4-1"></p>
<blockquote>
<p>没错，我们通过命令，获取到了磁盘使用率的信息，当然，这个命令比较简短，方便我们从键盘键入，如果一条简单的命令，无法获取到磁盘使用率的信息呢，那么我们可能会通过一条稍微复杂的命令去实现监控，比如，如果我们只想要监控’根分区’磁盘使用率，我们可能会使用如下命令实现</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-2.jpg" alt="4-2"></p>
<blockquote>
<p>我们发现，获取监控信息的命令越来越长了，那么我们能不能尽量简化这些较长的命令呢，必须能啊，设置个别名不就行了，那么，我们把刚才的命令设置一个别名，直接执行命令别名试试</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-3.jpg" alt="4-3"></p>
<blockquote>
<p>可以看到，原本比较长的命令只缩减为了<code>rdu</code>三个字符。是不是比原来方便了许多呢，我们只需要三个字符，就能获取根分区的使用情况</p>
<p>这个时候，你可能会问，<code>linux</code>的命令别名与<code>zabbix</code>的监控项由关系吗，我们是来看怎么添加<code>zabbix</code>监控项的，不是来听你瞎BB的</p>
<p>好吧，其实它们并没有什么关系，但是它们有一些类似的地方，比如，我们刚才做的工作，无非就是获取监控信息，需要获取监控信息，就要执行对应的命令，我们也可以通过别名，调用对应的命令，从而获取到我们想要或得到的监控信息，在<code>zabbix</code>中，我们要监控的某一个指标，被称为’监控项’，就像我们的磁盘使用率，在<code>zabbix</code>中就可以被认为是一个’监控项’(<code>item</code>)，如果要获取到’监控项’的相关信息，我们则要执行一个命令，但是我们不能直接调用命令，而是通过一个’别名’去调用命令，这个’命令别名’在<code>zabbix</code>中被称为’键’(<code>key</code>)，所以，在<code>zabbix</code>中，如果我们想要获取到一个’监控项’的值，则需要有对应的’键’，通过’键’能够调用相应的命令，获取到对应的监控信息，我们暂且这样理解，方便我们入门</p>
</blockquote>
<blockquote>
<p>好了，此处我们又提到了两个新的术语，我们来总结一遍</p>
<p>监控项(<code>item</code>)：某个监控指标，在<code>zabbix</code>中被称之为一个<code>item</code>，某个主机中可能有多个需要被监控的指标，也就是说，某个<code>host</code>中可能有多个<code>item</code></p>
<p>键(<code>key</code>、<code>item key</code>)：如果想要获取监控项对应的数据，则必须通过某个<code>key</code>去获取，我们可以把<code>key</code>想象成调用对应命令的’命令别名’，<code>zabbix</code>中自带一些<code>key</code>，这些<code>key</code>往往比较通用，比如，通过这些<code>key</code>，我们可以监控<code>cpu</code>，内存，硬盘等常用指标，获取不同的指标信息，需要不同的<code>key</code>，但是如果这些自带的<code>key</code>无法满足我们的监控需求时，我们也可以自定义<code>key</code>，通过自定义<code>key</code>执行对应的操作，这些都是后话，我们慢慢来</p>
</blockquote>
<blockquote>
<p>好了，说了这么多，哥们你应该有点印象了，话接上回，我们已经在<code>zabbix</code>中添加了一台主机，现在，我们继续在这台主机上操作</p>
<p>首先，打开我们<code>zabbix</code>控制台，点击’配置’–’主机’，可以看到我们上次创建的主机，虽然我们为对应的被监控主机安装了<code>agent</code>，但是主机对应的<code>ZBX</code>仍然显示为灰色，代表我们还没有任何监控项被检测到，那么现在，我们来为<code>testzabbix1</code>主机添加一个监控项</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-4.jpg" alt="4-4"></p>
<blockquote>
<p>点击<code>testzabbix1</code>主机上的’监控项’，如下图所示位置</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-5.jpg" alt="4-5"></p>
<blockquote>
<p>进入监控项配置界面后，可以根据一些条件，筛选出已经存在的一些监控项，但是我们并没有任何监控项，所以此处，我们直接点击’创建监控项’按钮，以便新建监控项</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-6.jpg" alt="4-6"></p>
<blockquote>
<p>假如，现在我们想要监控<code>testzabbix1</code>这台主机的<code>CPU</code>的上下文切换此处，那么我们可以在此界面进行如下配置</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-7.jpg" alt="4-7"></p>
<blockquote>
<p>首先，在名称文本框中设置监控项的名称，我们此处监控的指标为<code>cpu</code>上下文切换此处，所以，命名此监控项为’<code>cpu context switches</code>‘</p>
<p>因为我们在<code>testzabbix1</code>这台主机上安装了<code>zabbix agent</code>，所以，此处类型保持默认，选择<code>zabbix</code>客户端</p>
<p>在键值一栏中，我们可以选择对应的<code>key</code>，也就是说，我们通过哪个<code>key</code>，获取到<code>cpu</code>的上下文切换次数的信息，所以，点击’选择’按钮，点击选择按钮以后，可以看到非常多的预先定义好的<code>key</code>，这些<code>key</code>都是<code>zabbix</code>自带的<code>key</code>，这些<code>key</code>一般都是系统级别的通过的监控项所能够用到的<code>key</code>，如果这些’键’不能满足我们的需求，我们则需要自定义<code>key</code>，这是后话，到时再聊，此处，我们选择<code>system.cpu.switches</code></p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-8.jpg" alt="4-8"></p>
<blockquote>
<p>选择完成后，可以看到，<code>key</code>的值已经自动填充到了’键值’的文本框中</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-9.jpg" alt="4-9"></p>
<blockquote>
<p>在继续操作之前，我们来插入一段概念</p>
<p>我们在介绍<code>zabbix</code>的概念时已经说过：管理员可以在<code>server</code>端使用一个名为<code>zabbix_get</code>的工具，测试是否能够从<code>agent</code>端拉取数据</p>
</blockquote>
<blockquote>
<p>其实，我们可以先通过命令行，看看对应的’键’返回的信息到底是什么样子的</p>
<p>我们在<code>server</code>端，使用如下命令，获取一下<code>system.cpu.switches</code>这个键对应的值</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-10.jpg" alt="4-10"></p>
<blockquote>
<p>上图中，我们在<code>server</code>端通过<code>zabbix_get</code>命令，使用<code>system.cpu.switches</code>这个’键’，获得了<code>47.96.189.157</code>这台主机上的<code>cpu</code>上下文切换次数</p>
<p>通过<code>-s</code>选项指定被监控主机的<code>IP</code>，通过<code>-k</code>选项指定对应的<code>KEY</code>，即可获得对应主机的对应监控指标的信息</p>
<p>那么，我们多运行两个这个命令</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-11.jpg" alt="4-11"></p>
<blockquote>
<p>可以看到，<code>cpu</code>的上下文切换次数是在不停的增长的，而且返回的值是一个整数</p>
</blockquote>
<blockquote>
<p>好了，回到我们的图形化配置界面，继续看我们的监控项配置</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-12.jpg" alt="4-12"></p>
<blockquote>
<p>我们就是通过<code>agent</code>接口监控数据的，<code>agent</code>监听在<code>10050</code>端口上，此处保持默认即可</p>
<p>而我们刚才也看到了，通过<code>zabbix_get</code>获取到的<code>system.cpu.switches</code>的数据，都是一些十进制的整数，所以，信息类型选择数字，数据类型选择十进制</p>
<p>数据更新间隔表示每隔多长时间获取一次监控项对应的数据，为了演示方便，能够尽快获取到数据，我们设定为每隔<code>30</code>秒获取一次监控信息，此处表示每隔<code>30</code>秒获取一次<code>47.96.189.157</code>主机的<code>cpu</code>上下文切换次数。但是需要注意，在生产环境中，如果不是特别重要的、敏感的、迅速变化的数据，不要获取的这么频繁，因为如果我们的监控项变得特别多时，获取信息的时间间隔过于频繁会带来巨大的监控压力，同时对数据库的写入也是一种考验</p>
<p>当然，我们也可以灵活的定义时间间隔，比如，周一到周五我们的业务量比较少，可以<code>10</code>分钟获取一次数据，而周六周日的业务量会剧增，为了实时监控，可以设置<code>5</code>分钟获取一次数据，这里只是举个例子，如果有类似的需求，可以通过’自定义时间间隔’配置段，添加不同时间段的不同监测频率</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-13.jpg" alt="4-13"></p>
<blockquote>
<p>因为我们每隔<code>30</code>秒就获取一次数据，那么这些数据都会编程历史数据，存入数据库中，通过上图中的历史数据文本框，可以设置历史数据的保存时长</p>
<p>上图中，我们设置历史数据保存<code>8</code>天，此监控项超过<code>100</code>天的数据将会被<code>zabbix</code>删除</p>
<p>从上图中，还可以看到有一个趋势数据保存天数，趋势数据时什么意思呢？趋势数据就是每个小时收集到的历史数据中的最大值、最小值，平均值以及每个小时收集到的历史数据的数量，所以，趋势数据每小时收集一次，数据量不会特别大，一般情况下，历史数据的保留时间都比趋势数据的保留时间短很多，因为历史数据比较多，如果我们监控的主机非常多，而且监控的频率特别频繁，那么数据库的压力则会变得非常大</p>
</blockquote>
<blockquote>
<p>继续向下看，可以看到存储值与查看值两个下拉框</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-14.jpg" alt="4-14"></p>
<blockquote>
<p>我们点开存储值下拉框，可以看到三个选项，不变、差量(每秒速率)、差量(简单变化)</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-15.jpg" alt="4-15"></p>
<blockquote>
<p>那么，这些值都是什么意思呢，我们慢慢说</p>
<p>不变：表示获取到的值是什么样子的，就在数据库中存储为什么样子</p>
<p>差量(简单变化)：表示本次收集到的信息值减去上一次收集到的信息值得出的差值</p>
<p>差量(每秒速率)：表示本次收集到的值 减去上次收集到的值以后，再除以两次收集信息的间隔时间</p>
<p>而此处，我们监控的指标为<code>cpu</code>上下文切换次数，这是一个不断增长的整数值，所以，我们选择’差量(每秒速率)’最为合适</p>
<p>这样我们就能够监控到不同时间段内<code>cpu</code>上下文切换的频率了</p>
</blockquote>
<blockquote>
<p>那么查看值是什么意思呢？查看值可以改变监控数据的展示方式，以便监控人员更容易理解，此处我们保持默认即可，在实际用到时我们再做解释</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-16.jpg" alt="4-16"></p>
<blockquote>
<p>新的应用集与应用集是什么意思呢？</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-17.jpg" alt="4-17"></p>
<blockquote>
<p>我们可以把’应用集’理解为同一类型的监控项的集合，’应用集’英文原词为<code>application</code>，<code>application</code>为一组<code>item</code>(监控项)的集合，比如，我们有<code>3</code>个监控项，它们分别监控’磁盘使用率’，’磁盘写入速率’，’磁盘读取速率’，虽然它们监控的指标不同，但是他们都是监控’磁盘’的监控项，所以，我们可以把它们归类为’磁盘’应用集，同理，如果有<code>2</code>个监控项，一个是监控<code>nginx</code>连接数量的，一个是监控<code>nginx</code>请求数量的，虽然它们监控的指标不同，但是它们都是监控<code>nginx</code>相关指标的，所以，我们可以把它们归为<code>nginx</code>应用集</p>
<p>但是，由于我们没有创建过任何应用集，所以上图中，应用集选择框中没有任何可选应用集，如果没有可选的合适的应用集，我们可以直接在’新的应用集’文本框中填入要创建的应用集名称，那么对应应用集会自动被创建，当前监控项也会自动归类为这个应用集</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-18.jpg" alt="4-18"></p>
<blockquote>
<p>继续聊，’填入主机资产记录栏位’我们后面再聊</p>
<p>描述信息栏填写关于这个监控项的相关描述</p>
<p>‘已启用’默认被勾选，表示此监控项被创建后，立即生效，即创建此监控项后立即开始监控</p>
</blockquote>
<blockquote>
<p>好了，监控项的配置我们已经解释的七七八八了，示例配置如下，点击添加按钮，注：为了更快的获取演示效果，此处将数据更新间隔设置为<code>5</code>秒，但是生产环境中请仔细考虑具体设置为多少秒比较适合生产环境的需求</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-19.jpg" alt="4-19"></p>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-20.jpg" alt="4-20"></p>
<blockquote>
<p>点击添加按钮以后，可以看到，<code>testzabbix1</code>主机的第一个监控项已经被添加，而且处于已启用状态</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-21.jpg" alt="4-21"></p>
<blockquote>
<p>点击监控项旁边的’应用集’</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-22.jpg" alt="4-22"></p>
<blockquote>
<p>可以看到，应用集中已经存在了<code>cpu</code>应用集，而且这个应用集中已经存在一个监控项，就是我们刚才创建的’<code>cpu context switches</code>‘监控项</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-23.jpg" alt="4-23"></p>
<blockquote>
<p>我们已经创建了一个监控项，那么怎样查看这个监控项的监控情况呢，点击’检测中’—-‘最新数据’，但是目前并没有展示出任何数据，因为我们还没有指定要查看哪些监控数据</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-24.jpg" alt="4-24"></p>
<blockquote>
<p>我们可以输入过滤条件，过滤出我们想要查看的数据，比如，我们选择根据主机过滤，过滤出对应主机的对应的监控项数据</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-25.jpg" alt="4-25"></p>
<blockquote>
<p>从对应的主机组中找到对应的主机</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-26.jpg" alt="4-26"></p>
<blockquote>
<p>选择主机以后点击过滤</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-27.jpg" alt="4-27"></p>
<blockquote>
<p>点击过滤按钮以后，应该可以看到我们刚才创建的监控项，已经存在了部分数据，如果你刚刚创建完监控项，不要着急的立马查看’监控项’数据，因为它可能需要一段时间收集数据</p>
<p>但是，如果超出正常收集数据的时间后，很长时间以内仍然无法收集到数据，那么有可能是因为<code>agent</code>端与<code>server</code>端时间不同步引起的，请确定你的<code>agent</code>端与<code>server</code>端的时间是同步的</p>
<p>可以看到，’<code>cpu context switches</code>‘这个监控项已经存在数据，我们点击对应的’图形’连接</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-28.jpg" alt="4-28"></p>
<blockquote>
<p>点击上图中的’图形’连接们可以看到如下界面，<code>zabbix</code>已经监控到了对应的<code>cpu</code>上下文切换频率，并且绘制出了对应的’图形’</p>
</blockquote>
<p><img src="/2010/01/07/zabbix%E6%B7%BB%E5%8A%A0%E7%9B%91%E6%8E%A7%E9%A1%B9/4-29.jpg" alt="4-29"></p>
<blockquote>
<p>从上图中，可以看到，<code>zabbix</code>除了为我们绘制出了图形以外，还显示出了最大值、最小值、平均值等信息，上图中，正常显示为中文</p>
<p>如果你的界面不能正常显示中文，那么证明你没有上传中文字体，或者没有正确的配置显示字体选项，我们在安装<code>zabbix</code>的文章中已经描述了解决问题的过程，此处不再赘述</p>
<p>我们已经为主机添加了第一个监控项，并且已经成功监控到了对应的数据，好了，我们已经入门了</p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix(3)：zabbix添加主机</title>
    <url>/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote>
<p>在前文中，我们已经介绍过了<code>zabbix</code>是什么，以及怎样安装<code>zabbix</code>环境，那么现在，我们应该开始实际动手使用<code>zabbix</code>了，为了能让大家更加容易理解实际使用过程中将会用到的术语以及概念，我们先把实际工作场景描述清楚，然后再根据描述的工作场景进行演示</p>
</blockquote><a id="more"></a>
<blockquote>
<p>假设，我们想要使用<code>zabbix</code>监控一台<code>linux</code>服务器，那么，我们肯定要将这个服务器纳入<code>zabbix</code>的管理范围，而’添加主机’这个操作，就是将被监控的主机纳入<code>zabbix</code>管理范围的一个必须操作，如果我们有<code>10</code>台主机都需要被<code>zabbix</code>监控呢，没错，这<code>10</code>台主机都必须被添加到<code>zabbix</code>的监控列表中，在<code>zabbix</code>中，我们将被监控的对象称之为’主机’，’主机’不一定是服务器，也可以是路由器，交换机等网络设备，而且，根据主机的属性、角色、特征的不同，我们还能够将主机分组，比如，我们有<code>10</code>台服务器，<code>10</code>台服务器中，有<code>3</code>台<code>windows</code>服务器，有<code>7</code>台<code>linux</code>服务器，那么，我们可以按照操作系统的不同，将他们分为两组，<code>windows</code>服务器组与<code>linux</code>服务器组，或者我们不按照操作系统对主机进行分组，而是根据服务器的角色对主机分组，比如，一共<code>10</code>台服务器，<code>3</code>台是提供<code>ldap</code>服务的，<code>2</code>台是提供<code>web</code>服务的，<code>5</code>台是提供数据库服务的，我们也可以把它们按照角色分成<code>3</code>组，<code>ldap</code>主机组、<code>web</code>主机组、<code>db</code>主机组，当然，我们只是举个例子，实际应用中，具体怎样分组，是根据实际需求视情况而定的，那么，为什么要将主机分组呢，这是为了方便管理，因为同一类主机需要被监控的指标很有可能都是相同的，所以将它们分为一组方便管理，这是后话，我们到时候再聊</p>
</blockquote>
<blockquote>
<p>上面一段话中，我们提到了两个<code>zabbix</code>的常用术语，’主机’与’主机组’，我们再来总结一遍</p>
<ol>
<li><code>host</code>(主机)：需要被<code>zabbix</code>监控的对象，被称为主机，主机必须属于某个主机组</li>
<li><code>hostgroup</code>(主机组)：’主机组’也被称为’主机群组’，是由具有相同属性、特征、角色的多个主机组成的逻辑单元</li>
</ol>
</blockquote>
<blockquote>
<p>好了，理解上述两个术语，并且能够在<code>zabbix</code>中是同它们，就是我们这篇文章所要达到的目标</p>
<p>那么，我们来看看怎样在<code>zabbix</code>中添加一台主机，在动手添加主机之前，先说明一下我们的环境</p>
<p>我们已经将<code>zabbix-server</code>、<code>zabbix-database</code>、<code>zabbix-web</code>安装在了<code>116.62.188.230</code>上</p>
<p>同时，我们将<code>zabbix-agent</code>安装在了<code>47.96.189.157</code>上</p>
<p>所以此处，<code>47.96.189.157</code>就是被监控的对象，我们需要将<code>47.96.189.157</code>添加为<code>zabbix</code>主机</p>
</blockquote>
<blockquote>
<p>好了，跟我一起搞起来，首先，打开我们的<code>zabbix web</code>控制台，我们看看都有哪些’主机组’</p>
<p>点击’配置’—-‘主机群组’，可以看到，系统默认已经为我们准备了一些主机组，如果这些主机组不满足我们的需要，我们也可以创建新的主机组，点击下图中的’创建主机群组’按钮，即可创建主机组，但是，现在我们还不用深入研究主机组，此处只是让大家了解一下，对主机组有一个初步的认识即可</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-1.jpg" alt="3-1"></p>
<blockquote>
<p>同样，点击’配置’—-‘主机’，即可查看已经被加入<code>zabbix</code>主机列表的主机，可以看到，<code>zabbix</code>默认将<code>zabbix server</code>添加为了一台主机，以便可以自己监控自己，但是此处，我们需要添加一台我们自己的主机，就是<code>47.96.189.157</code>，点击’创建主机’，点击创建主机之前，可以选择左侧的’群组’下拉菜单，以确定将要创建的主机所在的主机组，当然，我们也可以先不选主机组，直接点击’创建主机’按钮</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-2.jpg" alt="3-2"></p>
<blockquote>
<p>点击’创建主机’按钮以后，即可看到类似如下界面，为了更好的描述每个步骤，具体解释参考下图后面的注释列表</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-3.jpg" alt="3-3"></p>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-4.jpg" alt="3-4"></p>
<ol>
<li>我们可以在主机名称的文本框中填写被监控主机的主机名称</li>
<li>‘可见名称’一般使用简短的、易读的、见名知义的名称表示主机即可</li>
<li>我们可以选择将要创建的主机属于哪个主机组，当然，如果没有合适的主机组，我们也可以直接在创建主机时，直接新建主机组，我们说过，每个主机必须存在于某个主机组中，所以，主机组是必须的</li>
<li>如果在’3’的位置没有对应的、可用的、合适的主机组，我们可以直接在’新的群组’中创建符合当前主机需要的主机组</li>
<li>选择通过哪种接口监控当前主机，可选的方式有<code>IPMI</code>接口、<code>JMX</code>接口、<code>SNMP</code>接口、<code>agent</code>接口，我们说过，’主机’在<code>zabbix</code>中，可以是服务器，路由器，交换机等等硬件设备，有的硬件设备只支持某种接口，所以，当我们添加主机时，会让我们选择通过哪种合适的接口监控它，具体各接口的使用场景我们已经在第一篇介绍<code>zabbix</code>概念的文章中描述过，此处不再赘述，当然，如果一台自助机能被多种接口所监控，也可以同时配置多个接口监控这台主机，但是当前，我们需要监控的主机是一台<code>linux</code>服务器，而且已经安装了对应的<code>agent</code>端，所以，此处，我们只使用<code>agent</code>接口对当前主机进行监控，而使用<code>agent</code>接口时，可以通过<code>IP</code>连接到对应<code>agent</code>，也可以使用主机名连接到对应<code>agent</code>，而此处，我们选择使用<code>IP</code>地址连接到对应的<code>agent</code>，<code>IP</code>地址就是我们将要添加的主机的<code>IP</code>，<code>47.96.189.157</code>，对应端口为默认的<code>10050</code>，如果你想要使用主机名连接到对应的<code>agent</code>，那么需要保证主机名能够被正常解析到<code>47.96.189.157</code>上，此处不再赘述，如果有多个<code>IP</code>可以连接到对应<code>agent</code>，可以点击’添加’，添加一条新的<code>IP</code></li>
<li>对将要添加的主机进行描述，添加相应的描述信息即可</li>
<li>表示是否使用<code>zabbix proxy</code>监控当前主机，虽然上图中，此处翻译为’由<code>agent</code>代理程序检测’，但是实际是用于指定<code>zabbix proxy</code>的，与<code>zabbix agent</code>并没有关系，但是因为我们没有配置<code>zabbix proxy</code>，所以此处保持默认即可</li>
</ol>
<blockquote>
<p>好了，按照上述界面中的配置进行设置以后，点击’添加’按钮，即可简单的添加一台主机，可以看到，<code>47.96.189.157</code>已经被添加到了主机列表中</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-5.jpg" alt="3-5"></p>
<blockquote>
<p>而且，如果此时我们再次查看主机组，已经发现，<code>Zabbix test</code>主机组已经被添加了，而且其中的成员已经包含了<code>testzabbix1</code>主机</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-6.jpg" alt="3-6"></p>
<blockquote>
<p>回到主机列表，可以看到我们刚才添加的<code>testzabbix1</code>主机，但是<code>testzabbix1</code>主机的’可用性’对应的<code>4</code>种接口都是灰色的</p>
</blockquote>
<p><img src="/2010/01/05/zabbix%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA/3-7.jpg" alt="3-7"></p>
<blockquote>
<p>上图中，<code>ZBX</code>就代表<code>agent</code>接口，虽然我们在添加主机时，配置了通过<code>agent</code>监控对应主机，但是，由于我们并没有配置监控主机的任何指标，所以，<code>ZBX</code>仍然是灰色的，也就是说，我们现在只是将<code>47.96.189.157</code>加入了<code>zabbix</code>的监控范围，但是并没有对它进行任何实际的监控，因为我们还没有配置任何’监控项’，至于怎样配置监控项，且听下回分解</p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix(2)：Zabbix安装</title>
    <url>/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><blockquote>
<p>我们在上一篇介绍<code>zabbix</code>的基本概念的文章中已经描述过，<code>zabbix</code>的几个常用的重要组件，在安装<code>zabbix</code>时，其实就是在安装这些组件</p>
<p>由于我们的监控规模并不庞大，所以此处不会安装<code>zabbix proxy</code>，我们将会安装如下组件：</p>
<p><code>zabbix server</code></p>
<p><code>zabbix database</code></p>
<p><code>zabbix web</code></p>
<p><code>zabbix agent</code></p>
</blockquote><a id="more"></a>
<blockquote>
<p>此处我们将要安装的<code>zabbix server</code>版本为<code>zabbix3.0.7</code></p>
<p>如果你想要无痛的跟随本博客中的步骤进行练习，请安装3.0版本的<code>zabbix</code></p>
<p>因为<code>zabbix3.X</code>依赖的<code>php</code>版本不能低于<code>php5.4</code>，而<code>centos6.8</code>中，<code>php</code>默认版本为5.3</p>
<p>如果你想要使用<code>centos6.X</code>的操作系统，同时想要更加方便的升级<code>php</code>，可以使用<code>Remi</code>源升级<code>php</code></p>
<p>但是为了更加方便的使用yum源安装相关软件包，此处使用7.3安装<code>zabbix3.0.7</code></p>
</blockquote>
<blockquote>
<p>首先，为了方便安装，配置<code>zabbix</code>的官方<code>yum</code>源</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-1.jpg" alt="2-1"></p>
<blockquote>
<p>我们配置了<code>zabbix3.0</code>的<code>yum</code>源</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-2.jpg" alt="2-2"></p>
<blockquote>
<p>同时，我们配置了base源与epel源，因为安装过程中会用到这些yum源</p>
<p>准备工作完毕，剩下的就是安装各个组件了</p>
</blockquote>
<h5 id="安装zabbix-server"><a href="#安装zabbix-server" class="headerlink" title="安装zabbix server"></a>安装<code>zabbix server</code></h5><blockquote>
<p>我们先从<code>zabbix server</code>开始安装，由于我们使用<code>mysql</code>作为数据库，所以，在安装<code>zabbix3.X</code>的版本的<code>server</code>端时，需要安装<code>zabbix-server-mysql</code>包，在<code>3.X</code>的<code>zabbix</code>版本中，并没有单独的<code>zabbix server</code>端程序包，安装<code>zabbix-server-mysql</code>包即为安装了<code>server</code>端包，同时，我们可以在服务端安装<code>zabbix_get</code>包，以便向<code>agent</code>端发起测试采集数据请求，所以，我们在<code>server</code>端安装如下包</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-3.jpg" alt="2-3"></p>
<blockquote>
<p>安装完成上述两个包以后，<code>server</code>即为安装完成，是不是很简单，<code>server</code>端的相关配置我们一会儿再进行</p>
</blockquote>
<h5 id="初始化zabbix-database"><a href="#初始化zabbix-database" class="headerlink" title="初始化zabbix database"></a>初始化<code>zabbix database</code></h5><blockquote>
<p>此处我们将<code>mysql</code>与<code>zabbix</code>安装在同一台服务器上，安装<code>mysql</code>的过程此处不再赘述，当我们安装完<code>mysql</code>，需要初始化<code>zabbix</code>的数据库，而在我们安装<code>zabbix server</code>时，其中就包含初始化<code>zabbix</code>数据库的<code>sql</code>脚本</p>
<p>我们查看刚才安装完成的<code>zabbix-server-mysql</code>，可以看到一个<code>create.sql.gz</code>的包</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-4.jpg" alt="2-4"></p>
<blockquote>
<p>解压此包即可获得初始化<code>sql</code>脚本</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-5.jpg" alt="2-5"></p>
<blockquote>
<p>但是需要注意的是，此<code>sql</code>脚本中<code>sql</code>只会在对应的数据库中初始化<code>zabbix</code>所需要的数据库表，但是不会创建<code>zabbix</code>数据库，所以，创建<code>zabbix</code>数据库这一步骤，还是需要我们手动进行的，所以，此处我们先手动创建<code>zabbix</code>的数据库，过程如下</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-6.jpg" alt="2-6"></p>
<blockquote>
<p><code>zabbix</code>数据库初始化完成后，执行对应的<code>sql</code>初始化脚本</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-7.jpg" alt="2-7"></p>
<blockquote>
<p>查看<code>zabbix</code>数据库，发现对应的表已经生成</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-8.jpg" alt="2-8"></p>
<h5 id="配置zabbix-server端并启动"><a href="#配置zabbix-server端并启动" class="headerlink" title="配置zabbix server端并启动"></a>配置<code>zabbix server</code>端并启动</h5><blockquote>
<p><code>server</code>端已经安装完毕，并且数据库也已经初始化，现在我们开始配置<code>server</code>端，编辑<code>zabbix server</code>端的配置文件</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-9.jpg" alt="2-9"></p>
<blockquote>
<p>此处列出我们可能会经常修改的参数，如下</p>
<p><code>ListenPort=10051</code></p>
<p># 服务端监听的端口，保持默认即可</p>
<p><code>SourceIP=</code></p>
<p># 通过<code>SourceIP</code>参数可以指定服务端的源<code>IP</code>，当<code>server</code>端有多个<code>IP</code>地址时，我们可以指定服务端使用固定的<code>IP</code>与<code>agent</code>端进行通讯，为了安全起见，<code>agent</code>端会基于<code>IP</code>进行一定的访问控制，也就是说<code>agent</code>端只允许指定的<code>IP</code>以<code>server</code>端的身份采集被监控主机的数据，如果<code>IP</code>不对应，则不允许采集被监控主机的数据，所以，当<code>server</code>端有多个<code>IP</code>时，我们可以通过<code>SourceIP</code>参数，指定<code>server</code>端通过哪个<code>IP</code>采集被监控主机的数据</p>
<p><code>LogType=file</code></p>
<p># 通过<code>LogType</code>参数，可以指定通过那种方式记录日志，此参数可以设置为三种植，<code>system</code>、<code>file</code>、<code>console</code>，<code>system</code>表示将日志发往<code>syslog</code>，<code>file</code>表示使用指定的文件作为日志文件，<code>console</code>表示将日志发往控制台，默认为<code>file</code></p>
<p><code>LogFile=/var/log/zabbix/zabbix_server.log</code></p>
<p># 当<code>LogType</code>设置为<code>file</code>时，通过<code>LogFile</code>参数设置日志文件位置</p>
<p><code>LogFileSize=0</code></p>
<p># 指明日志文件达到多大时自动滚动，单位为<code>MB</code>，如果设置<code>LogFileSize</code>为<code>50</code>，表示日志大小达到<code>50MB</code>滚动一次，设置为<code>0</code>表示日志文件不会滚动，所有日志保存在一个文件中</p>
<p><code>DebugLevel=3</code></p>
<p># 通过<code>DebugLevel</code>参数可以定义日志的详细程度，即为日志级别</p>
<p><code>DBHost=localhost</code></p>
<p># 通过<code>DBHost</code>参数设置<code>zabbix</code>数据库所在的服务器<code>IP</code>，由于此处<code>zabbix</code>与<code>mysql</code>安装在同一服务器上，所以此处设置为<code>localhost</code></p>
<p><code>DBName=zabbix</code></p>
<p># 通过<code>DBName</code>指定<code>zabbix</code>数据库对应的名称</p>
<p><code>DBUser=zabbix</code></p>
<p># 通过<code>DBUser</code>指定<code>zabbix</code>数据库用户名</p>
<p><code>DBPassword=123456</code></p>
<p># 通过<code>DBPassword</code>指定<code>zabbix</code>数据库用户的密码</p>
<p><code>DBPort=3306</code></p>
<p># 通过<code>DBPort</code>指定<code>zabbix</code>所在数据库服务监听的端口号</p>
<p><code>DBSocket=/var/lib/mysql/mysql.sock</code></p>
<p># 如果数据库服务与<code>server</code>端在同一台服务器上，可以通过<code>DBSocket</code>指定数据库本地套接字文件位置，但是需要注意，即使设置了<code>mysql</code>套接字文件的位置，还是需要配合<code>DBHost</code>参数，否则在登录<code>zabbix</code>控制台时，可能会出现警告，在<code>zabbix server</code>的<code>log</code>中，也可能会出现无法连接到数据库的提示</p>
</blockquote>
<blockquote>
<p>根据上述的配置参数的解释，根据具体需求进行实际配置即可</p>
</blockquote>
<blockquote>
<p>配置完成后，启动<code>zabbix</code>服务端即可，启动后，<code>10051</code>端口已经被监听</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-10.jpg" alt="2-10"></p>
<blockquote>
<p>好了，<code>zabbix server</code>已经启动，剩下的就是初始化<code>zabbix</code>设置了，但是初始化<code>zabbix</code>的设置需要<code>zabbix web</code>提供的<code>GUI</code>图形化界面，所以，我们需要先安装<code>zabbix web</code></p>
</blockquote>
<h5 id="安装zabbix-web"><a href="#安装zabbix-web" class="headerlink" title="安装zabbix web"></a>安装<code>zabbix web</code></h5><blockquote>
<p><code>zabbix web</code>可以安装在单独的主机上，只要连接到<code>zabbix database</code>所在的数据库即可，但是此处为了方便，我们将<code>zabbix web</code>与<code>mysql</code>以及<code>zabbix server</code>安装在同一台服务器上</p>
<p>因为<code>zabbix web</code>需要<code>lamp</code>环境，所以，此处我们将会依赖到的环境先安装好</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-11.jpg" alt="2-11"></p>
<blockquote>
<p>完成上述步骤后，安装<code>zabbix web</code>所需要的两个包，对应版本为<code>3.0.7</code></p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-12.jpg" alt="2-12"></p>
<blockquote>
<p>查看刚才安装完成的<code>zabbix-web</code>程序包，可以看到，<code>zabbix-web</code>的<code>web</code>应用存放在<code>/usr/share/zabbix</code>中</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-13.jpg" alt="2-13"></p>
<blockquote>
<p><code>zabbix</code>还是比较贴心的，针对<code>httpd</code>，<code>zabbix-web</code>包中已经包含了对应<code>zabbix</code>文档路径的配置文件</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-14.jpg" alt="2-14"></p>
<blockquote>
<p>可以看到，针对<code>zabbix web</code>的文档路径，此文件中已经为我们准备好了默认配置，如果不使用<code>httpd</code>的虚拟主机，主要将时区稍加改动即可直接使用</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-15.jpg" alt="2-15"></p>
<blockquote>
<p>而此处，我们使用<code>httpd</code>的虚拟主机访问<code>zabbix web</code>，所以，将配置文件中的内容改为如下配置，同时将时区修改为亚洲上海</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-16.jpg" alt="2-16"></p>
<blockquote>
<p>配置完成后，启动hettpd服务</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-17.jpg" alt="2-17"></p>
<blockquote>
<p>好了，<code>zabbix web</code>安装配置完成</p>
</blockquote>
<h5 id="初始化zabbix-配置"><a href="#初始化zabbix-配置" class="headerlink" title="初始化zabbix 配置"></a>初始化<code>zabbix</code> 配置</h5><blockquote>
<p>完成上述安装步骤后，访问<code>zabbix_IP/zabbix</code>，可以看到如下图的<code>zabbix</code>安装页面，点击下一步按钮</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-18.jpg" alt="2-18"></p>
<blockquote>
<p>可以看到，<code>zabbix</code>自动检查了安装环境是否满足要求，如果出现不满足要求的情况，需要进一步处理，此处没有问题，点击下一步</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-19.jpg" alt="2-19"></p>
<blockquote>
<p>此处<code>zabbix</code>需要配置数据库连接，此处配置数据库的类型，<code>IP</code>，端口，数据库名，用户密码等信息，端口填写<code>0</code>表示使用默认端口(<code>3306</code>端口)</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-20.jpg" alt="2-20"></p>
<blockquote>
<p>此处，我们可以填写<code>zabbix server</code>的详细信息，包括<code>IP</code>地址，端口号，以及<code>server</code>名称等，填写完成后点击下一步</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-21.jpg" alt="2-21"></p>
<blockquote>
<p>在配置之前，请确定概要信息无误，点击下一步</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-22.jpg" alt="2-22"></p>
<blockquote>
<p>从提示可以看出，初始化配置已经完成，而且<code>zabbix</code>提示我们，这些配置信息都被保存到了<code>&#39;/etc/zabbix/web/zabbix.conf.php&#39;</code>配置文件中，如果想要更改刚才的一些配置，可以通过修改此文件完成，初始化已经完成，点击结束即可</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-23.jpg" alt="2-23"></p>
<blockquote>
<p>点击完成按钮后，可以看到<code>zabbix</code>的登录页面，默认的管理员用户为<code>admin</code>，密码为<code>zabbix</code>，输入用户名密码后登录</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-24.jpg" alt="2-24"></p>
<blockquote>
<p>登录完成后，可以看到<code>zabbix</code>的仪表盘</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-25.jpg" alt="2-25"></p>
<blockquote>
<p>哈哈哈，我知道你看英文不爽，别急，现在就调成中文，点击下图中红框标注的图标</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-26.jpg" alt="2-26"></p>
<blockquote>
<p>语言选择中文，点击更新即可，但是你可能无法在语言中看到中文选项，如果无法找到中文选项，则代表你的配置文件中的中文选项显示属性为<code>False</code></p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-27.jpg" alt="2-27"></p>
<blockquote>
<p>如果你安装的<code>zabbix3.0.X</code>无法看到中文选项，那么你可以需要少许额外的操作，首先，你需要修改如下文件</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-28.jpg" alt="2-28"></p>
<blockquote>
<p>找到中文对应的值，将显示属性设置为true即可</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-29.jpg" alt="2-29"></p>
<blockquote>
<p>但是，你可能还会遇见中文乱码的情况，如果遇到中文乱码，可以从<code>windows</code>中挑选一个顺眼的中文字体，将对应字体文件放置到<code>linux</code>中<code>zabbix web</code>的字体目录中，因为我们使用的是<code>rpm</code>包安装的<code>zabbix web</code>，所以<code>zabbix web</code>的默认字体目录为<code>/usr/share/zabbix/fonts</code>，<code>windows</code>中的字体文件后缀名如果为<code>TTF</code>，当我们把对应字体文件拷贝到<code>zabbix</code>字体目录时，需要修改其后缀名为小写的<code>ttf</code>(如果本来就是小写的则不用任何修改)，字体文件上传完毕后，修改<code>/usr/share/zabbix/include/defines.inc.php</code>配置文件，将下图中显示字体部分修改为刚才上传的字体文件对应的名称即可</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-30.jpg" alt="2-30"></p>
<blockquote>
<p>比如，我选择了’微软雅黑’字体，将<code>msyh.ttf</code>文件上传至<code>zabbix</code>的<code>fonts</code>目录后，配置文件修改如下</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-31.jpg" alt="2-31"></p>
<blockquote>
<p>好了，上述操作完成后，<code>zabbix</code>控制台即显示为中文了</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-32.jpg" alt="2-32"></p>
<blockquote>
<p>但是，你可能会在访问<code>zabbix</code>控制台时，可能会发现如下提示</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-33.jpg" alt="2-33"></p>
<blockquote>
<p>如果出现上图中的提示，可能是由如下几个原因引起的</p>
</blockquote>
<ol>
<li><code>zabbix-server</code>未正常启动</li>
<li>已经开始<code>selinux</code>，但是没有正常设置对应权限</li>
<li><code>zabbix-server</code>未能正常连接数据库</li>
<li><code>zabbix.conf.php</code>文件中<code>$ZBX_SERVER</code>参数对应的主机名不能正常解析</li>
<li>其他原因，需要查看<code>zabbix server</code>日志</li>
</ol>
<blockquote>
<p>如果在访问<code>zabbix</code>控制台时并没有出现上述提示，忽略上述描述即可</p>
</blockquote>
<blockquote>
<p>为了更加安全，我们不应该使用管理员的默认密码，所以，我们最好先修改管理员密码</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-34.jpg" alt="2-34"></p>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-35.jpg" alt="2-35"></p>
<blockquote>
<p>好了，我们以后的监控工作就要围绕这个<code>web</code>界面展开了，为了以后更好的展开工作，我们先大概的了解一下<code>zabbix</code>的菜单</p>
</blockquote>
<blockquote>
<p>管理菜单中，一般用于管理<code>zabbix</code>自身及<code>zabbix</code>相关设置</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-36.jpg" alt="2-36"></p>
<blockquote>
<p>配置菜单中，一般用于配置监控相关设置</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-37.jpg" alt="2-37"></p>
<blockquote>
<p>监测中菜单，一般用于查看被监控的相关数据</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-38.jpg" alt="2-38"></p>
<blockquote>
<p>报表菜单中，可以为管理员生成一段时间内的监控统计信息</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-39.jpg" alt="2-39"></p>
<blockquote>
<p>资产记录菜单中，管理员可以查看被管控的主机有那些，以及相关的资产信息</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-40.jpg" alt="2-40"></p>
<blockquote>
<p>好了，<code>zabbix web</code>的安装及简介暂时告一段落</p>
</blockquote>
<h5 id="安装zabbix-agent"><a href="#安装zabbix-agent" class="headerlink" title="安装zabbix agent"></a>安装<code>zabbix agent</code></h5><blockquote>
<p>万事俱备，就差<code>agent</code>端了，<code>agent</code>端安装也非常方便，直接被监控主机上安装如下两个包即可</p>
<p>此处被管理主机为<code>centos7.3</code>，已经配置好了对应的<code>zabbix</code>源，<code>agent</code>版本可以跟<code>server</code>端版本不一致，没有关系，安装即可</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-41.jpg" alt="2-41"></p>
<blockquote>
<p>我们查看一下<code>zabbix-agent</code>都安装了哪些文件，当然，最重要的就是<code>zabbix_agentd.conf</code>这个配置文件了</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-42.jpg" alt="2-42"></p>
<blockquote>
<p>还记得我们在刚开始介绍<code>zabbix</code>时，说过的’主动模式’与’被动模式’吗？这两种模式的相关配置，都需要在<code>zabbix_agentd.conf</code>中定义，打开这个文件，我们来配置一下最常用的<code>agent</code>端配置。首先，可以看到配置文件中有很多注释，打开配置文件，首先看到的就是’通用参数配置段’，我们可以在此配置段配置<code>zabbix_agent</code>进程的进程编号文件路径，存储日志方式，日志文件位置，日志滚动阈值等常用设定，细心如你一定已经发现，<code>zabbix_agent</code>配置文件的’通过配置段’中的参数大多数与<code>zabbix_server</code>配置文件中的仓用参数意义相同，所以，此处不再过多赘述，如果没有特殊需要，保持默认即可</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-43.jpg" alt="2-43"></p>
<blockquote>
<p>此处先说说我们马上会用到的两个配置段，如下图红框中的注释所描述的，’被动模式配置段’与’主动模式配置段’</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-44.jpg" alt="2-44"></p>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-45.jpg" alt="2-45"></p>
<blockquote>
<p>我们已经在最开始的概念介绍中，描述过，’主动模式’与’被动模式’都是对于<code>agent</code>端来说的，而且它们可以同时存在，并不冲突</p>
<p>我们来看看’被动模式’的相关配置参数</p>
<p>被动模式相关参数如下</p>
<p><code>Server</code>：用于指定允许哪台服务器拉取当前服务器的数据，当<code>agent</code>端工作于被动模式，则代表<code>server</code>端会主动拉取<code>agent</code>端数据，那么<code>server</code>端的<code>IP</code>必须与此参数的<code>IP</code>对应，此参数用于实现基于<code>IP</code>的访问控制，如果有多个<code>IP</code>，可以使用逗号隔开</p>
<p><code>ListenPort</code>：用于指定当<code>agent</code>端工作于被动模式时所监听的端口号，默认端口为<code>10050</code>，也就是说，<code>server</code>端默认访问<code>10050</code>端口，从而拉取数据</p>
<p><code>ListenIP</code>：用于指定<code>agent</code>端工作于被动模式时所监听的<code>IP</code>地址，默认值为<code>0.0.0.0</code>，表示监听本机的所有<code>IP</code>地址</p>
<p><code>StartAgents</code>：用于指定欲生成的<code>agent</code>进程数量</p>
</blockquote>
<blockquote>
<p>好了，被动模式的参数说完了，现在聊聊主动模式</p>
<p>主动模式的常用参数如下</p>
<p><code>ServerActive</code>：此参数用于指定当<code>agent</code>端工作于主动模式时，将信息主动推送到哪台<code>server</code>上，当有多个<code>IP</code>时，可以用逗号隔开</p>
<p><code>Hostname</code>：此参数用于指定当前主机的主机名，<code>server</code>端通过此参数对应的主机名识别当前主机</p>
<p><code>RefreshActiveChecks</code>：此参数用于指定<code>agent</code>端每多少秒主动将采集到的数据发往<code>server</code>端</p>
</blockquote>
<blockquote>
<p>此处，我们同时设置’被动模式’与’主动模式’的如下参数，其他保持默认即可，修改完成后保存退出</p>
<p><code>Server=116.62.188.230</code></p>
<p><code>ServerActive=116.62.188.230</code></p>
<p><code>Hostname=testzabbix1.qzl.net</code></p>
</blockquote>
<blockquote>
<p>配置文件修改完成之后，启动agent端进行</p>
</blockquote>
<p><img src="/2010/01/03/Zabbix%E5%AE%89%E8%A3%85/2-46.jpg" alt="2-46"></p>
<blockquote>
<p>好了，agent端也已经安装完毕了</p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix(1)：Zabbix概念</title>
    <url>/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><h5 id="Zabbix监控系统入门简介"><a href="#Zabbix监控系统入门简介" class="headerlink" title="Zabbix监控系统入门简介"></a>Zabbix监控系统入门简介</h5><blockquote>
<p><code>Zabbix</code>是一个基于<code>WEB</code>界面的提供分布式系统监控的企业级的开源解决方案，<code>Zabbix</code>能监视各种网络参数，保证服务器系统的安全稳定的运行，并提供灵活的通知机制以让SA快速定位并解决存在的各种问题。<code>Zabbix</code>分布式监控系统的优点如下：</p>
</blockquote><a id="more"></a>
<ul>
<li>支持自动发现服务器和网络设备</li>
<li>支持底层自动发现</li>
<li>分布式的监控体系和集中式的<code>WEB</code>管理</li>
<li>支持主动监控和被动监控模式</li>
<li>服务器端支持多种操作系统：<code>Linux, Solaris, HP-UX, AIX, FreeBSD, OpenBSD, MAC</code>等</li>
<li><code>Agent</code>客户端支持多种操作系统：<code>Linux, Solaris, HP-UX, AIX, FreeBSD, Windows</code>等</li>
<li>基于<code>SNMP</code>、<code>IPMI</code>接口方式也可以监控<code>Agent</code></li>
<li>安全的用户认证及权限配置</li>
<li>基于<code>WEB</code>的管理方法，支持自由的自定义事件和邮件发送</li>
<li>高水平的业务视图监控资源，支持日志审计，资产管理等功能</li>
<li>支持高水平<code>API</code>二次开发、脚本监控、自<code>Key</code>定义、自动化运维整合调用</li>
</ul>
<h5 id="Zabbix监控组件及流程"><a href="#Zabbix监控组件及流程" class="headerlink" title="Zabbix监控组件及流程"></a>Zabbix监控组件及流程</h5><blockquote>
<p><code>Zabbix</code>监控组件如下图所示，主要由三大组件，分别是 <code>Zabbix server</code>端、<code>Zabbix Proxy</code>、<code>Agent</code>客户端，其中<code>Zabbix Server</code>端包括：<code>WEB GUI</code>、<code>Database</code>、<code>Zabbix_Server</code>。</p>
</blockquote>
<p><img src="/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/1-1.png" alt="1-1"></p>
<blockquote>
<p><code>Zabbix</code>监控系统具体监控系统流程如下图所示：</p>
</blockquote>
<p><img src="/2010/01/01/Zabbix%E6%A6%82%E5%BF%B5/1-2.png" alt="1-2"></p>
<blockquote>
<p><code>Zabbix</code>监控完整流程包括：<code>Agent</code>安装在被监控的主机上，Agent负责定期收集客户端本地各项数据，并发送到<code>Zabbix Server</code>端，<code>Zabbix Server</code>收到数据，将数据存储到数据库中，用户基于<code>Zabbix WEB</code>可以看到数据在前端展现图像。</p>
<p>当<code>Zabbix</code>监控某个具体的项目，该项目会设置一个触发器阀值，当被监控的指标超过该触发器设定的阀值，会进行一些必要的动作，动作包括：邮件、微信报警或者执行命令等操作。如下为<code>Zabbix</code>完整监控系统，各个部分负责的工作：</p>
</blockquote>
<ul>
<li><code>Zabbix Server</code>：负责接收<code>Agent</code>发送的报告信息的核心组件，所有配置，统计数据及操作数据均由其组织进行</li>
<li><code>Database Storage</code>：专用于存储所有配置信息，以及存储由<code>Zabbix</code>收集到的数据</li>
<li><code>Web interface</code>：<code>Zabbix</code>的<code>GUI</code>接口，通常与<code>Server</code>运行在同一台主机上</li>
<li><code>Proxy</code>：常用于分布监控环境中，代理<code>Server</code>收集部分被监控端的监控数据并统一发往<code>Server</code>端</li>
<li><code>Zabbix Agent</code>：部署在被监控主机上，负责收集本地数据并发往<code>Server</code>端或<code>Proxy</code>端</li>
</ul>
<blockquote>
<p><code>Zabbix</code>监控部署在系统中，会包含常见的四个程序：<code>zabbix_server</code> 、<code>zabbix_get</code>、<code>zabbix_agentd</code>、<code>zabbix_proxy</code>、<code>zabbix_sender</code>等。四个程序启动后分别对应四个进程，如下为每个进程的功能：</p>
</blockquote>
<ul>
<li><code>Zabbix_server</code>：<code>Zabbix</code>服务端守护进程，其中<code>zabbix_agentd</code>、<code>zabbix_get</code>、<code>zabbix_sender</code>、<code>zabbix_proxy</code>的数据最终均是提交给<code>Zabbix_Server</code></li>
<li><code>Zabbix_Agentd</code>：客户端守护进程，负责收集客户端数据，例如收集<code>cpu</code>负载、内存、硬盘使用情况等</li>
<li><code>Zabbix_get</code>：<code>Zabbix</code>数据获取工具，单独使用的命令，通常在<code>server</code>或者<code>proxy</code>端执行获取远程客户端信息的命令</li>
<li><code>Zabbix_sender</code>：<code>zabbix</code>数据发送工具，用于发送数据给<code>server</code>或者<code>proxy</code>，通常用于耗时比较长的检查。很多检查非常耗时间，导致<code>zabbix</code>超时。于是我们在脚本执行完毕之后，使用<code>sender</code>主动提交数据</li>
<li><code>Zabbix_proxy</code>：<code>zabbix</code>分布式代理守护进程，分布式监控架构需要部署<code>Zabbix_Proxy</code></li>
</ul>
<h5 id="Zabbix监控方式及数据采集"><a href="#Zabbix监控方式及数据采集" class="headerlink" title="Zabbix监控方式及数据采集"></a>Zabbix监控方式及数据采集</h5><blockquote>
<p><code>Zabbix</code>分布式监控系统监控客户端的方式常见有三种，分别是<code>Agent</code>方式、<code>SNMP</code>、<code>IPMI</code>方式，三种方式特点如下：</p>
</blockquote>
<ul>
<li><code>Agent</code>：<code>Zabbix</code>可以基于自身<code>zabbix_agent</code>客户端插件监控<code>OS</code>的状态，例如<code>CPU</code>、内存、硬盘、网卡、文件等</li>
<li><code>SNMP</code>：<code>Zabbix</code>可以通过简单网络管理协议（<code>Simple Network Management Protocol</code>，<code>SNMP</code>)协议监控网络设备或者<code>windows</code>主机等，通过设定<code>SNMP</code>的参数将相关监控数据传送至服务器端，交换机、防火墙等网络设备一般都支持<code>SNMP</code>协议</li>
<li><code>IPMI</code>：智能平台管理接口（<code>Intelligent  Platform Management Interface</code>，<code>IPMI</code>）即主要应用于设备的物理特性，包括：温度、电压、电扇工作状态、电源供应以及机箱入侵等。<code>IPMI</code>最大的优势在于无论<code>OS</code>在开机还是关机的状态下，只要接通电源就可以实现对服务器的监控</li>
</ul>
<blockquote>
<p><code>Zabbix</code>监控客户端分为主动监控与被动监控，主被动模式以客户端为参照，<code>Zabbix</code>监控客户端默认为被动模式，可以修改为主动模式，只需要在客户端配置文件中添加。可以关闭被动模式的方法：在配置文件中加入 <code>StartAgents</code>=0，即为关闭被动模式。主被动监控模式区别如下：</p>
</blockquote>
<ul>
<li><code>Zabbix</code>主动模式：<code>Agent</code>主动请求<code>server</code>获取主动的监控项列表，并主动将监控项内需要检测的数据提交给<code>server/proxy</code>，<code>zabbix agent</code>首先向<code>ServerActive</code>配置的<code>IP</code>请求获取<code>active items</code>，获取并提交<code>active tiems</code>数据值<code>server</code>或者<code>proxy</code></li>
<li><code>Zabbix</code>被动模式：<code>Server</code>向<code>Agent</code>请求获取监控项的数据，<code>Agent</code>返回数据，<code>Server</code>打开一个<code>TCP</code>连接，<code>Server</code>发送请求<code>Agent.ping</code>，<code>Agent</code>接收到请求并且响应，<code>Server</code>处理接收到的数据</li>
</ul>
<h5 id="Zabbix监控概念"><a href="#Zabbix监控概念" class="headerlink" title="Zabbix监控概念"></a>Zabbix监控概念</h5><blockquote>
<p><code>Zabbix</code>监控系统包括很多监控概念，掌握<code>Zabbix</code>监控概念能对<code>Zabbix</code>监控快速的理解，如下为<code>Zabbix</code>常用术语及解释。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Zabbix常用术语</th>
<th align="left">Zabbix术语解释</th>
</tr>
</thead>
<tbody><tr>
<td>主机(host)</td>
<td align="left">被监控的网络设备，可以写IP或者DNS</td>
</tr>
<tr>
<td>主机组(host group)</td>
<td align="left">主机组用于管理主机，可以批量设置权限</td>
</tr>
<tr>
<td>监控项(item)</td>
<td align="left">具体监控项，items值由独立的keys进行识别</td>
</tr>
<tr>
<td>触发器(trigger)</td>
<td align="left">为某个items设置触发器，达到触发器会执行action动作</td>
</tr>
<tr>
<td>事件(event)</td>
<td align="left">例如达到某个触发器，称之为一个事件</td>
</tr>
<tr>
<td>动作(action)</td>
<td align="left">对于特定事件事先定义的处理方法，默认可以发送信息及发送命令</td>
</tr>
<tr>
<td>报警升级(escalation)</td>
<td align="left">发送警报或执行远程命令的自定义方案，如隔5分钟发送一次警报，共发送5次等</td>
</tr>
<tr>
<td>媒介(media)</td>
<td align="left">发送通知的方式，可以支持Mail、SMS、Scripts等</td>
</tr>
<tr>
<td>通知(notification)</td>
<td align="left">通过设置的媒介向用户发送的有关某事件的信息</td>
</tr>
<tr>
<td>远程命令</td>
<td align="left">达到触发器，可以在被监控端执行命令</td>
</tr>
<tr>
<td>模板(template)</td>
<td align="left">可以快速监控被监控端，模块包含：item、trigger、graph、screen、application</td>
</tr>
<tr>
<td>web场景(web scennario)</td>
<td align="left">用于检测web站点可用性，监控HTTP关键词</td>
</tr>
<tr>
<td>web前端(frontend)</td>
<td align="left">Zabbix的web接口</td>
</tr>
<tr>
<td>图形(graph)</td>
<td align="left">监控图像</td>
</tr>
<tr>
<td>屏幕(screens)</td>
<td align="left">屏幕显示</td>
</tr>
<tr>
<td>幻灯(slide show)</td>
<td align="left">幻灯显示</td>
</tr>
<tr>
<td>##### Zabbix工作模式</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>我们知道，<code>agent</code>端会将采集完的数据主动发送给<code>server</code>端，这种模式我们称之为主动模式，即对于<code>agent</code>端来说是主动的</p>
<p>其实，<code>agent</code>端也可以不主动发送数据，而是等待<code>server</code>过来拉取数据，这种模式我们称之为被动模式</p>
<p>聪明如你一定已经明白，不管是主动模式还是被动模式，都是对于<code>agent</code>端来说的，而且，主动模式与被动模式可以同时存在，并不冲突</p>
<p>管理员可以在<code>agent</code>端使用一个名为<code>zabbix_sender</code>的工具，测试是否能够向<code>server</code>端发送数据</p>
<p>管理员可以在<code>server</code>端使用一个名为<code>zabbix_get</code>的工具，测试是否能够从<code>agent</code>端拉取数据</p>
</blockquote>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Templates-模板层</title>
    <url>/2005/01/07/Django-Templates-%E6%A8%A1%E6%9D%BF%E5%B1%82/</url>
    <content><![CDATA[<h4 id="模板层"><a href="#模板层" class="headerlink" title="模板层"></a>模板层</h4><blockquote>
<p>Django中的HTML文件并不是一个简单的前端页面，他支持多种渲染方式；</p>
<p>比如<code>Smart</code>或是<code>Jinja</code>这样出名的模板语言引擎，默认django使用的是templates引擎来进行模板页面的渲染，这也被称为Django模板语言（DTL）</p>
</blockquote><a id="more"></a>
<ul>
<li>模板语言主要有<strong>模板变量</strong>和<strong>模板标签</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;&#123; account &#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>模板变量通过视图函数传递字典变量，字典的<code>key</code>值为对应模板变量名，对应<code>value</code>是模板变量实际被渲染的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">	content = &#123;<span class="string">'account'</span>:<span class="string">'test'</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> render(request,html,content)</span><br></pre></td></tr></table></figure>

<ul>
<li>最终渲染结果</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> test <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板引擎遇到这个变量，将会计算他，并且将结果覆盖；</p>
<p>如果视图函数中，并没有给这个模板变量赋值，也没有关系，模板会自动将这个``处理为一个空</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：模板变量名，只能以字母数字下划线构成，下划线不可以打头，并且也不可以使用表单符号组成模板变量</p>
</blockquote>
<h5 id="变量获取方式"><a href="#变量获取方式" class="headerlink" title="变量获取方式"></a>变量获取方式</h5><blockquote>
<p>当我们返回的是一个字符串数据，这应该是最简单的处理方式，前端模板会直接将它展示到页面中。</p>
<p>如果返回的是一个列表序列数据或者字典键值对数据，我们可以使用模板语言中的<code>.</code>符号来进行其中值的获取，当模板变量中有符号<code>.</code>的存在时，比如<code>content.key</code>他会按照如下顺序来进行查找：</p>
</blockquote>
<ol>
<li><p>字典查找：<code>content[key]</code></p>
</li>
<li><p>对应属性和方法查找：<code>content.key</code></p>
<ul>
<li><blockquote>
<p>注意：因为对应key值的查找优先级要低于属性方法，所以要尽量避免使用数据内置方法作为key值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>序列索引方式查找：<code>content[index]</code></p>
</li>
</ol>
<h5 id="Python数据在模板"><a href="#Python数据在模板" class="headerlink" title="Python数据在模板"></a>Python数据在模板</h5><blockquote>
<p>Python常用数据有int，float，str，list，tuple，dict，set等</p>
<p>把他们都通过模板变量传递到模板页面试试</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    int_ = <span class="number">123</span></span><br><span class="line">    float_ = <span class="number">0.123</span> </span><br><span class="line">    str_ = <span class="string">'str'</span></span><br><span class="line">    list_ = [<span class="string">'l'</span>,<span class="string">'i'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>]</span><br><span class="line">    tuple_ = (<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'p'</span>,<span class="string">'l'</span>,<span class="string">'e'</span>)</span><br><span class="line">    dict_ = &#123;<span class="string">"key"</span>:<span class="string">"value"</span>&#125;</span><br><span class="line">    set_ = &#123;<span class="string">'s'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>,locals())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>locals()</code>：该函数将当前作用域下的所有变量名和对应变量值组成字典，免去了我们构造存储字典的麻烦</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; int_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; float_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; list_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tuple_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dict_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dict_.key &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; set_ &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>到了模板页面上，这些变量值其实也都像变成了字符串一样，直接展示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">0.123</span><br><span class="line"></span><br><span class="line">str</span><br><span class="line"></span><br><span class="line">['l', 'i', 's', 't']</span><br><span class="line"></span><br><span class="line">('t', 'u', 'p', 'l', 'e')</span><br><span class="line"></span><br><span class="line">&#123;'key': 'value'&#125;</span><br><span class="line"></span><br><span class="line">&#123;'e', 's', 't'&#125;</span><br></pre></td></tr></table></figure>

<h5 id="for-标签"><a href="#for-标签" class="headerlink" title="for 标签"></a>for 标签</h5><blockquote>
<p>使用模板中使用标签语言&#123;% for %&#125;和&#123;% endfor%&#125;，对视图函数传递的数据集进行遍历访问，比如上面传递的字符串，列表，元祖，字典，集合这样的数据</p>
<p>和普通模板变量不同，模板标签使用大括号百分号的组合&#123;% lag %&#125;，具有有一些特殊的功能性</p>
</blockquote>
<blockquote>
<p>模板中的标签&#123;% for %&#125;与Python中的for循环类似，要记得有闭合模板标签&#123;&#123; endfor &#125;&#125;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in sequence %&#125;</span><br><span class="line">	&#123;&#123; var &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>来把上面的数据进行访问</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in str_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in tuple_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">---------------------</span><br><span class="line">&#123;% for var in set_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看到的效果和在Python中迭代访问的结果是差不多的，并且模板循环还会使对应的标签也进行循环</p>
</blockquote>
<blockquote>
<p>接下来来看字典，通过模板循环从字典中取出来的是字典的key值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in dict_ %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; var &#125;&#125; &#123;&#123; dict_.var&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在for循环遍历访问字典的时候，不能再像Python语法里一样，直接通过迭代获取<code>key</code>之后通过</p>
<p><code>dict[key]</code>或是<code>dict.key</code>，拿到对应value；</p>
<p>模板变量不会把<code>var</code>解释成取到的对应<code>key</code>值，var只是作为了一个单纯的<code>var</code>字符串，除非在字典中，有<code>var</code>字符串做为字典的键值，否则是取不到的</p>
</blockquote>
<ul>
<li>正确的对字典中键值对进行获取的方式是通过内置字典<code>items</code>属性：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for key,value in dict_.items %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; key &#125;&#125; &#123;&#123; value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：模板语言中，不会出现索引超出范围的<code>IndexError</code>或者Key值不存在的<code>KeyError</code>，取不出任何东西则只是一个空</p>
</blockquote>
<ul>
<li>在&#123;% for %&#125;循环中，我们还可以使用很多有用的模板变量，方便我们控制循环</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in iterable %&#125;</span><br><span class="line">	&#123;&#123; forloop.counter &#125;&#125; <span class="comment">&lt;!--当前循环次数，从1开始计数 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.counter0 &#125;&#125; <span class="comment">&lt;!--当前循环次数，从0开始计数 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.revcounter &#125;&#125; <span class="comment">&lt;!--当前循环次数，从最大长度开始 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.revcounter0 &#125;&#125; <span class="comment">&lt;!--当前循环次数，从最大索引开始 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.first &#125;&#125; <span class="comment">&lt;!-- 判断是否为第一次循环 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.last &#125;&#125; <span class="comment">&lt;!-- 判断是否为第一次循环 --&gt;</span></span><br><span class="line">	&#123;&#123; forloop.parentloop &#125;&#125; <span class="comment">&lt;!-- 当循环嵌套时，访问上层循环 --&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过&#123;% empty %&#125;标签判断迭代对象是否为空</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in test_list %&#125;</span><br><span class="line">	&#123;&#123; var &#125;&#125;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">	空空如也</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h5 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h5><blockquote>
<p>可以通过&#123;% if %&#125;标签语法来进行模板变量的值判断；</p>
<p>语法如下</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if test_list %&#125;</span><br><span class="line">    列表不为空</span><br><span class="line">&#123;% elif test_dict %&#125;</span><br><span class="line">    列表为空，字典不为空</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">	列表字典均为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>并且<code>if</code>标签还支持<code>and</code>、<code>or</code>及<code>not</code>来进行变量的布尔判断</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if test_list and test_dict %&#125;</span><br><span class="line">    列表、字典均不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if not test_list %&#125;</span><br><span class="line">    列表为空时才能满足IF条件判断</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if test_list or test_dict %&#125;</span><br><span class="line">    列表、字典某一个不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if not test_list or test_dict %&#125;</span><br><span class="line">    列表为空或字典不为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if test_list and not test_dict %&#125;</span><br><span class="line">    列表不为空并且字典为空</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也支持同时使用and及or语句，但是and的条件判断优先级要高于or语句</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if a or b and c %&#125;</span><br><span class="line">等同于</span><br><span class="line">&#123;% if a or (b and c) %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>if</code>标签还支持<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>的判断用法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if var == "1" %&#125;</span><br><span class="line">	这个值是"1"</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if var != "x" %&#125;</span><br><span class="line">	判断不相等成立</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if var <span class="tag">&lt; <span class="attr">100</span> %&#125;</span></span><br><span class="line"><span class="tag">    <span class="attr">var</span>大于<span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#123;% <span class="attr">endif</span> %&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if var &gt;= 100 %&#125;</span><br><span class="line">    var大于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果判断的数据类型在后台传递到模板变量时具体数值类型为整型或浮点型而不是字符串;</p>
<p><strong>不需要在判断的时候加字符串的标识引号</strong></p>
</blockquote>
<ul>
<li>在模板语言中，不支持连续判断</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if 100 &gt; var &gt; 50 %&#125;</span><br><span class="line">    var大于50小于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应该使用and语句写成这样</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if 100 &gt; var and var &gt; 50 %&#125;</span><br><span class="line">    var大于50小于100</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>除去运算符之外，<code>if</code>标签还支持<code>in</code>和<code>not in</code>的判断运算</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if 1 in test_list %&#125;</span><br><span class="line">    列表中有数字1</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他常用标签"><a href="#其他常用标签" class="headerlink" title="其他常用标签"></a>其他常用标签</h5><blockquote>
<p>其实<code>django</code>官方提供了不只<code>if</code>和<code>for</code>这样的模板标签，还提供了很多可以让我们在模板页面上实现之前只能在后台进行逻辑实现的功能标签，比如以下：</p>
</blockquote>
<h6 id="comment-标签"><a href="#comment-标签" class="headerlink" title="comment 标签"></a>comment 标签</h6><blockquote>
<p><code>comment</code>标签常用来注释，在&#123;% comment %&#125;和&#123;% endcomment %&#125;中间的部分内容会被忽略；</p>
<p>这个标签不能嵌套使用</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% comment %&#125;</span><br><span class="line">	这里的内容会被忽略，相当于注释起来。</span><br><span class="line">&#123;% endcomment %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="autoescape-标签"><a href="#autoescape-标签" class="headerlink" title="autoescape 标签"></a>autoescape 标签</h6><blockquote>
<p>默认情况下，为了安全起见，模板在接收到一个<code>HTML</code>标签或者<code>css</code>样式等具有实际意义的变量字符串时；</p>
<p>会对他进行转义，不会将这个字符串处理为HTML中实际的标签。一个<code>&lt;h1&gt;</code>标签到最后会被处理成：</p><h1>，这样浏览器就不会把他解释成一个标签的样式了<p></p>
</h1></blockquote>
<ul>
<li>转义规则</li>
</ul>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">转义规则</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;</td>
<td align="left"><code>&amp;lt;</code></td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left"><code>&amp;gt;</code></td>
</tr>
<tr>
<td align="left">‘（单引号）</td>
<td align="left"><code>&amp;#39;</code></td>
</tr>
<tr>
<td align="left">“（双引号）</td>
<td align="left"><code>&amp;quot;</code></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left"><code>&amp;amp;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>那么有的时候，我们可能需要这样类似的HTML标签真正效果展示出来，</p>
<p>比如一个<code>&lt;h1&gt;</code>标签我们希望他真正展示出<code>h1</code>的样子，而不是一个朴素的<code>&lt;h1&gt;</code>字符串，那么就需要我们使用autoescape标签来进行防止转义处理</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">str_ = "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是H1标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>"</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape on %&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="cycle-标签"><a href="#cycle-标签" class="headerlink" title="cycle 标签"></a>cycle 标签</h6><blockquote>
<p><code>cycle</code>标签提供一些可迭代数据；</p>
<p>它的结构像是一个环，其中的数据通过空格分割，你可以使用任意数量的值，作为接下里每一次循环迭代的数据</p>
<p>其他包含在单引号 <code>&#39;</code>或者双引号 <code>&quot;</code>中的值被认为是可迭代字符串，如果没有被字符串引号包围的值被当作模版变量</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">list_ = ['l','i','s','t'] # 视图定义的模板变量</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.blue</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"&#123;% cycle 'red' 'blue' %&#125;"</span>&gt;</span></span><br><span class="line">        &#123;&#123; var &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很简单的就可以通过<code>cycle</code>标签进行循环中的样式切换啦</p>
<p>循环遍历出来的列表中每一个字都是换着颜色展示</p>
</blockquote>
<blockquote>
<p>某些时候，我们可能希望在使用一次<code>cycle</code>之后，接下来使用不是继续向后迭代取值，而是继续沿用这一次取到的值；</p>
<p>那么我们可以通过<code>as</code>语法给<code>cycle</code>标签取别名，在接下来需要沿用的地方直接使用别名作为模板变量即可，比如这样</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;% cycle 'red' 'blue' as style %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一次循环取到的cycle其中的值，都可以通过别名style在这次循环区域中重复利用而不递进</li>
</ul>
<blockquote>
<p>但是我们发现个问题，<code>as</code>语句本身在使用时也会造成对<code>cycle</code>中的数据进行一次取值，那有什么办法可以在第一次<code>as</code>语句出现时，我只做声明，而不是为了取值，<code>django</code>模板中提供了一个叫<code>silent</code>的属性，可以用来<code>as</code>命名时不进行取值动作</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% cycle 'red' 'blue' as style silent %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% cycle 'red' 'blue' as style silent %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% cycle style %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% cycle style %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; style &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>silent</code>可以在初次定义时不进行取值，</p>
<p>接下来使用<code>cycle</code>所创建的迭代器，每次访问得到当前值，不会继续向后迭代；</p>
<p>如果希望取到下一个值，可以使用迭代器标签&#123;% style %&#125;，这次访问不会生产数据，但是会让迭代访问位置向后推进一次，在接下来&#123;&#123; style &#125;&#125;使用将得到下一个值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">red</span><br><span class="line">red</span><br><span class="line">blue</span><br><span class="line">red</span><br><span class="line">red</span><br></pre></td></tr></table></figure>

<h6 id="ifchanged-标签"><a href="#ifchanged-标签" class="headerlink" title="ifchanged 标签"></a>ifchanged 标签</h6><blockquote>
<p><code>ifchanged</code>标签用在<code>for</code>标签中；</p>
<p>检测这一次迭代的值和上一次迭代的值是否有改变，可以搭配<code>else</code>标签使用，用来确定是没有改变；</p>
<p>检查标签&#123;% ifchanged %&#125;和&#123;% endifchanged %&#125;之间的数据在每一次迭代过程中是否发生改变</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">list_ = [1,1,1,2,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for var in list_ %&#125;</span><br><span class="line">	&#123;% ifchanged %&#125; </span><br><span class="line">		&#123;&#123; var &#125;&#125;</span><br><span class="line">	&#123;% else %&#125;</span><br><span class="line">		数据未发生变化</span><br><span class="line">	&#123;% endifchanged %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">数据未发生变化 </span><br><span class="line">数据未发生变化 </span><br><span class="line">2 </span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h6 id="firstof-标签"><a href="#firstof-标签" class="headerlink" title="firstof 标签"></a>firstof 标签</h6><blockquote>
<p><code>firstof</code>标签用来查找到标签内变量中第一个为<code>True</code>的参数并输出，如果标签内变量均为<code>False</code>，那么输出空</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% firstof 0 0 0 0 0 "哈哈哈" %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">哈哈哈</span><br></pre></td></tr></table></figure>

<h6 id="ifequal-标签"><a href="#ifequal-标签" class="headerlink" title="ifequal 标签"></a>ifequal 标签</h6><blockquote>
<p><code>ifequal</code>标签接收两个变量，用来判断这两个值是否相等，如果相等，展示对应内容</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% ifequal 1 "1" %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>两个值相等<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% else %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>两个值不等<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endifequal %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这都不用想的，俩类型都不一样</li>
</ul>
<h6 id="ifnotequal-标签"><a href="#ifnotequal-标签" class="headerlink" title="ifnotequal 标签"></a>ifnotequal 标签</h6><blockquote>
<p>上面的反义</p>
</blockquote>
<h6 id="now-标签"><a href="#now-标签" class="headerlink" title="now 标签"></a>now 标签</h6><blockquote>
<p>显示日期或时间，标签必须一个参数，用来指定当前时间日期的描述方式；</p>
<p>输出最终格式与项目时区及语言设置有关</p>
<p>参数是一个描述字符串，比较多，记着常用的就行</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">秒</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">u</td>
<td align="left">微妙，000000-999999</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">秒，00-59</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">时区偏移量（UTC），单位为秒。-43200到43200</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">自Unix 时间以来的秒数。1970年1月1日00:00:00 UTC</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">分钟</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">分钟，00-59</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">小时</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">g</td>
<td align="left">12小时格式，1-12’</td>
</tr>
<tr>
<td align="left">G</td>
<td align="left">24小时格式，00-23</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">12小时格式，00-12</td>
</tr>
<tr>
<td align="left">H</td>
<td align="left">24小时格式，00-23</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">时区差值，单位小时，如：Asia/Shanghai时区：+0800</td>
</tr>
<tr>
<td align="left">P</td>
<td align="left">当前几时几分，如：5:30 pm</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">当前几时几分，不包含上下午标示，如：5:30</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">小写字母：a.m.、p.m.</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">大写字母：AM、PM</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">月份</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">b</td>
<td align="left">月份英文字母的前三个表示，均小写。如：”aug”</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">这个月的第几天，01-31</td>
</tr>
<tr>
<td align="left">j</td>
<td align="left">这个月的第几天，1-31</td>
</tr>
<tr>
<td align="left">E</td>
<td align="left">当前时区月份英文单词全拼</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">当前月份英文单词全拼</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">第几月，01-12</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">月份英文字母的前三个表示，首字母大写。如：”Aug”</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">第几月，1-12</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">美联社月份缩写，如：’Jan.’，’Feb.’，’March’，’May’</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">星期</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">D</td>
<td align="left">星期几的英文单词前三个表示，首字母大写，如：’Fri’</td>
</tr>
<tr>
<td align="left">l</td>
<td align="left">星期几的英文单词全拼，如：’Friday’</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">星期几的数字，0（星期日）-6（星期六）</td>
</tr>
<tr>
<td align="left">W</td>
<td align="left">ISO-8601周数，今年第几周</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">年</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">L</td>
<td align="left">Bool值判断是否为闰年</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">第几年两位数字，如：2018年，返回18</td>
</tr>
<tr>
<td align="left">Y</td>
<td align="left">第几年，目前是：2018</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">今天是今年的第几天</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">其他</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">c</td>
<td align="left">ISO 8601时间格式</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">当前时区名称：CST（美国-6:00，澳大利亚+9:30，中国+8:00，古巴-4:00）</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">RFC 5322格式化日期</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">一个月的第几天的英文序数后缀：’st’，’nd’，’rd’或’th’</td>
</tr>
<tr>
<td align="left">t</td>
<td align="left">当前月份的天数：28-31</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">当前时区</td>
</tr>
</tbody></table>
<ul>
<li>选出你想表达的时间，比如年月日，那么可以这样</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% now "Y-m-d" %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2019-03-26</span><br></pre></td></tr></table></figure>

<ul>
<li>除了以上自己组合的格式化字符，还有一些已经预定义好的字符串</li>
</ul>
<table>
<thead>
<tr>
<th align="left">字符串</th>
<th align="left">对应格式 时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE_FORMAT</td>
<td align="left">‘N j, Y’ Feb. 5, 2018</td>
</tr>
<tr>
<td align="left">DATETIME_FORMAT</td>
<td align="left">‘N j, Y, P’ Feb. 4, 2013, 4 p.m.</td>
</tr>
<tr>
<td align="left">SHORT_DATE_FORMAT</td>
<td align="left">‘m/d/Y’ 12/31/2015</td>
</tr>
<tr>
<td align="left">SHORT_DATETIME_FORMAT</td>
<td align="left">‘m/d/Y P’ 12/31/2019 11:59 p.m.</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>DATE_FORMAT: &#123;% now "DATE_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>DATETIME_FORMAT: &#123;% now "DATETIME_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>SHORT_DATE_FORMAT: &#123;% now "SHORT_DATE_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>SHORT_DATETIME_FORMAT: &#123;% now "SHORT_DATETIME_FORMAT" %&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DATE_FORMAT: March 26, 2019</span><br><span class="line">DATETIME_FORMAT: March 26, 2019, 3:45 a.m.</span><br><span class="line">SHORT_DATE_FORMAT: 03/26/2019</span><br><span class="line">SHORT_DATETIME_FORMAT: 03/26/2019 3:45 a.m.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后<code>now</code>标签也支持<code>as</code>的用法，可以方便我们在模板中使用一个已经格式化好的输出</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% now "Y-m-d H:i:s" as show_time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; show_time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发现时间输出不正确，记得查看<code>settings</code>文件下的<code>TIME_ZONE</code>配置</li>
</ul>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote>
<p>除了模板标签可以帮助我们对数据或者进行逻辑处理</p>
<p><code>django</code>中还提供了一款工具叫做过滤器，过滤器也可以实现一些模板变量的运算，判断或是其他逻辑处理</p>
</blockquote>
<h6 id="add"><a href="#add" class="headerlink" title="add"></a>add</h6><blockquote>
<p>语法：&#123;&#123; var1|add:var2 &#125;&#125;</p>
</blockquote>
<blockquote>
<p><code>add</code>过滤器可以实现<code>var1</code>与<code>var2</code>的相加，并且在遇到其他相同数据类型的，比如列表时，加号还可以重载为拼接功能</p>
</blockquote>
<blockquote>
<p>过滤器首先会将数据转换成Int类型，进行相加，如果转换失败，则会尝试使用<code>Python</code>中的数据类型</p>
<p>列表、元祖等这样的数据类型来进行转换，并且执行对应类型的加法</p>
<p>如果都转换失败，那么结果为一个空字符串</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>add :&#123;&#123; value|add:10 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>add :&#123;&#123; list_1|add:list_2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="capfirst"><a href="#capfirst" class="headerlink" title="capfirst"></a>capfirst</h6><blockquote>
<p>语法：&#123;&#123; var|capfirst &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将变量第一个字母变为大写，如果第一个字符不是字母，过滤器不生效</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>capfirst:&#123;&#123; "Abc"|capfirst &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>capfirst:&#123;&#123; "1abc"|capfirst &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="center"><a href="#center" class="headerlink" title="center"></a>center</h6><blockquote>
<p>语法：&#123;&#123; value|center:”length” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>使<code>value</code>在给定的<code>length</code>范围内居中</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>center: &#123;&#123; "abc"|center:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h6><blockquote>
<p>语法：&#123;&#123; value|cut:”str” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>在<code>value</code>中移除所有<code>str</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>cut: &#123;&#123; "a*b*c"|cut:"*" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="date"><a href="#date" class="headerlink" title="date"></a>date</h6><blockquote>
<p>语法：&#123;&#123; value|date:SHORT_DATE_FORMAT” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>与&#123;% now %&#125;标签所使用格式字符一致；<code>value</code>为一个<code>datetime</code>对象</p>
<p>输出最终格式与项目时区及语言设置有关</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime = datetime.datetime.now()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;date: &#123;&#123; datetime|date:&quot;H:i&quot; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;date: &#123;&#123; datetime|date:&quot;Y/m/d&quot; &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h6 id="default"><a href="#default" class="headerlink" title="default"></a>default</h6><blockquote>
<p>语法：&#123;&#123; value|default:”默认值” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>如果<code>value</code>值为假，则取”默认值”，反之返回<code>value</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default: &#123;&#123; 0|default:"这是展示的默认值" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>非空非0为真，0或空为假</p>
</blockquote>
<h6 id="default-if-none"><a href="#default-if-none" class="headerlink" title="default_if_none"></a>default_if_none</h6><blockquote>
<p>语法：&#123;&#123; value|default_if_none:”默认值” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>如果<code>value</code>值为<code>None</code>，则取”默认值”，反之返回<code>value</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default_if_none: &#123;&#123; None|default_if_none:"value值为None" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>default_if_none: &#123;&#123; 0|default_if_none:"aaaa" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="dictsort"><a href="#dictsort" class="headerlink" title="dictsort"></a>dictsort</h6><blockquote>
<p>语法：&#123;&#123; value|dictsort:”attr” &#125;&#125;</p>
</blockquote>
<blockquote>
<p><code>value</code>为字典列表数据，列表中数据均为类字典数据：<code>[ {1:&#39;a&#39;}, {2:&#39;b&#39;}, ]</code></p>
<p>根据给定<code>attr</code>值进行排序，一般是<strong>从小到大</strong>的顺序</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sort_list_dict = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小绿'</span>, <span class="string">'department'</span>: <span class="string">'Development'</span>, <span class="string">'age'</span>: <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小红'</span>, <span class="string">'department'</span>: <span class="string">'Leader'</span>, <span class="string">'age'</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小飞'</span>, <span class="string">'department'</span>: <span class="string">'Test'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小落'</span>, <span class="string">'department'</span>: <span class="string">'Development'</span>, <span class="string">'age'</span>: <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'大胖'</span>, <span class="string">'department'</span>: <span class="string">'Leader'</span>, <span class="string">'age'</span>: <span class="number">43</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>dictsort: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% for var in sort_list_dict|dictsort:"age" %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; var.name &#125;&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="dictsortreversed"><a href="#dictsortreversed" class="headerlink" title="dictsortreversed"></a>dictsortreversed</h6><blockquote>
<p>语法：&#123;&#123; value|dictsortreversed:”attr” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>与<code>dictsort</code>功能相同，但是排序方式与<code>dictsort</code>相反，从大到小</p>
</blockquote>
<h6 id="divisibleby"><a href="#divisibleby" class="headerlink" title="divisibleby"></a>divisibleby</h6><blockquote>
<p>语法：&#123;&#123; value|divisibleby:num &#125;&#125;</p>
</blockquote>
<blockquote>
<p>如果给定的<code>value</code>可以被<code>num</code>整除，返回<code>True</code>；反之，返回<code>False</code></p>
<p>常用来做整除判断</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>divisibleby: &#123;&#123; 8|divisibleby:2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h6><blockquote>
<p>语法：&#123;&#123; value|escape &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将value值转义输出；</p>
<p>可以在取消转义autoescape标签下，选择性的打开某些需要转义的数据</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    &#123;&#123; str_|escape &#125;&#125;</span><br><span class="line">    &#123;&#123; str_ &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="safe"><a href="#safe" class="headerlink" title="safe"></a>safe</h6><blockquote>
<p>语法：&#123;&#123; value|safe &#125;&#125;</p>
</blockquote>
<blockquote>
<p>取消转义，与&#123;% autoescape off %&#125;标签意义相同</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str_|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="safeseq"><a href="#safeseq" class="headerlink" title="safeseq"></a>safeseq</h6><blockquote>
<p>语法：&#123;&#123; value|safeseq &#125;&#125;</p>
</blockquote>
<blockquote>
<p>处理一个包含标签字符串的列表数据，简单的<code>safe</code>是不行的，因为<code>safe</code>过滤器会把内容先整体处理为字符串；而不是依次过滤序列中的数据，而<code>safeseq</code>过滤器则会依次处理序列中的每一个数据</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">list_ = [</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h2</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>",</span><br><span class="line">    "<span class="tag">&lt;<span class="name">h3</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>",</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; list_|safe|join:&quot;&quot; &#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">------------------</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123; list_|safeseq|join:&quot;&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="filesizeformat"><a href="#filesizeformat" class="headerlink" title="filesizeformat"></a>filesizeformat</h6><blockquote>
<p>语法：&#123;&#123; value|filesizeformat &#125;&#125;</p>
</blockquote>
<blockquote>
<p>格式化value值为人类可读的计算机存储单位。如：1 bytes、1.2 MB；</p>
<p>如果不是一个可以处理的数值类型，返回0。</p>
<p>最小单位为byte</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>filesizeformat : &#123;&#123; "1"|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>filesizeformat : &#123;&#123; "3758331"|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="first"><a href="#first" class="headerlink" title="first"></a>first</h6><blockquote>
<p>语法：&#123;&#123; value|first &#125;&#125;</p>
</blockquote>
<blockquote>
<p>返回序列数据<code>value</code>中的第一项</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>first : &#123;&#123; "abc"|first &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="last"><a href="#last" class="headerlink" title="last"></a>last</h6><blockquote>
<p>语法：&#123;&#123; value|last &#125;&#125;</p>
</blockquote>
<blockquote>
<p>返回序列数据<code>value</code>中的最后一项</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>last : &#123;&#123; "abc"|last &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="floatformat"><a href="#floatformat" class="headerlink" title="floatformat"></a>floatformat</h6><blockquote>
<p>语法：&#123;&#123; value|floatformat:”精度” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>设置浮点数<code>value</code>的精度，没有参数时，默认四舍五入<strong>保留小数点后一位</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.2332"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.2550"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>floatformat : &#123;&#123; "2.0000"|floatformat:"2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><blockquote>
<p>语法：&#123;&#123; value|join:”str” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将序列数据<code>value</code>通过<code>str</code>进行拼接</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>join : &#123;&#123; "abc"|join:"*" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="length-is"><a href="#length-is" class="headerlink" title="length_is"></a>length_is</h6><blockquote>
<p>语法：&#123;&#123; value|length_is:”num” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>判断序列<code>value</code>的长度是否为<code>num</code>，如果是，返回<code>True</code>，反之返回<code>False</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;length_is : &#123;&#123; &quot;abc&quot;|length_is:4 &#125;&#125;&lt;/p&gt;&lt;p&gt;length_is : &#123;&#123; &quot;abcd&quot;|length_is:4 &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h6 id="linebreaksbr"><a href="#linebreaksbr" class="headerlink" title="linebreaksbr"></a>linebreaksbr</h6><blockquote>
<p>语法：&#123;&#123; value|linebreaksbr &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将字符串<code>value</code>中的所有换行符<code>\n</code>转换为<code>HTML</code>换行符<code>&lt;br&gt;</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">str_ = "abc\nbbb"</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linebreaksbr : &#123;&#123; str_|linebreaksbr &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="linenumbers"><a href="#linenumbers" class="headerlink" title="linenumbers"></a>linenumbers</h6><blockquote>
<p>语法：&#123;&#123; value|linenumbers &#125;&#125;</p>
</blockquote>
<blockquote>
<p>显示<code>value</code>数据的行号，一般来说，是根据<code>value</code>字符串中的<code>\n</code>换行来确定每一行</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">str_ = "abc\nbbb"</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linenumbers :<span class="tag">&lt;<span class="name">br</span>&gt;</span> &#123;&#123; str_|linenumbers &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>linenumbers :<span class="tag">&lt;<span class="name">br</span>&gt;</span> &#123;&#123; str_|linenumbers|linebreaksbr &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="ljust"><a href="#ljust" class="headerlink" title="ljust"></a>ljust</h6><blockquote>
<p>语法：&#123;&#123; value|ljust:”num” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将字符串<code>value</code>按照给定宽度<code>num</code>左对齐</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>ljust : &#123;&#123;"test"|ljust:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>HTML中</code>空格是被忽略的，所以直观的我们并看不到这个过滤器的对齐效果</p>
<p>需要使用<code>&amp;nbsp</code>才可以在<code>HTML</code>中展示真正的空格效果，这个操作会在之后的自定义过滤器中为大家介绍</p>
</blockquote>
<h6 id="rjust"><a href="#rjust" class="headerlink" title="rjust"></a>rjust</h6><blockquote>
<p>语法：&#123;&#123; value|rjust:”num” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将字符串<code>value</code>按照给定宽度<code>num</code>右对齐</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>rjust : &#123;&#123; "test"|rjust:"10" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h6><blockquote>
<p>语法：&#123;&#123; value|lower &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将字符串<code>value</code>中的全部字符串小写</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>rjust : &#123;&#123; "Aa123Bb"|lower &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h6><blockquote>
<p>语法：&#123;&#123; value|upper &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将字符串<code>value</code>中的全部字符串大写</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>upper : &#123;&#123; "Aa123Bb"|upper &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="title"><a href="#title" class="headerlink" title="title"></a>title</h6><blockquote>
<p>语法：&#123;&#123; value|title &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将<code>value</code>字符串中每一个单词首字母大写，其余字符小写</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>title : &#123;&#123; "heLLO a12b world"|title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="make-list"><a href="#make-list" class="headerlink" title="make_list"></a>make_list</h6><blockquote>
<p>语法：&#123;&#123; value|make_list &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将<code>value</code>转换为列表</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>make_list : &#123;&#123; "a1好a2a"|make_list &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">['a', '1', '好', 'a', '2', 'a']</span><br></pre></td></tr></table></figure>

<h6 id="random"><a href="#random" class="headerlink" title="random"></a>random</h6><blockquote>
<p>语法：&#123;&#123; value|random &#125;&#125;</p>
</blockquote>
<blockquote>
<p>返回<code>value</code>序列中的一个随机值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>random : &#123;&#123; "12345"|random &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h6><blockquote>
<p>语法：&#123;&#123; value|slice:”start:stop:step” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>与<code>Python</code>中序列切片用法类似，取出一定范围内的数据</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:5" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:6" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>slice : &#123;&#123; "abcdef"|slice:"0:6:2" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><blockquote>
<p>语法：&#123;&#123; value|time:”time_format” &#125;&#125;</p>
</blockquote>
<blockquote>
<p>与<code>date</code>过滤器类似，但该过滤器只处理时、分、秒；</p>
<p>根据时间格式化字符输出时间，输出最终格式与项目时区及语言设置有关</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime = datetime.datetime.now()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time: &#123;&#123; datetime|time:"H:i" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time: &#123;&#123; datetime|time:"Y/m/d" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="timesince"><a href="#timesince" class="headerlink" title="timesince"></a>timesince</h6><blockquote>
<p>语法：&#123;&#123; start_time|timesince:end_time &#125;&#125;</p>
</blockquote>
<blockquote>
<p>计算从<code>start_time</code>一直到<code>end_time</code>的时间间隔，<code>end_time</code>为可选，没有该值，截至从当前时间开始</p>
<p>分钟为返回最小单位</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_time = datetime.datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>)</span><br><span class="line">end_time = datetime.datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time : &#123;&#123; start_time|timesince:end_time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span></span></span><br><span class="line">&lt;p&gt;time : &#123;&#123; start_time|timesince &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">time : 2 days, 2 hours</span><br><span class="line">time : 3 weeks, 2 days</span><br></pre></td></tr></table></figure>

<h6 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h6><blockquote>
<p>语法：&#123;&#123; value|urlencode &#125;&#125;</p>
</blockquote>
<blockquote>
<p>使用连接编码格式处理<code>value</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlencode : &#123;&#123; "http://example.com"|urlencode &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">urlencode : http%3A//example.com</span><br></pre></td></tr></table></figure>

<h6 id="urlize"><a href="#urlize" class="headerlink" title="urlize"></a>urlize</h6><blockquote>
<p>语法：&#123;&#123; value|urlize &#125;&#125;</p>
</blockquote>
<blockquote>
<p>使连接字符串<code>value</code>变为可点击的a标签连接</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlize : &#123;&#123; "http://example.com"|urlize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>urlize : &#123;&#123; "http://example.com" &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="人性化过滤器"><a href="#人性化过滤器" class="headerlink" title="人性化过滤器"></a>人性化过滤器</h5><blockquote>
<p>除去上面所介绍的过滤器，django还提供了一个专门人性化处理数据的过滤器组件；</p>
<p>使用时，需要将<strong>‘django.contrib.humanize’</strong>添加到<code>settings.py</code>文件中的<code>INSTALLED_APPS</code>属性中</p>
<p>之后在模板页面加载&#123;% load humanize %&#125;就可以使用到<code>humanize</code>中的人性化过滤器</p>
</blockquote>
<h6 id="apnumber"><a href="#apnumber" class="headerlink" title="apnumber"></a>apnumber</h6><blockquote>
<p>语法：&#123;&#123; value|apnumber &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将整数转化为字符串，并按照语言设置返回对应的数字表示方式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intcomma : &#123;&#123; "3000"|intcomma &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intcomma : &#123;&#123; "23300"|intcomma &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="intword"><a href="#intword" class="headerlink" title="intword"></a>intword</h6><blockquote>
<p>语法：&#123;&#123; value|intword &#125;&#125;</p>
</blockquote>
<blockquote>
<p>将一个大型数字转换成友好的文字表达形式，适合超过<code>100万</code>的数字</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>intword : &#123;&#123; "310100100"|intword &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="naturalday"><a href="#naturalday" class="headerlink" title="naturalday"></a>naturalday</h6><blockquote>
<p>语法：&#123;&#123; value|naturalday &#125;&#125;</p>
</blockquote>
<blockquote>
<p>返回value时间相对于今天。返回”今天”，”明天”或者”昨天”</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">today = datetime.datetime.now()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>naturalday : &#123;&#123; today|naturalday &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="naturaltime"><a href="#naturaltime" class="headerlink" title="naturaltime"></a>naturaltime</h6><blockquote>
<p>语法：&#123;&#123; value|naturaltime &#125;&#125;</p>
</blockquote>
<blockquote>
<p>获得<code>value</code>与当前时间的时间间隔，并使用合适的文字来描述；</p>
<p>如果超过一天间隔，将会使用<code>timesice</code>过滤器格式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">start_time = datetime.datetime(2019, 3, 3, 15)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>naturalday : &#123;&#123; start_time|naturaltime &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><blockquote>
<p>虽然有了django给我们提供的这么多方便的标签和过滤器；</p>
<p>但是有些时候，还不能达成我们想要的功能，那么就需要我们自定义标签和过滤器</p>
<p>django默认的过滤器及标签文件夹：</p>
<p> <code>django/template/defaultfilters.py</code></p>
<p> <code>django/template/defaulttags.py</code></p>
</blockquote>
<ol>
<li><p>在<strong>当前app下</strong>创建保存自定义标签及过滤器的文件夹，这个文件夹常命名为<code>templatetags</code></p>
</li>
<li><p>为了支持该文件夹可以作为模块导入，<code>templatetags</code>文件夹下创建<code>__init__.py</code>文件</p>
</li>
<li><p>创建过滤器<code>xxxx.py</code>文件，文件名自定义</p>
</li>
<li><p>过滤器文件头部必须包含名为<code>register</code>的全局变量，该变量是<code>template.Library</code>对象的实例</p>
</li>
<li><p>自定义过滤器为一个<code>Python</code>函数，参数可以是<code>1-2</code>个</p>
<ul>
<li>比如&#123;&#123; value|upper &#125;&#125;，过滤器函数名为<code>upper</code>，参数为<code>value</code></li>
</ul>
<blockquote>
<p>注意：过滤器参数可以是一个字符串，也可以使类似列表的其他类型，参数可以设置默认值。另外需要注意的是模板中无法进行异常处理，过滤器一旦出现错误，将会引发服务器错误</p>
</blockquote>
</li>
<li><p>最重要的一步，所有编写完成的过滤器函数，都要记得：使用<code>register.filter()</code>函数将其注册为<code>Library</code>实例</p>
<ul>
<li><p><code>register.filter(name=None, filter_func=None)</code>：注册过滤函数</p>
<blockquote>
<p><code>name</code>：一个字符串，表示过滤器在模板的使用名称</p>
<p><code>filter_func</code>：编写好的过滤器函数</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app/templatetags/my_filter.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_length</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment">#  返回变量长度</span></span><br><span class="line">    <span class="keyword">return</span> len(str(value))</span><br><span class="line"></span><br><span class="line">register.filter(<span class="string">"return_length"</span>,return_length)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 'abc'|return_length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 返回3 --&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外：除了我们使用<code>register.filter</code>函数来对过滤器函数进行注册；</p>
<p>还可以将<code>register.filter</code>作为装饰器<code>@register.filter</code>来使用，可以更加方便的进行过滤器函数注册</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter(name="delete_space")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_space</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment"># 去掉value数据中所有空格</span></span><br><span class="line">	<span class="keyword">return</span> value.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，这里有个问题，我们的过滤器经常期望处理的数据类型是一个字符串，但是以上过滤器如果在对数字类型进行处理时，会引发<code>&#39;int&#39; object has no attribute &#39;replace&#39;</code>，这样的错误，那么需要我们对传入过滤器的value参数进行字符串转变的处理</p>
<p>解决办法也很简单，大家可能想到了直接用字符串工厂函数去转换传入参数、但是这里有更加优雅安全的方式，通过<code>django.template.defaultfilter</code>模块下的<code>stringfilter</code>装饰器来对过滤器函数进行装饰</p>
<p><code>stringfilter</code><strong>这个装饰器可以帮助我们把传入过滤器函数的参数转换为它的字符串值</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template.defaultfilters <span class="keyword">import</span> stringfilter</span><br><span class="line"><span class="meta">@register.filter(name="delete_space")</span></span><br><span class="line"><span class="meta">@stringfilter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_space</span><span class="params">(value)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> value.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在过滤器函数的<code>value</code>参数将会先被装饰器<strong>@stringfilter</strong>处理成对应的字符串类型之后</p>
<p>才会被作为参数传递到过滤器函数<code>delete_space</code>中</p>
<p>接下来通过这个过滤器处理一个<strong>非字符串类型</strong>也就不会在报错了</p>
</blockquote>
<h5 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h5><blockquote>
<p>标签要实现的功能可以比过滤器更加强大，可以支持接收更多参数！</p>
</blockquote>
<blockquote>
<p>基本使用语法 &#123;% tag “arg1” “arg2” “arg3” … %&#125;</p>
</blockquote>
<blockquote>
<p>很多模板标签可以接收多个参数，字符串或者模板变量；并且可以将这些变量经过一系列处理之后返回一个字符串这样的标签我们可以通过django为我们提供的<code>simple_tag()</code>注册函数来进行编写，该函数来自于<code>django.template.Library</code></p>
</blockquote>
<blockquote>
<p>同样的，编写自定义标签函数完成之后，也需要进行注册，也可以直接将<code>@simple_tag</code>作为装饰器使用注册</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line"></span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag(name="myUpper")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myUpper</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="comment"># 将模板变量处理为纯大写的模板标签</span></span><br><span class="line">    <span class="keyword">return</span> str(value).upper()</span><br><span class="line"><span class="comment"># register.simple_tag(name="myUpper",func=myUpper)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>simple_tag()</code>函数在这里帮助我们做了如下工作：</p>
<ul>
<li><p>检查标签函数所需参数数量</p>
</li>
<li><p>截掉参数中的引号，确保函数接收到的是一个普通的字符串</p>
</li>
<li><p>截掉参数中的引号，确保函数接收到的是一个普通的字符串</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果我们希望标签函数可以访问到当前模板中其他全部的模板变量值；</p>
<p>那么可以使用simple_tag(takes_context=True)参数</p>
<p>比如通过视图函数向模板返回了</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">value = '哈哈哈哈哈哈'</span><br><span class="line">return render(request, template, locals())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在自定义标签处通过<code>simple_tag(takes_context=True)</code>来进行视图函数中<code>content</code>值的获取；</p>
<p>但是还要注意的是，此时自定义标签函数参数位置第一个必须为<code>context</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@register.simple_tag(takes_context=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_context</span><span class="params">(context)</span>:</span></span><br><span class="line">	value = context.get(<span class="string">"value"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"获取到的模板变量:%s"</span> % value</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板页面直接使用</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;% get_context %&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h5><blockquote>
<p>关于模板，经常重复的编写页面是一个非常痛苦的事情；</p>
<p>那么在<code>django</code>中也提供了一种非常舒服方便的方法，可以使新的模板页面来继承自一个已编写好的<code>html</code>页面实现复用，免去重复工作；这就是模板继承</p>
</blockquote>
<h6 id="block"><a href="#block" class="headerlink" title="block"></a>block</h6><blockquote>
<p>页面的继承不能说全部都拿过来，有时候只需要已经编写好的页面某些部分</p>
<p>其他部分提前挖好一些坑，去填充不同内容</p>
<p>挖坑可以通过模板中的&#123;% block %&#125;标签</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% block name %&#125;</span><br><span class="line">	预留区域，可供未来继承的页面覆盖</span><br><span class="line">&#123;% endblock name %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设计一个可以被继承的父模板，我们经常叫做base.html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% block title %&#125;</span><br><span class="line">        父模板标题</span><br><span class="line">        &#123;% endblock title %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% block top %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>这里是父模板页面内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个页面中，我们设计了三个<code>block</code>标签块<code>title</code>、<code>content</code>以及<code>top</code>；</p>
<p>每一个块都可以被之后继承的页面所覆盖新的内容</p>
</blockquote>
<ul>
<li>继承页面使用&#123;% extends “base.html” %&#125;标签进行页面的继承，现在编写一个test.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">    子模版</span><br><span class="line">&#123;% endblock title %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block top %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子模版<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% block other %&#125;</span><br><span class="line">    哈哈哈哈哈</span><br><span class="line">    这里的内容不会显示</span><br><span class="line">    父模板并没有这样的block块</span><br><span class="line">&#123;% endblock other%&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了对应<code>block</code>标签内容被子模板修改，其余内容均默认使用父模板中的</p>
</blockquote>
<ul>
<li><p>注意：</p>
<ul>
<li><p>如果父模板内有模板变量或者其他上下文数据，不会被子模板继承，但是子模板可以为父模板内的模板数据赋值</p>
</li>
<li><p>如果需模板中具有模板变量等上下文数据，只有放到<code>block</code>标签块内数据才会显示</p>
</li>
<li><p>子模板中修改父模板中并不存在的block块，子模板不会显示</p>
</li>
</ul>
</li>
</ul>
<h5 id="模板加载"><a href="#模板加载" class="headerlink" title="模板加载"></a>模板加载</h5><blockquote>
<p>除了&#123;% extends %&#125;与&#123;% block %&#125;结合的方式可以继承一个父模板</p>
<p>我们还可以使用&#123;% include %&#125;一个新的标签进行模板加载，<code>include</code>标签使用语法与<code>extends</code>类似</p>
</blockquote>
<h6 id="include"><a href="#include" class="headerlink" title="include"></a>include</h6><blockquote>
<p>现在新建一个html文件，名为<code>li.html</code>，用来写一个简单的列表</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>玩耍<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; var &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在需要导入的页面中使用&#123;% include “li.html” %&#125;进行引入</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">    子模版</span><br><span class="line">&#123;% endblock title %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block top %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子模板<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endblock top %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子模版<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% include "li.html" %&#125;</span><br><span class="line">&#123;% endblock content %&#125; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>被<code>include</code>引入的新模板，会在渲染完成之后添加到父模板所给定的对应<code>block</code>块中</p>
</blockquote>
<blockquote>
<p>与<code>extends</code>不同，<code>extends</code>常用来控制整个模板的样式和效果；</p>
<p>而<code>include</code>更加细化，可以在一个模板内包含其他多个模板</p>
<p><strong>如果include所包含的模板页面中有模板变量需要被填充，会在包含include的页面下进行渲染</strong></p>
<p>这种行为也好像是，把一个新的渲染好的<code>html</code>页面嵌入了进来一样</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Urls-路由层</title>
    <url>/2005/01/05/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/</url>
    <content><![CDATA[<h4 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h4><blockquote>
<p>路由是Web服务的入口，就好像办事大厅有各个服务窗口一样</p>
</blockquote><a id="more"></a>
<blockquote>
<p>Django奉行DRY主义，提倡使用简洁、优雅的URL：</p>
<p> 可以不用<code>.html</code>、<code>.php</code>或<code>.cgi</code>之类后缀</p>
<p> 尽量不要单独使用无序随机数字这样无意义的东西</p>
<p> 让你随心所欲设计你的URL，不受框架束缚</p>
</blockquote>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><h6 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h6><blockquote>
<p>urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系</p>
<p>用户发起的请求<code>URL</code>都会首先进入主控制目录下的这个<code>urls.py</code>文件中进行查找匹配</p>
</blockquote>
<ol>
<li>首先找到<code>urls.py</code>下的<code>urlpatterns</code>全局变量，这是一个路由规则实例的列表数据。</li>
<li>按照先后定义顺序，进行路由匹配。</li>
<li>找到第一个匹配项时停止匹配，执行匹配到的视图函数。</li>
<li>遍历完全，未发现匹配，<code>django</code>进行异常处理</li>
</ol>
<blockquote>
<p>其中<code>urlpatterns</code>中的每一个路由映射规则可以由<code>path</code>或<code>re_path</code>进行构造</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<code>Django</code>的路由不考虑<code>HTTP</code>请求方式，仅根据URL进行路由；即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p>
</blockquote>
<h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><ul>
<li><p><code>path(regex, view, kwargs=None, name=None)</code></p>
<blockquote>
<p><code>regex</code>：一个匹配对应url地址的规则字符串。</p>
<p><code>view</code>：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函</p>
<p><code>kwargs</code>：视图函数的关键字参数。</p>
<p><code>name</code>：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为<code>url</code>取变量名，接下来全局使用该命名值即可；当对应<code>url</code>路由改变之后，结合路由反向解析使用的地方不需要更改路由</p>
<p>此外，<code>django</code>还提供了一个兼容老版本<strong>url</strong>路由配置函数的<strong>re_path</strong>函数；<code>re_path</code>：第一个参数部分为一个正则匹配规则，其他与path同</p>
</blockquote>
</li>
</ul>
<h5 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h5><blockquote>
<p>静态路由用来映射对应视图函数，以下是一个简单的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Worlds!'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.index),</span><br><span class="line">    re_path(<span class="string">r"^"</span>,views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><blockquote>
<p>有的时候，我们的路由设置不能一直维持一个一成不变的状态；</p>
<p>比如遇到一些内容翻页的场景，那么我们的连接可能是：<code>xx.com/airticle_list/1/</code>、<code>xx.com/airticle_list/2/</code></p>
<p>那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request,x,y)</span>:</span></span><br><span class="line">    content = <span class="string">"x:%s\ny:%s"</span> % (x,y)  </span><br><span class="line">	<span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义如上函数，将会接收连接中的后两部份<code>path</code>值作为参数，分别依次给到<code>x</code>和<code>y</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;int:x&gt;/&lt;str:y&gt;/'</span>,views.index),</span><br><span class="line">    <span class="comment">#指明类型</span></span><br><span class="line">    path(<span class="string">"&lt;x&gt;/&lt;y&gt;/"</span>,views.index)</span><br><span class="line">    <span class="comment">#不指明类型</span></span><br><span class="line">    re_path(<span class="string">r"^(?P&lt;x&gt;\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$"</span>),</span><br><span class="line">    <span class="comment"># (?P&lt;name&gt;pattern) 正则分组</span></span><br><span class="line">    re_path(<span class="string">r"^(\d+)/([a-zA-Z]+)/$"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上；</p>
<p>访问：<code>http://127.0.0.1:8000/1/abc/</code></p>
<p>其中<code>1</code>将作为x的参数值，<code>abc</code>将作为y的参数</p>
<p>但如果访问连接是：<code>http://127.0.0.1:8000/abc/abc/</code>，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定</p>
</blockquote>
<ul>
<li>内置Path转换器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式</span><br><span class="line">int：匹配正整数，包含<span class="number">0</span></span><br><span class="line">slug：匹配字母、数字以及横杠、下划线组成的字符串</span><br><span class="line">uuid：匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00</span><br><span class="line">path：匹配任何非空字符串，包含了路径分隔符</span><br></pre></td></tr></table></figure>

<h6 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h6><blockquote>
<p>除了以上<code>django</code>所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义<code>path</code>转换器</p>
</blockquote>
<ol>
<li><p>定义转换器类，类名随意</p>
</li>
<li><p>定义类中必须属性</p>
<blockquote>
<p><code>regex</code>：一个字符串形式的正则表达式，也是对应的路由规则</p>
<p><code>to_python(self, value)</code>：用于将匹配到的路由字符串转换为<code>Python</code>中的数据类型，并传递给视图函数，<strong>如果转换失败，必须抛出ValueError</strong>，路由映射视图函数时使用</p>
<p><code>to_url(self, value)</code>：将<code>Python</code>数据类型转换为一段url的方法，<code>to_python</code>方法的反向操作，反向解析时使用</p>
</blockquote>
</li>
<li><p>通过django.urls模块中的register_converter函数进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数第一个参数为转换器类</span><br><span class="line">函数第二个参数为转换器别名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>以下定义一个路由参数只能是三位字符的路由规则</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先将转换器类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeChar</span>:</span></span><br><span class="line">    regex = <span class="string">"[a-zA-Z]&#123;3&#125;"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"to_python"</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        <span class="comment"># 当通过反向路由解析时，将会调用该函数</span></span><br><span class="line">        print(<span class="string">'to_url'</span>)</span><br><span class="line">        <span class="keyword">return</span> str(value)[:<span class="number">3</span>] </span><br><span class="line">    	<span class="comment">#此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则</span></span><br><span class="line"><span class="comment">#注册转换器</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converter</span><br><span class="line">register_converter(ThreeChar,<span class="string">'tc'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index)</span><br><span class="line">]</span><br><span class="line"><span class="comment">#127.0.0.1:8000/aaa/bbb/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">app_name = <span class="string">"app"</span></span><br><span class="line">path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index, name=<span class="string">"threechr"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app:threechr"</span>,args=(<span class="string">'aaaa'</span>,<span class="string">'bbbb'</span>)))</span><br><span class="line"><span class="comment">#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位</span></span><br></pre></td></tr></table></figure>

<h5 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h5><blockquote>
<p>我们的路由编写都是在项目主要目录下的<code>urls.py</code>文件中，但是如果<code>app</code>有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情</p>
<p>其实在之前的练习中，我们使用的方式均是路由分发，每个子<code>app</code>都拥有自己独立的<code>urls.py</code>路由映射文件，而主控路由文件里只需要使用<code>include</code>函数导入子<code>app</code>下路由文件即可，这就是路由分发</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"urlapp.urls"</span>)) <span class="comment"># 使用include 实现路由分发，找到子app下的路由文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由分发为我们带来的好处有很多，可以让我们在多个<code>app</code>的项目中更加方便有效的管理每一个路由</p>
<p>并且也可以让我们的用户在访问时看到浏览器中的<code>URL</code>地址更加<strong>赏心悦目</strong></p>
</blockquote>
<h5 id="路由反向解析"><a href="#路由反向解析" class="headerlink" title="路由反向解析"></a>路由反向解析</h5><blockquote>
<p>到了这里，思考一下，之前我们已经设置过了很多路由；</p>
<p>但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把<code>aaa</code>换成了<code>aba</code>，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难</p>
</blockquote>
<blockquote>
<p><code>django</code>也为我们提供了一个解决办法，通过为路由映射使用<code>name</code>参数，来为每一个路由映射设置一个独立唯一的变量名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">'left/&lt;str:x&gt;/'</span>,views.left, name=<span class="string">"left"</span>),</span><br><span class="line">path(<span class="string">'right/&lt;int:x&gt;/'</span>,views.right, name=<span class="string">"right"</span>),</span><br><span class="line"><span class="comment"># 通过正则命名分组方式</span></span><br><span class="line">re_path(<span class="string">r'^left/([a-zA-Z]+)/$'</span>,views.left,name=<span class="string">"left"</span>),</span><br><span class="line">re_path(<span class="string">r'^right/(?P&lt;x&gt;\d+)/$'</span>,views.right, name=<span class="string">"right"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>两个视图函数对应如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: str</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"left.html"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: int</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">'message'</span>:x,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"right.html"</span>,content)</span><br></pre></td></tr></table></figure>

<ul>
<li>两个HTML页面</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;我是左页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'right' 123 %&#125;"&gt;右页面&lt;/a&gt;</span><br><span class="line">&lt;!-- ------另一个页面------ --&gt;</span><br><span class="line">&lt;p&gt;我是右页面&lt;/p&gt;</span><br><span class="line">&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;a href="&#123;% url 'left' 'abc' %&#125;"&gt;右页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在模板页面中，对于已命名路由可以通过 &#123;% url “name” “arg” %&#125;模板标签进行反向解析</p>
<p>参数以空格隔开，在标签后传入</p>
</blockquote>
<ul>
<li>视图函数反向解析</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">"left"</span>,args=(<span class="string">'aaa'</span>,) ))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在视图函数中需要使用到路由命名时，进行反向解析需要我们通过<code>django.shortcuts</code>模块下的<code>reverse</code>函数</p>
</blockquote>
<ul>
<li><code>reverse(viewname,args=None,kwargs=None)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">参数介绍</span><br><span class="line">viewname：视图函数、命名路由映射、或视图函数路径的字符串</span><br><span class="line">args：元组形式路由传参。</span><br><span class="line">kwargs：字典形式路由传参</span><br></pre></td></tr></table></figure>

<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><blockquote>
<p>如果想在多个<code>app</code>下使用相同的<code>name</code>路由命名，那么我们可以通过路由分发过程中的include函数来指定不同<code>app</code>所属的命名空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include((<span class="string">"app1.urls"</span>,<span class="string">'app1'</span>))),</span><br><span class="line">    <span class="comment">#直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间</span></span><br><span class="line">    path(<span class="string">'app2/'</span>,include((<span class="string">"app2.urls"</span>,<span class="string">'app2'</span>)))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当为每个<code>app</code>的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> redirect(reverse(<span class="string">"app1:left"</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' %&#125;"</span>&gt;</span>app2:left<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="应用命名空间：app-name"><a href="#应用命名空间：app-name" class="headerlink" title="应用命名空间：app_name"></a>应用命名空间：app_name</h6><blockquote>
<p>使用<code>app_name</code>指明命名空间，在子<code>app</code>的<code>urls.py</code>文件下配置全局变量<code>app_name</code>，这个值是唯一的</p>
<p>在这个路由文件中定义的其他映射关系，将具有命名空间<code>app1</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app_name = <span class="string">"app1"</span> <span class="comment"># 这个值应该是唯一的</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">   	...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="实例命名空间：namespace"><a href="#实例命名空间：namespace" class="headerlink" title="实例命名空间：namespace"></a>实例命名空间：namespace</h6><blockquote>
<p>当有多个子<code>app</code>同时引入同一个子路由映射文件，比如这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆，</p>
<p>此时需要给每一个路由分发的规则设置<code>namespace</code>属性，为实例进行命名空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app1"</span>)),</span><br><span class="line">    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app2"</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样做的好处，可以在不同路由导向同一<code>app</code>下时，为他们的不同命名空间；</p>
<p>虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作</p>
<p>接下来视图及模板页面中使用<code>namespace</code>的值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:right' 123 %&#125;"</span>&gt;</span>app1的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:left' 'abc' %&#125;"</span>&gt;</span>app1的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ----------------------------------------- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:right' 123 %&#125;"</span>&gt;</span>app2的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' 'abc' %&#125;"</span>&gt;</span>app2的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Views-视图层</title>
    <url>/2005/01/03/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/</url>
    <content><![CDATA[<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><blockquote>
<p>视图函数一般用来接收一个<code>Web</code>请求<code>HttpRequest</code>，之后返回一个Web响应<code>HttpResponse</code></p>
</blockquote><a id="more"></a>
<h4 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h4><blockquote>
<p>一个视图函数用来响应用户的<code>Request</code>请求，每个视图函数默认的第一个位置参数<code>request</code>用来接收用户发起请求的<code>HttpRequest</code>信息。</p>
<p>视图函数的返回值，为一个<code>HttpResponse</code>值，包括我们要返回给用户的<code>HTML</code>页面或者字符串等等，以及对应的头部字段信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> HttpResponse(<span class="string">'Hello world'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="常见请求方式"><a href="#常见请求方式" class="headerlink" title="常见请求方式"></a>常见请求方式</h4><blockquote>
<p><code>POST</code>和<code>GET</code>是<code>HTTP</code>协议定义的与服务器交互的方法。</p>
<p><code>GET</code>一般用于获取/查询资源信息，而<code>POST</code>一般用于更新资源信息。另外，还有<code>PUT</code>和<code>DELETE</code>方法</p>
</blockquote>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><blockquote>
<p>常用来从指定地址请求数据；</p>
<p>如果需要在请求时提交某些数据，则以路由形式传递参数，查询<code>Query</code>字符串如下格式所示：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/?key=abc&amp;pos=hebei</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get</code>请求可被浏览器缓存，保存在历史记录中</li>
<li><code>get</code>不应在使用敏感数据时使用，明文包路在请求地址中</li>
<li><code>get</code>有长度限制</li>
</ul>
<h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><blockquote>
<p>向指定的资源提交要被处理的数据</p>
<p>使用<code>POST</code>，提交的数据保存在<code>HTTP</code>协议中的消息主体部分</p>
</blockquote>
<ul>
<li><code>post</code>请求不会被浏览器缓存</li>
<li><code>post</code>提交数据长度无限制</li>
<li><code>post</code>比<code>get</code>更加安全</li>
</ul>
<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><blockquote>
<p>如果说<code>urls.py</code>是<code>Django</code>中前端页面和后台程序桥梁，那么<code>request</code>就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于<code>requests</code>中</p>
</blockquote>
<h5 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h5><blockquote>
<p>获取当前用户请求方式，</p>
<p>请求方式字符串为纯大写：<code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code></p>
<p>如用户以<code>get</code>方式发起请求，对应代码中获取到的结果以及在判断时像是这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">		…</span><br></pre></td></tr></table></figure>

<h5 id="request-GET"><a href="#request-GET" class="headerlink" title="request.GET"></a>request.GET</h5><blockquote>
<p>当用户通过<code>get</code>方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(request.GET) </span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt;</span></span><br><span class="line">    print(type(request.GET)) </span><br><span class="line">    <span class="comment"># &lt;class 'django.http.request.QueryDict'&gt;</span></span><br><span class="line">    name_ = request.GET.get(<span class="string">'name'</span>)</span><br><span class="line">    id_ = request.GET.get(<span class="string">'id'</span>)</span><br><span class="line">    content = <span class="string">'%s:%s'</span> % (name_,id_)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>request.GET</code>是一个类似字典的数据类型：<code>QueryDict</code></p>
<p>其中也支持类似对字典的<code>get</code>或直接<code>dict.[key]</code>键值访问方式，当然使用<code>get</code>方式进行对应<code>key</code>获取会更好，因为<code>get</code>在访问不到时不会报错</p>
</blockquote>
<ul>
<li>如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/?name=jack&amp;id=1</span><br></pre></td></tr></table></figure>

<ul>
<li>这里对应页面会显示的结果：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">jack:1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：使用<code>GET</code>方法在连接中进行参数提交，后台接收到的数据类型均是字符串</p>
</blockquote>
<hr>
<h5 id="request-POST"><a href="#request-POST" class="headerlink" title="request.POST"></a>request.POST</h5><blockquote>
<p>获取用户以<code>post</code>形式提交的数据并保存在后台，为类字典数据，这里和<code>request.GET</code>是一个东西；</p>
<p>在网页中，一般我们通过<code>html</code>的表单进行数据的提交，<code>POST</code>方式可以提交空数据</p>
</blockquote>
<ul>
<li>因为涉及到了表单页面，所以我们先来弄一个<code>HTML</code>页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个关于POST的测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加<code>csrf_token</code>标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。</p>
</blockquote>
<blockquote>
<p>在接下来的视图函数中会使用到<code>input</code>标签中的<code>name</code>属性；</p>
<p><code>name</code>值属性维护了<code>post</code>的数据传入到后台时的标示，会与表单的数据组合成类字典格式</p>
<p>如<code>name</code>属性为<code>account</code>的输入框中输入了<code>test</code>，那么后台数据接收到的值类似：<code>{&#39;account&#39;:&#39;test&#39;}</code></p>
</blockquote>
<ul>
<li>写一个视图函数用来捕获当前表单使用POST形式提交的数据：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method=<span class="string">"POST"</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        print(type(request.POST))</span><br><span class="line">        account = request.POST.get(<span class="string">"account"</span>)</span><br><span class="line">        passwd = request.POST.get(<span class="string">"passwd"</span>)</span><br><span class="line">        content = <span class="string">"%s:%s"</span> % (account,passwd)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(content)</span><br><span class="line">   	<span class="keyword">return</span> render(request,<span class="string">"index.html"</span>) <span class="comment">#在使用get形式请求时，返回表单页面</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2&apos;], &apos;account&apos;: [&apos;test&apos;], &apos;passwd&apos;: [&apos;123456&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure>

<h6 id="表单夺表提交"><a href="#表单夺表提交" class="headerlink" title="表单夺表提交"></a>表单夺表提交</h6><blockquote>
<p>在<code>request.POST</code>中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框<code>CheckBox</code>，直接使用<code>request.POST.get()</code>进行获取是有一些问题的，比如修改模板页`面如下所示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"eat"</span>&gt;</span>吃</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"sleep"</span>&gt;</span>睡</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"play"</span>&gt;</span>耍</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个<code>name</code>值为<code>taste</code>的兴趣爱好采集的多选框，<code>value</code>值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;QueryDict: &#123;&apos;csrfmiddlewaretoken&apos;: [&apos;nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k&apos;], &apos;taste&apos;: [&apos;eat&apos;, &apos;sleep&apos;, &apos;play&apos;]&#125;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是问题接踵而至，我们发现使用<code>get</code>函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项</p>
</blockquote>
<ul>
<li><p><code>request.POST.get(key, default=None)</code></p>
<blockquote>
<p>返回对应<code>key</code>值的数据中的<strong>最后一个</strong>数据单独返回；<code>key</code>值不存在，取<code>default</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>要想真正拿出所有的结果，应该使用<code>getlist</code>函数</p>
</blockquote>
<ul>
<li><p><code>request.POST.getlist(key, default=None)</code></p>
<blockquote>
<p>将对应<code>key</code>值的所有数据以<strong>一个列表</strong>形式返回；<code>key</code>值不存在，取<code>default</code></p>
</blockquote>
</li>
</ul>
<h5 id="request-META"><a href="#request-META" class="headerlink" title="request.META"></a>request.META</h5><blockquote>
<p><code>request.MAT</code>E获取的是一个标准的<code>python</code>字典。它包含了所有的<code>HTTP</code>请求信息</p>
<p>比如用户IP地址和用户<code>Agent</code>（通常是浏览器的名称和版本号）。</p>
<p>注意，<code>Header</code>信息的完整列表取决于用户所发送的<code>Header</code>信息和服务器端设置的<code>Header</code>信息</p>
</blockquote>
<ul>
<li><code>CONTENT_LENGTH</code>：请求的正文的长度，字符串类型</li>
<li><code>CONTENT_TYPE</code>：请求的正文的<code>MIME</code> 类型</li>
<li><code>HTTP_ACCEPT</code>：响应可接收的<code>Content-Type</code></li>
<li><code>HTTP_ACCEPT_ENCODING</code>：响应可接收的编码</li>
<li><code>HTTP_ACCEPT_LANGUAGE</code>：响应可接收的语言</li>
<li><code>HTTP_HOST</code>：客服端发送的<code>HTTP Host</code>头部</li>
<li><code>HTTP_REFERER</code>：请求前的连接地址</li>
<li><code>HTTP_USER_AGENT</code>：客户端的<code>user-agent</code>字符串</li>
<li><code>QUERY_STRING</code>：单个字符串形式的查询字符串（未解析过的形式）</li>
<li><code>REMOTE_ADDR</code>：客户端的IP 地址</li>
<li><code>REMOTE_HOST</code>：客户端的主机名</li>
<li><code>REMOTE_USER</code>：服务器认证后的用户</li>
<li><code>REQUEST_METHOD</code>：一个字符串，例如<code>GET</code> 或<code>POST</code></li>
<li><code>SERVER_NAME</code>：服务器的主机名</li>
<li><code>SE0RVER_PORT</code>：服务器的端口，字符串类型</li>
</ul>
<h5 id="request-FILES"><a href="#request-FILES" class="headerlink" title="request.FILES"></a>request.FILES</h5><blockquote>
<p>接收用户上传文件及相关信息。同样类似于<code>request.POST</code>，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息</p>
</blockquote>
<ul>
<li><p><code>f = request.FILES.get(&#39;upload_file&#39;)</code></p>
<blockquote>
<p><code>file_data = f.read()</code>：读取整个上传文件的内容，适合小文件上传</p>
<p><code>yiled = f.chunks()</code>：返回一个类似生成器<code>（&lt;class &#39;generator&#39;&gt;）</code>的数据，每一次读取按块返回文件，可以通过<code>for</code>迭代访问其中数据；适合上传大文件到服务器。</p>
<p><code>f.multiple_chunks()</code>：返回文件大小，当文件大小大于<code>2.5M</code>时，返回<code>True</code>，反之返回<code>False</code>，可以通过该函数来选择是否使用<code>chunks</code>方法或<code>read</code>直接存储。</p>
<p>如果想要修改这个文件判定的默认值，可以通过：<code>FILE_UPLOAD_MAX_MEMORY_SIZE</code>在<code>settings</code>文件下进行设置</p>
<p><code>f.content_type</code>：上传文件时头部中的<code>Content-Type</code>字段值，参考MIME类型</p>
<p><code>f.name</code>：上传文件名字</p>
<p><code>f.charset</code>：上传文件编码</p>
<p><code>f.size</code>： 上传文件大小，字节为单位：<code>byte</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>创建好静态资源目录，并在下面创建一个<code>img</code>文件夹，保存我们即将上传的图片；</p>
<p>完成上传文件的<code>HTML</code>表单页面</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload_file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'img/1.jpg' %&#125;"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：上传文件的页面表单，一定要记得设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p>
</blockquote>
<ul>
<li>视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        f = request.FILES.get(<span class="string">"upload_files"</span>)</span><br><span class="line">        path = os.path.join(settings.STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/'</span>+f.name)</span><br><span class="line">  		<span class="comment"># 上传文件本地保存路径</span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">if</span> f.multiple_chunks: <span class="comment">#判断到上传文件为大于2.5MB的大文件</span></span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> f.chunks(): <span class="comment">#迭代写入文件</span></span><br><span class="line">                    fp.write(buf)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fp.write(f.read())</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"Success!"</span>)</span><br><span class="line">  	<span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试上传一个名为<code>1.jpg</code>的图片，如果成功上传，那么后台<code>static</code>目录下会出现该图片，并且模板页面也可以展示对应图片效果</p>
</blockquote>
<h4 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h4><blockquote>
<p>一个视图的返回值经常是为了向用户返回一个<code>HttpResponse</code>响应，</p>
<p>有如下常用的可以返回<code>HttpResponse</code>的函数</p>
</blockquote>
<h5 id="response"><a href="#response" class="headerlink" title="response"></a>response</h5><ul>
<li><p><code>HttpResponse(content=b&#39;&#39;)</code></p>
<blockquote>
<p>返回一个字符串内容</p>
<p><em>from</em> django.http <em>import</em> HttpResponse</p>
</blockquote>
</li>
<li><p><code>render(request,template_name,context=None,content_type=None,status=None)</code></p>
<blockquote>
<p>返回一个可渲染HTML页面，状态码为<code>200</code></p>
<p><em>from</em> django.shortcuts <em>import</em> render</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request`：固定参数，响应的`request`请求，来自于参数部分接收的`HttpRequest</span><br></pre></td></tr></table></figure>

<p><code>template_name</code>：返回的模板页面路径</p>
<p><code>context</code>：模板页面渲染所需的数据，默认为字典格式</p>
<p><code>content_type</code>：生成之后的结果使用的<code>MIME</code>类型</p>
<p><code>status</code>：响应的状态码，默认为<code>200</code></p>
</blockquote>
</li>
<li><p>redirect(to, permanent=False)</p>
<blockquote>
<p>一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码<code>302</code></p>
<p><em>from</em> django.shortcuts <em>import</em> redirect</p>
</blockquote>
<blockquote>
<p><code>to</code>：可以是一个<code>django</code>项目中视图函数的路由映射，也可以是一个<code>reverse</code>的反向路由解析</p>
<p><code>permanent</code>：如果设置为<code>True</code>，将返回<code>301</code>状态码，代表永久重定向</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">302</span>：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。</span><br><span class="line"><span class="number">301</span>：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图错误处理"><a href="#视图错误处理" class="headerlink" title="视图错误处理"></a>视图错误处理</h4><blockquote>
<p>为了方便我们开发，<code>django</code>提供了一个异常叫做<code>Http404</code>异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后<code>django</code>项目会自动捕获该异常，并会展示默认的<code>404</code>页面</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.GET.get(<span class="string">"id"</span>) == <span class="string">"1"</span>:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>settings</code>中的<code>debug</code>配置项为<code>false</code>时，访问<code>http://127.0.0.1:8000/?id=1</code>，可以看到<code>django</code>为我们提供的错误页面；</p>
<p>除了<code>django</code>默认提供的，我们还可以可以在模板目录下定义全局<code>404.html</code>进行错误页面的定制</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    抱歉，找不到你要的东西</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义错误处理视图"><a href="#自定义错误处理视图" class="headerlink" title="自定义错误处理视图"></a>自定义错误处理视图</h5><blockquote>
<p>除去<code>404</code>错误的自定义，<code>django</code>还提供了覆盖默认错误行为处理的办法；</p>
<p>有些时候，<code>django</code>自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数，</p>
<p>来覆盖掉<code>django</code>所提供的错误处理视图函数，最后在<code>urls.py</code>路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler404：覆盖page_not_found()视图。</span><br><span class="line">handler500：覆盖server_error()视图。</span><br><span class="line">handler403：覆盖permission_denied()视图。	</span><br><span class="line">handler400：覆盖bad_request()视图。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">"viewapp.urls"</span>)),</span><br><span class="line">]</span><br><span class="line">handler404 = <span class="string">"viewapp.views.error_404"</span></span><br><span class="line"><span class="comment"># APP.模块.视图函数</span></span><br><span class="line">handler500 = <span class="string">"viewapp.views.error_500"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关定义好的错误处理视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是404错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_403</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是403错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_500</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是500错误"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django初识</title>
    <url>/2005/01/01/Django%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h4 id="开始玩耍Django"><a href="#开始玩耍Django" class="headerlink" title="开始玩耍Django"></a>开始玩耍Django</h4><blockquote>
<p><em>Django</em>是一个开放源代码的<code>Web</code>应用框架，由<code>Python</code>写成。采用了<code>MVT</code>的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是<code>CMS</code>（内容管理系统）软件</p>
<p>框架是以比利时的吉普赛爵士吉他手<code>Django Reinhardt</code>来命名的</p>
</blockquote><a id="more"></a>
<h5 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h5><blockquote>
<p><code>pip install django==2.0.4</code>(版本号)</p>
<p><code>pip install django</code>默认安装最新版本</p>
</blockquote>
<h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><blockquote>
<p><code>django-admin startproject myproject</code></p>
</blockquote>
<h5 id="开启开发服务器"><a href="#开启开发服务器" class="headerlink" title="开启开发服务器"></a>开启开发服务器</h5><blockquote>
<p><code>cd myproject</code>：进入项目目录</p>
<p><code>python manage.py runserver</code>：开启服务</p>
<p><code>python manage.py runserver 7000</code>：改变服务监听端口</p>
<p><code>python manage.py runserver 0:8000</code>：改变服务监听IP:端口</p>
</blockquote>
<h5 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">manage.py：用来管理当前项目的一个命令行工具</span><br><span class="line">myproject/： 项目主文件夹</span><br><span class="line">myproject/__init__.py：空文件，用来指明当前的myproject为一个可导入的模块包</span><br><span class="line">myproject/settings.py：项目主要配置文件</span><br><span class="line">myproject/urls.py：项目主要路由配置文件</span><br><span class="line">myproject/wsgi.py：项目部署WSGI并发服务器时所需要的配置文件</span><br></pre></td></tr></table></figure>

<h5 id="Settings-py"><a href="#Settings-py" class="headerlink" title="Settings.py"></a>Settings.py</h5><blockquote>
<p>该文件是整个项目的主控文件，其中相关配置选项如下</p>
<p><code>https://docs.djangoproject.com/zh-hans/2.1/ref/settings/</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径</span><br><span class="line">- SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥</span><br><span class="line">- DEBUG: 调试模式</span><br><span class="line">- ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。</span><br><span class="line">- INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！</span><br><span class="line">- MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等</span><br><span class="line">	- SecurityMiddleware: xss脚本过滤，一些安全设置</span><br><span class="line">	- SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器</span><br><span class="line">	- CommonMiddleware: 通用组件，比如为路由添加末尾斜杠</span><br><span class="line">	- CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值</span><br><span class="line">	- AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性</span><br><span class="line">	- MessageMiddleware: 消息中间件 展示一些后台消息给前端</span><br><span class="line">	- XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗</span><br><span class="line">- ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径</span><br><span class="line">- TEMPLATES: 模板文件配置项</span><br><span class="line">- WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件</span><br><span class="line">- DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库</span><br><span class="line">- AUTH_PASSWORD_VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义</span><br><span class="line">- LANGUAGE_CODE: django所使用语言文件</span><br><span class="line">- TIME_ZONE: django所使用时区</span><br><span class="line">- USE_I18N: 国际化支持 <span class="number">18</span>表示Internationalization这个单词首字母I和结尾字母N之间的字母有<span class="number">18</span>个</span><br><span class="line">- USE_L10N: 是localization的缩写形式，意即在l和n之间有<span class="number">10</span>个字母</span><br><span class="line">- USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括<span class="keyword">print</span>显示的时间将是是UTC时间格式</span><br><span class="line">- STATIC_URL: URL访问静态资源时的路径</span><br></pre></td></tr></table></figure>

<h4 id="来搞个Hello-World"><a href="#来搞个Hello-World" class="headerlink" title="来搞个Hello World"></a>来搞个Hello World</h4><h5 id="django创建子应用"><a href="#django创建子应用" class="headerlink" title="django创建子应用"></a>django创建子应用</h5><blockquote>
<p>项目和应用有啥区别？</p>
<p>应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序</p>
<p>项目则是一个网站使用的配置和应用的集合。项目可以包含很多个<code>app</code>应用，应用可以被很多个项目使用</p>
</blockquote>
<ul>
<li><p><code>python manage.py startapp myapp</code></p>
<blockquote>
<p>创建子应用</p>
</blockquote>
</li>
</ul>
<h5 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- admin.py: app在admin注册展示时需要的文件</span><br><span class="line">- views.py: app的功能视图函数文件</span><br><span class="line">- models.py: app需要使用数据库时的文件</span><br><span class="line">- urls.py: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的</span><br></pre></td></tr></table></figure>

<h5 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h5><blockquote>
<p>打开<code>app</code>下的<code>views.py</code>文件</p>
<p><code>Web</code>访问起始就是通过一个<code>URL</code>连接地址访问到服务器上的一个函数</p>
<p>在<code>views.py</code>中我们通过编写函数的形式，接收用户请求的<code>request</code>并返回一个<code>response</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每一个视图函数都需要有一个必须参数 request,用来接收用户访问时的请求内容</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello world&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HttpResponse</code>函数用来向用户返回一个字符串</li>
</ul>
<h5 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h5><blockquote>
<p>创建好了一个可以在请求时返回<code>H1</code>标签的视图函数，但是现在通过浏览器还是访问不到</p>
<p>需要我们为这个<code>app</code>下的函数进行路由配置</p>
</blockquote>
<blockquote>
<p>第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls), <span class="comment">#admin控制界面路由</span></span><br><span class="line">    path(<span class="string">''</span>,views.index) </span><br><span class="line">    <span class="comment">#path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时</span></span><br><span class="line">    <span class="comment">#第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来访问<code>127.0.0.1:8000</code>，那么你会看到一个非常大的<code>Hello world</code></li>
</ul>
<blockquote>
<p>以上将视图函数的查找直接写到主控路由并不是最好的办法</p>
<p>我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护</p>
</blockquote>
<ul>
<li>我们可以在对应<code>app</code>下创建一个子路由控制文件，并在其中设置视图的路由配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">""</span>,views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在虽然配置了<code>app</code>下的路由文件，但是访问时，是看不到对应视图的结果</p>
<p>这是因为默认的<code>url</code>查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置</p>
<p>让主控路由可以找到子<code>app</code>下的路由映射文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    <span class="comment">#path('',views.index)</span></span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">"myapp.urls"</span>)),</span><br><span class="line">    <span class="comment"># 函数 include() 允许引用其它 URLconfs</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！</li>
</ul>
<h6 id="路由查找流程"><a href="#路由查找流程" class="headerlink" title="路由查找流程"></a>路由查找流程</h6><ol>
<li>查找主控路由文件下的<code>urlpatterns</code>全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则</li>
<li>如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数</li>
<li>如果对应的不是一个执行函数，而是一个<code>include</code>路由包含，那么截断与此项匹配的<code>URL</code>的部分，并将剩余的路由字符串发送到<code>include</code>所包含的子路由文件中以供进一步处理</li>
<li>如果没有匹配到的任何结果，<code>django</code>默认抛出<code>Page not found (404)</code></li>
</ol>
<blockquote>
<p><strong>注意</strong>：<code>Django</code>的路由不考虑HTTP请求方式，仅根据<code>URL</code>进行路由，即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p>
</blockquote>
<h6 id="path"><a href="#path" class="headerlink" title="path"></a>path</h6><blockquote>
<p><code>path</code>函数用来处理一个路由对应的视图映射</p>
</blockquote>
<ul>
<li><p><code>path(route, view, name)</code></p>
<blockquote>
<p><code>route</code>： 匹配规则，是一个字符串</p>
<p><code>view</code>：对应的视图函数</p>
<p><code>name</code>：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用</p>
</blockquote>
</li>
</ul>
<h6 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h6><blockquote>
<p><code>re_path</code>是<code>path</code>函数的加强版</p>
<p>可以在<code>re_path</code>函数的第一个位置的字符串参数，是一个标准<code>Python</code>正则表达式，其余参数与<code>path</code>相同</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个<code>url</code>都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的<code>/</code></p>
</blockquote>
<h5 id="模板页面"><a href="#模板页面" class="headerlink" title="模板页面"></a>模板页面</h5><blockquote>
<p>返回一个字符串这肯定是不行的，太<code>low</code>了，也不好看，现在来返回一个正式的<code>HTML</code>页面</p>
<p>并在<code>HTML</code>页面中加入模板变量，由视图函数动态传递值；</p>
</blockquote>
<ul>
<li>配置<code>django</code>中模板页面的保存路径，在项目目录下的<code>settings.py</code>文件中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'template'</span>)], <span class="comment"># 就是这一行 设置静态模板路径</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>创建template</code>目录并在其中创建<code>index.html</code>文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>HTML</code>页面中，我们并没有明确指出<code>H1</code>标签的内容；通过一个``来等待接收视图函数传来的数据，在<code>HTML</code>页面中这样的变量也叫做<strong>模板变量</strong>，双大括号为使用语法</p>
</blockquote>
<ul>
<li>接下来修改之前的视图函数，由视图函数传递变量给到<code>HTML</code>页面</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#return HttpResponse("&lt;h1&gt;Hello world&lt;/h1&gt;")</span></span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"message"</span>:<span class="string">"你好，世界"</span> <span class="comment">#此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,content)</span><br></pre></td></tr></table></figure>

<h6 id="render"><a href="#render" class="headerlink" title="render"></a>render</h6><blockquote>
<p>render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染</p>
</blockquote>
<ul>
<li><p><code>render(request, template_name, context=None)</code></p>
<blockquote>
<p>返回一个HTTP响应</p>
</blockquote>
<blockquote>
<p><code>request</code>： 固定接收<code>request</code>请求</p>
<p><code>template_name</code>： 为一个可以找到的模板页面</p>
<p><code>context</code>： 模板页面所需模板变量</p>
</blockquote>
</li>
</ul>
<h6 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h6><blockquote>
<p>在<code>django</code>中的<code>HTML</code>页面，不光可以编写原本的标签等内容，还可以像<code>Vue</code>一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到<code>HTML</code>模板页面中</p>
</blockquote>
<blockquote>
<p>模板变量可以由后台视图函数构建一个<strong>字典数据类型</strong>传递，</p>
<p>字典的<code>key</code>是模板变量名，<code>value</code>值该模板变量对应的数据</p>
<p>当然，模板变量的内容远不止此，还会再后面继续为大家叙述</p>
</blockquote>
<h5 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h5><blockquote>
<p>虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋</p>
<p>我们还要继续引入一些类似<code>css、img</code>这样的静态资源，来装饰我们的页面</p>
<p>在<code>django</code>中模板页面的静态资源使用，不能像之前写<code>HTML</code>代码直接引入</p>
<p>需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为<code>static</code></p>
</blockquote>
<ul>
<li>在settings中配置静态文件保存目录，<strong>添加</strong>如下内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中创建<code>static</code>目录，<code>static</code>目录下创建专门保存图片的<code>img</code>目录，在里面存一张图片<code>1.jpg</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时的目录结构</span></span><br><span class="line">myproject/</span><br><span class="line">	myproject/</span><br><span class="line">	myapp/</span><br><span class="line">	template/</span><br><span class="line">	static/</span><br><span class="line">		img/</span><br><span class="line">			<span class="number">1.j</span>pg</span><br></pre></td></tr></table></figure>

<ul>
<li>有了图片，接下来在模板页面中去引入并使用它，打开<code>index.html</code>进行修</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;% static "img/1.jpg" %&#125;'</span> <span class="attr">alt</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里用到了一个特殊语法：&#123;% tag %&#125;这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的&#123;% if %&#125;，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能</p>
</blockquote>
<blockquote>
<p>在页面中要引入静态资源：图片，<code>CSS</code>，<code>JS</code>文件在引入时都需要通过&#123;% static “path” %&#125;来进行引入</p>
</blockquote>
<blockquote>
<p>最后，需要使用静态标签<code>static</code>前使用&#123;% load staticfiles %&#125;标签进行静态资源路径的加载</p>
</blockquote>
<h5 id="模型数据库"><a href="#模型数据库" class="headerlink" title="模型数据库"></a>模型数据库</h5><blockquote>
<p>有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据</p>
</blockquote>
<ul>
<li>创建数据库，这里使用项目自带的<code>SQLite3</code>数据库，默认已经是配置好的，接下来需要我们进入到<code>app</code>下的<code>models.py</code>文件中，编写一个类，这个类就对应数据库中的一张表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    weather = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">"天气"</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name_plural = <span class="string">"天气"</span></span><br><span class="line">        <span class="comment"># 设置当前表名的一个可读的性更好的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weather</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我们使用到了<code>django</code>的<code>orm</code>映射关系用来创建数据库表，继承自<code>django</code>的<code>models.Model</code>类，</p>
<p><strong>一个类用来表示一张表，类中的一个属性代表一个字段，</strong></p>
</blockquote>
<blockquote>
<p>这里我们定义了一个类型为<code>CharField</code>，长度为<code>100</code>的字段，用来存储天气</p>
<p><code>models.CharField(max_length=100,verbose_name=&quot;天气&quot;)</code></p>
</blockquote>
<hr>
<blockquote>
<p>下面的<code>class Meta</code>是模型类的元类，用来设置当前表的一些属性；</p>
<p>这里我们使用<code>verbose_name_plural</code>属性设置当前表在<code>admin</code>后台查看时的名字</p>
</blockquote>
<blockquote>
<p>在这里我们还定义了一个属于实例的函数<code>__str__</code>，用来描述当前数据在返回时的默认展示结果，为<code>weather</code>字段的值</p>
</blockquote>
<blockquote>
<p><code>django</code>在创建模型类对应的数据表时，默认使用 <code>应用名</code>加<code>下划线</code>加<code>模型类名</code>作为表的名字；比如当前<code>Weather</code>表名为：<code>myapp_Weather</code></p>
</blockquote>
<blockquote>
<p><code>orm</code>映射关系，是<code>django</code>与数据库之间的一个桥梁，可以使开发者不再关注如何去编写<code>SQL</code>语句，直接通过一套<code>ORM</code>所提供的<code>API</code>接口即可方便对各种数据库进行交互</p>
</blockquote>
<ul>
<li>当某个子应用<code>APP</code>涉及到了数据库的使用时，要记得在<code>settings</code>文件中进行配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来通过<code>manage.py</code>命令行管理工具提供的两条，创建我们所需要的数据</li>
</ul>
<blockquote>
<p><strong>注意</strong>：默认<code>django</code>本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的</p>
</blockquote>
<blockquote>
<p><code>python manage.py migrate</code>：根据数据库迁移文件生成对应<code>SQL</code>语句并执行</p>
<p>初次执行是为了先把默认django需要的数据库创建出来</p>
</blockquote>
<blockquote>
<p><code>python manage.py makemigrations</code>：创建数据库迁移文件</p>
<p>这次执行是为了创建APP中Weather模型类的迁移文件</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>将新添加的模型类迁移文件生成对应<code>SQL</code>，实际创建出对应的<code>Weather</code>表</p>
</blockquote>
<ul>
<li>如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到<code>django</code>为我们提供的<code>admin</code>（数据库管理界面）来进行相关表的操作了！</li>
</ul>
<h5 id="admin控制台"><a href="#admin控制台" class="headerlink" title="admin控制台"></a>admin控制台</h5><blockquote>
<p><code>admin</code>控制台是<code>django</code>为我们提供的一个非常便捷的用来管理数据库的界面</p>
<p>在主控路由文件下，其实你已经看到了它对应的路由设置：<code>path(&#39;admin/&#39;, admin.site.urls),</code></p>
</blockquote>
<blockquote>
<p>进入<code>admin</code>界面，初次访问连接：<code>127.0.0.1/admin</code>，会提示我们输入账号密码，这是因为<code>django</code>的<code>admin</code>界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的<code>admin</code>界面下的超级用户</p>
</blockquote>
<ul>
<li>创建<code>admin</code>超级用户，使用<code>manage.py</code>命令行工具执行如下命令</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Username (leave blank to use <span class="string">'lienze'</span>): root</span><br><span class="line">Email address:</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too short. It must contain at least <span class="number">8</span> characters.</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">This password <span class="keyword">is</span> too common.</span><br><span class="line">This password <span class="keyword">is</span> entirely numeric.</span><br><span class="line">Password:</span><br><span class="line">Password (again):</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是我们创建超级用户的过程，非常坎坷；</p>
<p>可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的</p>
<p>所以我们把用户账号创建为<code>root</code>，而密码创建为<code>a1234567</code>，</p>
</blockquote>
<ul>
<li>接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的<code>admin</code>界面啦</li>
</ul>
<blockquote>
<p><code>admin</code>界面已经展示出了默认<code>django</code>所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的<code>root</code>。</p>
</blockquote>
<h5 id="admin注册表"><a href="#admin注册表" class="headerlink" title="admin注册表"></a>admin注册表</h5><blockquote>
<p>问题还是有的，虽然<code>admin</code>界面已经可以登入，但是为什么看不到刚才创建的<code>Weather</code>表呢</p>
<p>这是因为默认的表创建之后，还需要通过对应app下的<code>admin.py</code>文件进行<code>admin</code>后台注册，只有注册在这个文件中的模型类对应的表才可以在<code>admin</code>界面所看到</p>
</blockquote>
<ul>
<li>在app下的admin.py文件中进行模型类的注册</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">admin.site.register(models.Weather)</span><br><span class="line"><span class="comment">#使用register函数接收模型类作为参数即可完成注册</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注册成功之后，在服务器，通过浏览器访问<code>admin</code>界面，就可以看到创建好的<code>Weather</code>表了</p>
</blockquote>
<ul>
<li>鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">阴天，晴天，打雷了</span><br></pre></td></tr></table></figure>

<h5 id="视图操作模型"><a href="#视图操作模型" class="headerlink" title="视图操作模型"></a>视图操作模型</h5><blockquote>
<p>最终我们希望可以在视图函数中通过<code>orm</code>接口来访问到表中的数据，那么来打开视图文件吧：<code>views.py</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    </span><br><span class="line">    weathers = models.Weather.objects.all()</span><br><span class="line">    content = &#123;</span><br><span class="line">        <span class="string">"weathers"</span>:weathers,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, content)</span><br></pre></td></tr></table></figure>

<ul>
<li>光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的<code>HTML</code>页面哦：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for weather in weathers %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; weather &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有任何天气<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板标签&#123;% for xxx in xxxs %&#125;可以用来在模板页面出迭代访问取出每一个数据</p>
<p>具体对于不同序列数据的访问我们会在后面详细为大家介绍</p>
<p>&#123;% empty %&#125;标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有&#123;% endfor %&#125;标签进行结束；因为<code>HTML</code>中并没有像<code>Python</code>缩进这样的方式来控制代码块。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>至此，我们的<code>HELLO WORLD</code>项目已经涵盖了<code>django</code>框架中的大部分常用的组件；</p>
<p><strong>路由</strong>、<strong>视图</strong>、<strong>模板</strong>、<strong>静态</strong>、<strong>模型</strong>，<strong>admin</strong></p>
<p>那么其中每一部分都还有很多内容等着我们去了解！</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码</title>
    <url>/2000/01/01/Python/</url>
    <content><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
</blockquote><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(blist)</span>:</span></span><br><span class="line">    count = len(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] = blist[j], blist[i]</span><br><span class="line">    <span class="keyword">return</span> blist</span><br><span class="line"></span><br><span class="line">blist = bubble_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">print(blist)</span><br></pre></td></tr></table></figure>

<h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><blockquote>
<p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(nlog₂n)</p>
<p>稳定性：不稳定</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]    <span class="comment">#找到一个基准值</span></span><br><span class="line">        <span class="comment">#遍历整个列表，将小于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#遍历整个列表，将大于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line">        <span class="comment">#首先，明确我们对元素为0个/1个的列表无需要排序</span></span><br><span class="line">        <span class="comment">#使用函数递归</span></span><br><span class="line">        <span class="comment">#目标：让我们在一个基准值的一侧变为有序，然后依次返回，让我们的每个基准值的两侧都变得有序</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less)+[pivot]+quicksort(greater)</span><br><span class="line"><span class="comment">#这是一些测试样例</span></span><br><span class="line">print(quicksort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">11</span>]))</span><br><span class="line">print(quicksort([<span class="number">152</span>,<span class="number">134</span>,<span class="number">38796</span>,<span class="number">7438415</span>,<span class="number">1</span>,<span class="number">2272</span>,<span class="number">34345</span>,<span class="number">24</span>,<span class="number">127</span>]))</span><br></pre></td></tr></table></figure>

<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><blockquote>
<p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p>
<p>优点：对唯一实例的受控访问，相当于全局变量，但是又可以防止变量被篡改</p>
<p>通过<strong>new</strong>方法，将类的实例在创建的时候绑定到类属性_inst上。如果cls._inst为None，说明类还未实例化，实例化并将实例绑定到cls._inst，以后每次实例化的时候都返回第一次实例化创建的实例。注意从Singleton派生子类的时候，不要重载<strong>new</strong>。</p>
<p>因为类每一次实例化后产生的过程都是通过<strong>new</strong>来控制的，所以通过重载<strong>new</strong>方法，我们 可以很简单的实现单例模式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) , id(single2))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>new</strong>方法</p>
<p>使用类名()创建对象时，Python的解释器首先会调用<strong>new</strong>方法为对象分配空间</p>
<p><strong>new</strong>是一个有object基类提供的内置的静态方法，主要作用有两个：</p>
<p>1）在内存中为对象分配空间</p>
<p>2）返回对象的引用</p>
<p>Python的解释器获得对象的引用后，将引用作为第一个参数，传递给<strong>init</strong>方法。</p>
<p><strong>重写<strong>new</strong>方法的代码非常固定</strong></p>
<ul>
<li>重写<strong>new</strong>方法一定要return super.<strong>new</strong>(cls)</li>
<li>否则Python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li>
<li>注意：<strong>new</strong>是一个静态方法，在调用时需要主动传递参数cls</li>
<li><strong>new</strong>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供</li>
</ul>
</blockquote>
<h4 id="递归斐波那契书列"><a href="#递归斐波那契书列" class="headerlink" title="递归斐波那契书列"></a>递归斐波那契书列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fun(i<span class="number">-2</span>) + fei(i<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(fun(i),end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>

<h4 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">        i = os.path.join(p,i)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(i):</span><br><span class="line">            <span class="keyword">return</span> fun(i)</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(i)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">                <span class="keyword">print</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> fun(i)</span><br><span class="line">path = unicode(<span class="string">r'F:\My Study\linux学习笔记\test'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">f(path)</span><br></pre></td></tr></table></figure>

<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote>
<p>闭包的定义：</p>
<p>在一个外函数中定义了一个内函数</p>
<p>内函数里运用了外函数的临时变量</p>
<p>并且外函数的返回值是内函数的引用。</p>
<p>这样就构成了一个闭包。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        b = a + <span class="number">10</span></span><br><span class="line">        print(<span class="string">"b ="</span>,b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">outer()()</span><br></pre></td></tr></table></figure>

<h4 id="装饰器测试程序运行时间"><a href="#装饰器测试程序运行时间" class="headerlink" title="装饰器测试程序运行时间"></a>装饰器测试程序运行时间</h4><blockquote>
<p>使用装饰器测试（1000以内的三个数，相加等于1000的情况，有多少组）这个案例的运行时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        s_time = time.time() <span class="comment">#获取程序运行的开始时间</span></span><br><span class="line">        fun()    <span class="comment">#运行程序</span></span><br><span class="line">        e_time = time.time() <span class="comment">#获取程序运行的结束时间</span></span><br><span class="line">        <span class="keyword">return</span> e_time-s_time</span><br><span class="line">    <span class="keyword">return</span> inner   </span><br><span class="line"></span><br><span class="line"><span class="meta">@time_</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">            c = <span class="number">1000</span> - a - b</span><br><span class="line">            <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == c ** <span class="number">2</span>:</span><br><span class="line">                print(<span class="string">"a = %d , b = %d , c = %d"</span> % (a,b,c)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(func())</span><br></pre></td></tr></table></figure>

<h4 id="python树-实现先中后遍历和层次遍历"><a href="#python树-实现先中后遍历和层次遍历" class="headerlink" title="python树,实现先中后遍历和层次遍历"></a>python树,实现先中后遍历和层次遍历</h4><blockquote>
<p>广度遍历：层次遍历</p>
<p>深度遍历：先、中、后序遍历</p>
<p>层次遍历：一层一层的遍历</p>
<p>先序遍历：依据 <strong>根–左–右</strong> 的顺序遍历</p>
<p>中序遍历：依据 <strong>左–根–右</strong> 的顺序遍历</p>
<p>后序遍历：依据 <strong>左–右–根</strong> 的顺序遍历</p>
<p>遍历这棵树：</p>
</blockquote>
<p><img src="/2000/01/01/Python/shu.jpg" alt="树"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''树的节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span>  <span class="comment">#左孩子</span></span><br><span class="line">        self.rchild = <span class="literal">None</span>  <span class="comment">#右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span>    <span class="comment"># 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''添加的方法'''</span></span><br><span class="line">        node = Node(item)   <span class="comment"># 先构造一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment">#     如果是空树 直接添加元素</span></span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]  <span class="comment"># 一个队列 用来存放的就是要遍历和处理的元素</span></span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment">#队列只要不为空 就始终能拿出节点进行判断</span></span><br><span class="line">            <span class="comment"># 先从队列中取出一个节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 看当前这个节点左边的孩子是否为空 如果是空 直接挂节点</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不为空则认定左孩子存在 追加到队列</span></span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 查看节点右孩子 与左孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breadth_trvael</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''层次遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment"># 只要队列不为空就一直取元素</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem,end=<span class="string">' '</span>)</span><br><span class="line">            <span class="comment"># 如果左孩子存在 添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 右孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, node)</span>:</span>   <span class="comment">#传一个根节点</span></span><br><span class="line">        <span class="string">'''先序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:    <span class="comment">#递归的终结条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem,end=<span class="string">' '</span>)    <span class="comment">#先打印根</span></span><br><span class="line">        self.preorder(node.lchild)  <span class="comment">#处理左半部分</span></span><br><span class="line">        self.preorder(node.rchild)  <span class="comment">#处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''中序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment">#输出根</span></span><br><span class="line">        self.inorder(node.rchild)  <span class="comment">#再处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''后序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        self.postorder(node.rchild)  <span class="comment"># 然后处理右半部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment"># 最后输出根</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tree = Tree()</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    tree.add(<span class="number">0</span>)</span><br><span class="line">    tree.add(<span class="number">1</span>)</span><br><span class="line">    tree.add(<span class="number">2</span>)</span><br><span class="line">    tree.add(<span class="number">3</span>)</span><br><span class="line">    tree.add(<span class="number">4</span>)</span><br><span class="line">    tree.add(<span class="number">5</span>)</span><br><span class="line">    tree.add(<span class="number">6</span>)</span><br><span class="line">    tree.add(<span class="number">7</span>)</span><br><span class="line">    tree.add(<span class="number">8</span>)</span><br><span class="line">    tree.add(<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'层次遍历：'</span>)</span><br><span class="line">    tree.breadth_trvael()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'先序遍历：'</span>)</span><br><span class="line">    tree.preorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'中序遍历：'</span>)</span><br><span class="line">    tree.inorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'后序遍历：'</span>)</span><br><span class="line">    tree.postorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span>    <span class="comment">#如果头节点为空 列表就为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        cur = self.head <span class="comment">#cur游标 用来移动遍历节点</span></span><br><span class="line">        count = <span class="number">0</span>        <span class="comment">#记录数量</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next    <span class="comment">#移动游标</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历整个链表'''</span></span><br><span class="line">        cur = self.head <span class="comment">#代表第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''在链表头部添加元素，头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.head   <span class="comment"># 新元素的下一个节点指向链表第一个元素</span></span><br><span class="line">        self.head = node    <span class="comment">#头节点指向新元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''向链表的尾部添加元素,尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment">#如果链表为空</span></span><br><span class="line">            self.head = node    <span class="comment">#头节点指向添加的元素</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#不为空</span></span><br><span class="line">            cur = self.head     <span class="comment"># 游标</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>: <span class="comment"># 游标下一个位置不为空开始进入循环 为空则不进入循环</span></span><br><span class="line">                cur = cur.next  <span class="comment"># 游标移动</span></span><br><span class="line">            cur.next = node <span class="comment">#当游标下一位置为空时添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span>    <span class="comment"># 传入一个插入位置pos 一个插入元素item</span></span><br><span class="line">        <span class="string">'''指定位置添加元素'''</span></span><br><span class="line">        <span class="comment"># 如果添加位置在头部 直接使用头插入方法</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span> :</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):   <span class="comment">#插入位置超出列表范围 使用尾插法</span></span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 当循环退出后cur指向 pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''删除元素,根据具体的数据删除'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span>    <span class="comment"># 前一位置</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断子节点是否为头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = cur.next <span class="comment"># 直接改变头指针指向的地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next <span class="comment"># 如果删除尾部 cur.next刚好指向none</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:  <span class="comment"># 列表不为空时</span></span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    ll.append(<span class="number">2</span>)    <span class="comment">#尾部添加</span></span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)   <span class="comment">#头部添加</span></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'开始遍历链表元素：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="comment"># 删除一个元素</span></span><br><span class="line">    ll.remove(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'删除后遍历：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<h4 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h4><blockquote>
<p>栈和队列是两种基本的数据结构，同为容器类型。两者根本的区别在于： </p>
<p><strong>栈stack:</strong>后进先出</p>
</blockquote>
<p><img src="/2000/01/01/Python/zhan.jpg" alt="栈"></p>
<blockquote>
<p><strong>队列queue:</strong>先进先出</p>
</blockquote>
<p><img src="/2000/01/01/Python/duilie.jpg" alt="队列"></p>
<blockquote>
<p><strong>栈的构造</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Stack() 创建一个新的空栈</span></span><br><span class="line"><span class="string">push(item) 添加一个新的元素item到栈顶</span></span><br><span class="line"><span class="string">pop() 弹出栈顶元素</span></span><br><span class="line"><span class="string">peek() 返回栈顶元素</span></span><br><span class="line"><span class="string">is_empty() 判断栈是否为空</span></span><br><span class="line"><span class="string">size() 返回栈的元素个数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""栈类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空栈"""</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""添加一个新的元素到栈顶"""</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断栈是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈元素的个数"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">6</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    print(s.stack)</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>队列的构造</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Queue() 创建一个空的队列</span></span><br><span class="line"><span class="string">enqueue(item) 往队列中添加一个item元素</span></span><br><span class="line"><span class="string">dequeue() 从队列头部删除一个元素</span></span><br><span class="line"><span class="string">is_empty() 判断一个队列是否为空</span></span><br><span class="line"><span class="string">size() 返回队列的大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空队列"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素"""</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ie_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断一个队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    q.enqueue(<span class="number">6</span>)</span><br><span class="line">    q.enqueue(<span class="number">7</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
